import * as i0 from '@angular/core';
import { ChangeDetectorRef, Component, Injector, Input, InjectionToken, Injectable, Inject, Optional, SkipSelf, isDevMode, NgZone, Directive, ElementRef, EventEmitter, Output, TemplateRef, ViewContainerRef, IterableDiffers, Self, Renderer2, ComponentFactoryResolver, Pipe, NgModule, LOCALE_ID, APP_INITIALIZER, NgModuleFactory, Compiler, ApplicationRef, inject } from '@angular/core';
import * as i1 from '@angular/router';
import { PRIMARY_OUTLET, Router, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ActivatedRoute, RouterModule } from '@angular/router';
import { registerLocaleData, CommonModule } from '@angular/common';
import { BehaviorSubject, Subject, throwError, from, Subscription, fromEvent, of, timer, pipe, Observable, concat, ReplaySubject } from 'rxjs';
import { map, distinctUntilChanged, filter, catchError, tap, take, switchMap, mapTo, debounceTime, takeUntil, finalize, retryWhen, delay, shareReplay } from 'rxjs/operators';
import { __rest, __awaiter, __decorate } from 'tslib';
import * as i2 from '@angular/common/http';
import { HttpClient, HttpHeaders, HttpClientModule, HttpClientXsrfModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import * as i4 from '@ngxs/store';
import { Store, Action, Selector, State, NgxsModule, createSelector } from '@ngxs/store';
import compare from 'just-compare';
import snq from 'snq';
import { FormGroupDirective, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import * as i1$1 from 'angular-oauth2-oidc';
import { OAuthService, OAuthStorage, OAuthErrorEvent, OAuthInfoEvent, OAuthModule } from 'angular-oauth2-oidc';
import clone from 'just-clone';

// Not an abstract class on purpose. Do not change!
// tslint:disable-next-line: use-component-selector
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@ngxs/store';
import * as ɵngcc3 from '@angular/router';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from '@angular/forms';
import * as ɵngcc6 from 'angular-oauth2-oidc';

function DynamicLayoutComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function DynamicLayoutComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "router-outlet");
} }
function DynamicLayoutComponent_ng_template_3_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 4);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngComponentOutlet", ctx_r5.layout);
} }
function DynamicLayoutComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DynamicLayoutComponent_ng_template_3_ng_container_0_Template, 1, 1, "ng-container", 3);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.isLayoutVisible);
} }
function ReplaceableRouteContainerComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
class AbstractNgModelComponent {
    constructor(injector) {
        this.injector = injector;
        this.valueFn = value => value;
        this.valueLimitFn = value => false;
        // tslint:disable-next-line: deprecation
        this.cdRef = injector.get(ChangeDetectorRef);
    }
    set value(value) {
        value = this.valueFn(value, this._value);
        if (this.valueLimitFn(value, this._value) !== false || this.readonly)
            return;
        this._value = value;
        this.notifyValueChange();
    }
    get value() {
        return this._value || this.defaultValue;
    }
    get defaultValue() {
        return this._value;
    }
    notifyValueChange() {
        if (this.onChange) {
            this.onChange(this.value);
        }
    }
    writeValue(value) {
        this._value = this.valueLimitFn(value, this._value) || value;
        setTimeout(() => this.cdRef.markForCheck(), 0);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
AbstractNgModelComponent.ɵfac = function AbstractNgModelComponent_Factory(t) { return new (t || AbstractNgModelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
AbstractNgModelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AbstractNgModelComponent, selectors: [["ng-component"]], inputs: { valueFn: "valueFn", valueLimitFn: "valueLimitFn", value: "value", disabled: "disabled", readonly: "readonly" }, decls: 0, vars: 0, template: function AbstractNgModelComponent_Template(rf, ctx) { }, encapsulation: 2 });
AbstractNgModelComponent.ctorParameters = () => [
    { type: Injector }
];
AbstractNgModelComponent.propDecorators = {
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    valueFn: [{ type: Input }],
    valueLimitFn: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @deprecated Use ConfigStateService. To be deleted in v5.0.
 */
class GetAppConfiguration {
}
GetAppConfiguration.type = '[Config] Get App Configuration';
/**
 * @deprecated Use EnvironmentService instead. To be deleted in v5.0.
 */
class SetEnvironment {
    constructor(environment) {
        this.environment = environment;
    }
}
SetEnvironment.type = '[Config] Set Environment';
/**
 * @deprecated Use EnvironmentService instead. To be deleted in v5.0.
 */
class PatchConfigState {
    constructor(state) {
        this.state = state;
    }
}
PatchConfigState.type = '[Config] Set State';

class StartLoader {
    constructor(payload) {
        this.payload = payload;
    }
}
StartLoader.type = '[Loader] Start';
class StopLoader {
    constructor(payload) {
        this.payload = payload;
    }
}
StopLoader.type = '[Loader] Stop';

class GetProfile {
}
GetProfile.type = '[Profile] Get';
class UpdateProfile {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateProfile.type = '[Profile] Update';
class ChangePassword {
    constructor(payload) {
        this.payload = payload;
    }
}
ChangePassword.type = '[Profile] Change Password';

class RestOccurError {
    constructor(payload) {
        this.payload = payload;
    }
}
RestOccurError.type = '[Rest] Error';

const CORE_OPTIONS = new InjectionToken('CORE_OPTIONS');
function coreOptionsFactory(_a) {
    var options = __rest(_a, []);
    return Object.assign({}, options);
}

function noop() {
    // tslint:disable-next-line: only-arrow-functions
    const fn = function () { };
    return fn;
}
function isUndefinedOrEmptyString(value) {
    return value === undefined || value === '';
}
function isNullOrUndefined(obj) {
    return obj === null || obj === undefined;
}
function exists(obj) {
    return !isNullOrUndefined(obj);
}
function isObject(obj) {
    return obj instanceof Object;
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isObjectAndNotArray(obj) {
    return isObject(obj) && !isArray(obj);
}
function isNode(obj) {
    return obj instanceof Node;
}
function isObjectAndNotArrayNotNode(obj) {
    return isObjectAndNotArray(obj) && !isNode(obj);
}

function deepMerge(target, source) {
    if (isObjectAndNotArrayNotNode(target) && isObjectAndNotArrayNotNode(source)) {
        return deepMergeRecursively(target, source);
    }
    else if (isNullOrUndefined(target) && isNullOrUndefined(source)) {
        return {};
    }
    else {
        return exists(source) ? source : target;
    }
}
function deepMergeRecursively(target, source) {
    const shouldNotRecurse = isNullOrUndefined(target) ||
        isNullOrUndefined(source) || // at least one not defined
        isArray(target) ||
        isArray(source) || // at least one array
        !isObject(target) ||
        !isObject(source) || // at least one not an object
        isNode(target) ||
        isNode(source); // at least one node
    /**
     * if we will not recurse any further,
     * we will prioritize source if it is a defined value.
     */
    if (shouldNotRecurse) {
        return exists(source) ? source : target;
    }
    const keysOfTarget = Object.keys(target);
    const keysOfSource = Object.keys(source);
    const uniqueKeys = new Set(keysOfTarget.concat(keysOfSource));
    return [...uniqueKeys].reduce((retVal, key) => {
        retVal[key] = deepMergeRecursively(target[key], source[key]);
        return retVal;
    }, {});
}

class InternalStore {
    constructor(initialState) {
        this.initialState = initialState;
        this.state$ = new BehaviorSubject(this.initialState);
        this.update$ = new Subject();
        this.sliceState = (selector, compareFn = compare) => this.state$.pipe(map(selector), distinctUntilChanged(compareFn));
        this.sliceUpdate = (selector, filterFn = (x) => x !== undefined) => this.update$.pipe(map(selector), filter(filterFn));
    }
    get state() {
        return this.state$.value;
    }
    patch(state) {
        let patchedState = state;
        if (typeof state === 'object' && !Array.isArray(state)) {
            patchedState = Object.assign(Object.assign({}, this.state), state);
        }
        this.state$.next(patchedState);
        this.update$.next(patchedState);
    }
    deepPatch(state) {
        this.state$.next(deepMerge(this.state, state));
        this.update$.next(state);
    }
    set(state) {
        this.state$.next(state);
        this.update$.next(state);
    }
    reset() {
        this.set(this.initialState);
    }
}

const mapToApiUrl = (key) => (apis) => (apis[key] || apis.default).url || apis.default.url;
const ɵ0$1 = mapToApiUrl;
class EnvironmentService {
    constructor() {
        this.store = new InternalStore({});
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    getEnvironment$() {
        return this.store.sliceState(state => state);
    }
    getEnvironment() {
        return this.store.state;
    }
    getApiUrl(key) {
        return mapToApiUrl(key)(this.store.state.apis);
    }
    getApiUrl$(key) {
        return this.store.sliceState(state => state.apis).pipe(map(mapToApiUrl(key)));
    }
    setState(environment) {
        this.store.set(environment);
    }
}
EnvironmentService.ɵfac = function EnvironmentService_Factory(t) { return new (t || EnvironmentService)(); };
EnvironmentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function EnvironmentService_Factory() { return new EnvironmentService(); }, token: EnvironmentService, providedIn: "root" });

class RestService {
    constructor(options, http, environment, store) {
        this.options = options;
        this.http = http;
        this.environment = environment;
        this.store = store;
    }
    getApiFromStore(apiName) {
        return this.environment.getApiUrl(apiName);
    }
    handleError(err) {
        this.store.dispatch(new RestOccurError(err));
        return throwError(err);
    }
    // TODO: Deprecate service or improve interface in v5.0
    request(request, config, api) {
        config = config || {};
        api = api || this.getApiFromStore(config.apiName);
        const { method, params } = request, options = __rest(request, ["method", "params"]);
        const { observe = "body" /* Body */, skipHandleError } = config;
        return this.http
            .request(method, api + request.url, Object.assign(Object.assign({ observe }, (params && {
            params: Object.keys(params).reduce((acc, key) => {
                const value = params[key];
                if (isUndefinedOrEmptyString(value))
                    return acc;
                if (value === null && !this.options.sendNullsAsQueryParam)
                    return acc;
                acc[key] = value;
                return acc;
            }, {}),
        })), options))
            .pipe(catchError(err => (skipHandleError ? throwError(err) : this.handleError(err))));
    }
}
RestService.ɵfac = function RestService_Factory(t) { return new (t || RestService)(ɵngcc0.ɵɵinject(CORE_OPTIONS), ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(EnvironmentService), ɵngcc0.ɵɵinject(ɵngcc2.Store)); };
RestService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RestService_Factory() { return new RestService(i0.ɵɵinject(CORE_OPTIONS), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(EnvironmentService), i0.ɵɵinject(i4.Store)); }, token: RestService, providedIn: "root" });
RestService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CORE_OPTIONS,] }] },
    { type: HttpClient },
    { type: EnvironmentService },
    { type: Store }
];

class AbpApplicationConfigurationService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
    }
    get() {
        return this.restService.request({
            method: 'GET',
            url: '/api/abp/application-configuration',
        }, { apiName: this.apiName });
    }
}
AbpApplicationConfigurationService.ɵfac = function AbpApplicationConfigurationService_Factory(t) { return new (t || AbpApplicationConfigurationService)(ɵngcc0.ɵɵinject(RestService)); };
AbpApplicationConfigurationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbpApplicationConfigurationService_Factory() { return new AbpApplicationConfigurationService(i0.ɵɵinject(RestService)); }, token: AbpApplicationConfigurationService, providedIn: "root" });
AbpApplicationConfigurationService.ctorParameters = () => [
    { type: RestService }
];

// This will not be necessary when only Angukar 9.1+ is supported
function getLocaleDirection(locale) {
    return /^(ar(-[A-Z]{2})?|ckb(-IR)?|fa(-AF)?|he|ks|lrc(-IQ)?|mzn|pa-Arab|ps(-PK)?|sd|ug|ur(-IN)?|uz-Arab|yi)$/.test(locale)
        ? 'rtl'
        : 'ltr';
}
function createLocalizer(localization) {
    return (resourceName, key, defaultValue) => {
        if (resourceName === '_')
            return key;
        const resource = snq(() => localization.values[resourceName]);
        if (!resource)
            return defaultValue;
        return resource[key] || defaultValue;
    };
}
function createLocalizerWithFallback(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultValue) => {
        const { localized } = findLocalization(resourceNames, keys);
        return localized || defaultValue;
    };
}
function createLocalizationPipeKeyGenerator(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultKey) => {
        const { resourceName, key } = findLocalization(resourceNames, keys);
        return !resourceName ? defaultKey : resourceName === '_' ? key : `${resourceName}::${key}`;
    };
}
function createLocalizationFinder(localization) {
    const localize = createLocalizer(localization);
    return (resourceNames, keys) => {
        resourceNames = resourceNames.concat(localization.defaultResourceName).filter(Boolean);
        const resourceCount = resourceNames.length;
        const keyCount = keys.length;
        for (let i = 0; i < resourceCount; i++) {
            const resourceName = resourceNames[i];
            for (let j = 0; j < keyCount; j++) {
                const key = keys[j];
                const localized = localize(resourceName, key, null);
                if (localized)
                    return { resourceName, key, localized };
            }
        }
        return { resourceName: undefined, key: undefined, localized: undefined };
    };
}

function createTokenParser(format) {
    return (str) => {
        const tokens = [];
        const regex = format.replace(/\./g, '\\.').replace(/\{\s?([0-9a-zA-Z]+)\s?\}/g, (_, token) => {
            tokens.push(token);
            return '(.+)';
        });
        const matches = (str.match(regex) || []).slice(1);
        return matches.reduce((acc, v, i) => {
            const key = tokens[i];
            acc[key] = [...(acc[key] || []), v].filter(Boolean);
            return acc;
        }, {});
    };
}
function interpolate(text, params) {
    return text
        .replace(/(['"]?\{\s*(\d+)\s*\}['"]?)/g, (_, match, digit) => { var _a; return (_a = params[digit]) !== null && _a !== void 0 ? _a : match; })
        .replace(/\s+/g, ' ');
}

class ConfigStateService {
    constructor(abpConfigService) {
        this.abpConfigService = abpConfigService;
        this.store = new InternalStore({});
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    setState(state) {
        this.store.set(state);
    }
    refreshAppState() {
        return this.abpConfigService.get().pipe(tap(res => this.setState(res)));
    }
    getOne$(key) {
        return this.store.sliceState(state => state[key]);
    }
    getOne(key) {
        return this.store.state[key];
    }
    getAll$() {
        return this.store.sliceState(state => state);
    }
    getAll() {
        return this.store.state;
    }
    getDeep$(keys) {
        keys = splitKeys(keys);
        return this.store
            .sliceState(state => state)
            .pipe(map(state => {
            return keys.reduce((acc, val) => {
                if (acc) {
                    return acc[val];
                }
                return undefined;
            }, state);
        }));
    }
    getDeep(keys) {
        keys = splitKeys(keys);
        return keys.reduce((acc, val) => {
            if (acc) {
                return acc[val];
            }
            return undefined;
        }, this.store.state);
    }
    getFeature(key) {
        var _a, _b;
        return (_b = (_a = this.store.state.features) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];
    }
    getFeature$(key) {
        return this.store.sliceState(state => { var _a, _b; return (_b = (_a = state.features) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key]; });
    }
    getFeatures(keys) {
        const { features } = this.store.state;
        if (!features)
            return;
        return keys.reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: features.values[key] })), {});
    }
    getFeatures$(keys) {
        return this.store.sliceState(({ features }) => {
            if (!(features === null || features === void 0 ? void 0 : features.values))
                return;
            return keys.reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: features.values[key] })), {});
        });
    }
    getSetting(key) {
        var _a, _b;
        return (_b = (_a = this.store.state.setting) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];
    }
    getSetting$(key) {
        return this.store.sliceState(state => { var _a, _b; return (_b = (_a = state.setting) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key]; });
    }
    getSettings(keyword) {
        var _a;
        const settings = ((_a = this.store.state.setting) === null || _a === void 0 ? void 0 : _a.values) || {};
        if (!keyword)
            return settings;
        const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
        return keysFound.reduce((acc, key) => {
            acc[key] = settings[key];
            return acc;
        }, {});
    }
    getSettings$(keyword) {
        return this.store
            .sliceState(state => { var _a; return (_a = state.setting) === null || _a === void 0 ? void 0 : _a.values; })
            .pipe(map((settings = {}) => {
            if (!keyword)
                return settings;
            const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
            return keysFound.reduce((acc, key) => {
                acc[key] = settings[key];
                return acc;
            }, {});
        }));
    }
}
ConfigStateService.ɵfac = function ConfigStateService_Factory(t) { return new (t || ConfigStateService)(ɵngcc0.ɵɵinject(AbpApplicationConfigurationService)); };
ConfigStateService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConfigStateService_Factory() { return new ConfigStateService(i0.ɵɵinject(AbpApplicationConfigurationService)); }, token: ConfigStateService, providedIn: "root" });
ConfigStateService.ctorParameters = () => [
    { type: AbpApplicationConfigurationService }
];
function splitKeys(keys) {
    if (typeof keys === 'string') {
        keys = keys.split('.');
    }
    if (!Array.isArray(keys)) {
        throw new Error('The argument must be a dot string or an string array.');
    }
    return keys;
}

class SessionStateService {
    constructor(configState) {
        this.configState = configState;
        this.store = new InternalStore({});
        this.updateLocalStorage = () => {
            localStorage.setItem('abpSession', JSON.stringify(this.store.state));
        };
        this.init();
        this.setInitialLanguage();
    }
    init() {
        const session = localStorage.getItem('abpSession');
        if (session) {
            this.store.set(JSON.parse(session));
        }
        this.store.sliceUpdate(state => state).subscribe(this.updateLocalStorage);
    }
    setInitialLanguage() {
        if (this.getLanguage())
            return;
        this.configState
            .getDeep$('localization.currentCulture.cultureName')
            .pipe(filter(cultureName => !!cultureName), take(1))
            .subscribe(lang => {
            if (lang.includes(';')) {
                lang = lang.split(';')[0];
            }
            this.setLanguage(lang);
        });
    }
    onLanguageChange$() {
        return this.store.sliceUpdate(state => state.language);
    }
    onTenantChange$() {
        return this.store.sliceUpdate(state => state.tenant);
    }
    getLanguage() {
        return this.store.state.language;
    }
    getLanguage$() {
        return this.store.sliceState(state => state.language);
    }
    getTenant() {
        return this.store.state.tenant;
    }
    getTenant$() {
        return this.store.sliceState(state => state.tenant);
    }
    setTenant(tenant) {
        if (compare(tenant, this.store.state.tenant))
            return;
        this.store.set(Object.assign(Object.assign({}, this.store.state), { tenant }));
    }
    setLanguage(language) {
        if (language === this.store.state.language)
            return;
        this.store.patch({ language });
        document.documentElement.setAttribute('lang', language);
    }
}
SessionStateService.ɵfac = function SessionStateService_Factory(t) { return new (t || SessionStateService)(ɵngcc0.ɵɵinject(ConfigStateService)); };
SessionStateService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SessionStateService_Factory() { return new SessionStateService(i0.ɵɵinject(ConfigStateService)); }, token: SessionStateService, providedIn: "root" });
SessionStateService.ctorParameters = () => [
    { type: ConfigStateService }
];

class LocalizationService {
    constructor(sessionState, injector, otherInstance, configState, appConfigService) {
        this.sessionState = sessionState;
        this.injector = injector;
        this.configState = configState;
        this.appConfigService = appConfigService;
        this.latestLang = this.sessionState.getLanguage();
        this._languageChange$ = new Subject();
        if (otherInstance)
            throw new Error('LocalizationService should have only one instance.');
        this.listenToSetLanguage();
    }
    /**
     * Returns currently selected language
     */
    get currentLang() {
        return this.latestLang || this.sessionState.getLanguage();
    }
    get languageChange$() {
        return this._languageChange$.asObservable();
    }
    listenToSetLanguage() {
        this.sessionState
            .onLanguageChange$()
            .pipe(filter(lang => this.configState.getDeep('localization.currentCulture.cultureName') !== lang), switchMap(lang => this.appConfigService
            .get()
            .pipe(tap(res => this.configState.setState(res)))
            .pipe(mapTo(lang))), switchMap(lang => from(this.registerLocale(lang).then(() => lang))))
            .subscribe(lang => this._languageChange$.next(lang));
    }
    registerLocale(locale) {
        const { registerLocaleFn } = this.injector.get(CORE_OPTIONS);
        return registerLocaleFn(locale).then(module => {
            if (module === null || module === void 0 ? void 0 : module.default)
                registerLocaleData(module.default);
            this.latestLang = locale;
        });
    }
    /**
     * Returns an observable localized text with the given interpolation parameters in current language.
     * @param key Localizaton key to replace with localized text
     * @param interpolateParams Values to interpolate
     */
    get(key, ...interpolateParams) {
        return this.configState
            .getAll$()
            .pipe(map(state => getLocalization(state, key, ...interpolateParams)));
    }
    getResource(resourceName) {
        return this.configState.getDeep(`localization.values.${resourceName}`);
    }
    getResource$(resourceName) {
        return this.configState.getDeep$(`localization.values.${resourceName}`);
    }
    /**
     * Returns localized text with the given interpolation parameters in current language.
     * @param key Localization key to replace with localized text
     * @param interpolateParams Values to intepolate.
     */
    instant(key, ...interpolateParams) {
        return getLocalization(this.configState.getAll(), key, ...interpolateParams);
    }
    localize(resourceName, key, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizer), map(localize => localize(resourceName, key, defaultValue)));
    }
    localizeSync(resourceName, key, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizer(localization)(resourceName, key, defaultValue);
    }
    localizeWithFallback(resourceNames, keys, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizerWithFallback), map(localizeWithFallback => localizeWithFallback(resourceNames, keys, defaultValue)));
    }
    localizeWithFallbackSync(resourceNames, keys, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizerWithFallback(localization)(resourceNames, keys, defaultValue);
    }
}
LocalizationService.ɵfac = function LocalizationService_Factory(t) { return new (t || LocalizationService)(ɵngcc0.ɵɵinject(SessionStateService), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(LocalizationService, 12), ɵngcc0.ɵɵinject(ConfigStateService), ɵngcc0.ɵɵinject(AbpApplicationConfigurationService)); };
LocalizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LocalizationService_Factory() { return new LocalizationService(i0.ɵɵinject(SessionStateService), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(LocalizationService, 12), i0.ɵɵinject(ConfigStateService), i0.ɵɵinject(AbpApplicationConfigurationService)); }, token: LocalizationService, providedIn: "root" });
LocalizationService.ctorParameters = () => [
    { type: SessionStateService },
    { type: Injector },
    { type: LocalizationService, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: ConfigStateService },
    { type: AbpApplicationConfigurationService }
];
function getLocalization(state, key, ...interpolateParams) {
    if (!key)
        key = '';
    let defaultValue;
    if (typeof key !== 'string') {
        defaultValue = key.defaultValue;
        key = key.key;
    }
    const keys = key.split('::');
    const warn = (message) => {
        if (isDevMode)
            console.warn(message);
    };
    if (keys.length < 2) {
        warn('The localization source separator (::) not found.');
        return defaultValue || key;
    }
    if (!state.localization)
        return defaultValue || keys[1];
    const sourceName = keys[0] || state.localization.defaultResourceName;
    const sourceKey = keys[1];
    if (sourceName === '_') {
        return defaultValue || sourceKey;
    }
    if (!sourceName) {
        warn('Localization source name is not specified and the defaultResourceName was not defined!');
        return defaultValue || sourceKey;
    }
    const source = state.localization.values[sourceName];
    if (!source) {
        warn('Could not find localization source: ' + sourceName);
        return defaultValue || sourceKey;
    }
    let localization = source[sourceKey];
    if (typeof localization === 'undefined') {
        return defaultValue || sourceKey;
    }
    interpolateParams = interpolateParams.filter(params => params != null);
    if (localization)
        localization = interpolate(localization, interpolateParams);
    if (typeof localization !== 'string')
        localization = '';
    return localization || defaultValue || key;
}

function findRoute(routesService, path) {
    const node = routesService.find(route => route.path === path);
    return node || path === '/'
        ? node
        : findRoute(routesService, path.split('/').slice(0, -1).join('/') || '/');
}
function getRoutePath(router, url = router.url) {
    const emptyGroup = { segments: [] };
    const primaryGroup = router.parseUrl(url).root.children[PRIMARY_OUTLET];
    return '/' + (primaryGroup || emptyGroup).segments.map(({ path }) => path).join('/');
}
function reloadRoute(router, ngZone) {
    const { shouldReuseRoute } = router.routeReuseStrategy;
    const setRouteReuse = (reuse) => {
        router.routeReuseStrategy.shouldReuseRoute = reuse;
    };
    setRouteReuse(() => false);
    router.navigated = false;
    ngZone.run(() => __awaiter(this, void 0, void 0, function* () {
        yield router.navigateByUrl(router.url).catch(noop);
        setRouteReuse(shouldReuseRoute);
    }));
}

class ReplaceableComponentsService {
    constructor(ngZone, router) {
        this.ngZone = ngZone;
        this.router = router;
        this.store = new InternalStore([]);
    }
    get replaceableComponents$() {
        return this.store.sliceState(state => state);
    }
    get replaceableComponents() {
        return this.store.state;
    }
    get onUpdate$() {
        return this.store.sliceUpdate(state => state);
    }
    add(replaceableComponent, reload) {
        const replaceableComponents = [...this.store.state];
        const index = replaceableComponents.findIndex(component => component.key === replaceableComponent.key);
        if (index > -1) {
            replaceableComponents[index] = replaceableComponent;
        }
        else {
            replaceableComponents.push(replaceableComponent);
        }
        this.store.set(replaceableComponents);
        if (reload)
            reloadRoute(this.router, this.ngZone);
    }
    get(replaceableComponentKey) {
        return this.replaceableComponents.find(component => component.key === replaceableComponentKey);
    }
    get$(replaceableComponentKey) {
        return this.replaceableComponents$.pipe(map(components => components.find(component => component.key === replaceableComponentKey)));
    }
}
ReplaceableComponentsService.ɵfac = function ReplaceableComponentsService_Factory(t) { return new (t || ReplaceableComponentsService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc3.Router)); };
ReplaceableComponentsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ReplaceableComponentsService_Factory() { return new ReplaceableComponentsService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Router)); }, token: ReplaceableComponentsService, providedIn: "root" });
ReplaceableComponentsService.ctorParameters = () => [
    { type: NgZone },
    { type: Router }
];

const NavigationEvent = {
    Cancel: NavigationCancel,
    End: NavigationEnd,
    Error: NavigationError,
    Start: NavigationStart,
};
class RouterEvents {
    constructor(router) {
        this.router = router;
    }
    getEvents(...eventTypes) {
        const filterRouterEvents = (event) => eventTypes.some(type => event instanceof type);
        return this.router.events.pipe(filter(filterRouterEvents));
    }
    getNavigationEvents(...navigationEventKeys) {
        const filterNavigationEvents = (event) => navigationEventKeys.some(key => event instanceof NavigationEvent[key]);
        return this.router.events.pipe(filter(filterNavigationEvents));
    }
    getAllEvents() {
        return this.router.events;
    }
    getAllNavigationEvents() {
        const keys = Object.keys(NavigationEvent);
        return this.getNavigationEvents(...keys);
    }
}
RouterEvents.ɵfac = function RouterEvents_Factory(t) { return new (t || RouterEvents)(ɵngcc0.ɵɵinject(ɵngcc3.Router)); };
RouterEvents.ɵprov = i0.ɵɵdefineInjectable({ factory: function RouterEvents_Factory() { return new RouterEvents(i0.ɵɵinject(i1.Router)); }, token: RouterEvents, providedIn: "root" });
RouterEvents.ctorParameters = () => [
    { type: Router }
];

function pushValueTo(array) {
    return (element) => {
        array.push(element);
        return array;
    };
}

class BaseTreeNode {
    constructor(props) {
        this.children = [];
        this.isLeaf = true;
        Object.assign(this, props);
    }
    static create(props) {
        return new BaseTreeNode(props);
    }
}
function createTreeFromList(list, keySelector, parentKeySelector, valueMapper) {
    const map = createMapFromList(list, keySelector, valueMapper);
    const tree = [];
    list.forEach(row => {
        const id = keySelector(row);
        const parentId = parentKeySelector(row);
        const node = map.get(id);
        if (!node)
            return;
        if (parentId) {
            const parent = map.get(parentId);
            if (!parent)
                return;
            parent.children.push(node);
            parent.isLeaf = false;
            node.parent = parent;
        }
        else {
            tree.push(node);
        }
    });
    return tree;
}
function createMapFromList(list, keySelector, valueMapper) {
    const map = new Map();
    list.forEach(row => map.set(keySelector(row), valueMapper(row)));
    return map;
}
function createTreeNodeFilterCreator(key, mapperFn) {
    return (search) => {
        const regex = new RegExp('.*' + search + '.*', 'i');
        return function collectNodes(nodes, matches = []) {
            for (const node of nodes) {
                if (regex.test(mapperFn(node[key])))
                    matches.push(node);
                if (node.children.length)
                    collectNodes(node.children, matches);
            }
            return matches;
        };
    };
}

class PermissionService {
    constructor(configState) {
        this.configState = configState;
    }
    getGrantedPolicy$(key) {
        return this.getStream().pipe(map(grantedPolicies => this.isPolicyGranted(key, grantedPolicies)));
    }
    getGrantedPolicy(key) {
        const policies = this.getSnapshot();
        return this.isPolicyGranted(key, policies);
    }
    filterItemsByPolicy(items) {
        const policies = this.getSnapshot();
        return items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies));
    }
    filterItemsByPolicy$(items) {
        return this.getStream().pipe(map(policies => items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies))));
    }
    isPolicyGranted(key, grantedPolicies) {
        if (!key)
            return true;
        const orRegexp = /\|\|/g;
        const andRegexp = /&&/g;
        // TODO: Allow combination of ANDs & ORs
        if (orRegexp.test(key)) {
            const keys = key.split('||').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.some(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        else if (andRegexp.test(key)) {
            const keys = key.split('&&').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.every(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        return this.getPolicy(key, grantedPolicies);
    }
    getStream() {
        return this.configState.getAll$().pipe(map(this.mapToPolicies));
    }
    getSnapshot() {
        return this.mapToPolicies(this.configState.getAll());
    }
    mapToPolicies(applicationConfiguration) {
        return snq(() => applicationConfiguration.auth.grantedPolicies, {});
    }
    getPolicy(key, grantedPolicies) {
        return snq(() => grantedPolicies[key], false);
    }
}
PermissionService.ɵfac = function PermissionService_Factory(t) { return new (t || PermissionService)(ɵngcc0.ɵɵinject(ConfigStateService)); };
PermissionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PermissionService_Factory() { return new PermissionService(i0.ɵɵinject(ConfigStateService)); }, token: PermissionService, providedIn: "root" });
PermissionService.ctorParameters = () => [
    { type: ConfigStateService }
];

class AbstractTreeService {
    constructor() {
        this._flat$ = new BehaviorSubject([]);
        this._tree$ = new BehaviorSubject([]);
        this._visible$ = new BehaviorSubject([]);
    }
    get flat() {
        return this._flat$.value;
    }
    get flat$() {
        return this._flat$.asObservable();
    }
    get tree() {
        return this._tree$.value;
    }
    get tree$() {
        return this._tree$.asObservable();
    }
    get visible() {
        return this._visible$.value;
    }
    get visible$() {
        return this._visible$.asObservable();
    }
    createTree(items) {
        return createTreeFromList(items, item => item[this.id], item => item[this.parentId], item => BaseTreeNode.create(item));
    }
    filterWith(setOrMap) {
        return this._flat$.value.filter(item => !setOrMap.has(item[this.id]));
    }
    findItemsToRemove(set) {
        return this._flat$.value.reduce((acc, item) => {
            if (!acc.has(item[this.parentId]))
                return acc;
            const childSet = new Set([item[this.id]]);
            const children = this.findItemsToRemove(childSet);
            return new Set([...acc, ...children]);
        }, set);
    }
    publish(flatItems, visibleItems) {
        this._flat$.next(flatItems);
        this._tree$.next(this.createTree(flatItems));
        this._visible$.next(this.createTree(visibleItems));
        return flatItems;
    }
    add(items) {
        const map = new Map();
        items.forEach(item => map.set(item[this.id], item));
        const flatItems = this.filterWith(map);
        map.forEach(pushValueTo(flatItems));
        flatItems.sort(this.sort);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    find(predicate, tree = this.tree) {
        return tree.reduce((acc, node) => (acc ? acc : predicate(node) ? node : this.find(predicate, node.children)), null);
    }
    patch(identifier, props) {
        const flatItems = this._flat$.value;
        const index = flatItems.findIndex(item => item[this.id] === identifier);
        if (index < 0)
            return false;
        flatItems[index] = Object.assign(Object.assign({}, flatItems[index]), props);
        flatItems.sort(this.sort);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    refresh() {
        return this.add([]);
    }
    remove(identifiers) {
        const set = new Set();
        identifiers.forEach(id => set.add(id));
        const setToRemove = this.findItemsToRemove(set);
        const flatItems = this.filterWith(setToRemove);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    search(params, tree = this.tree) {
        const searchKeys = Object.keys(params);
        return tree.reduce((acc, node) => acc
            ? acc
            : searchKeys.every(key => node[key] === params[key])
                ? node
                : this.search(params, node.children), null);
    }
}
class AbstractNavTreeService extends AbstractTreeService {
    constructor(injector) {
        super();
        this.injector = injector;
        this.id = 'name';
        this.parentId = 'parentName';
        this.hide = (item) => item.invisible || !this.isGranted(item);
        this.sort = (a, b) => {
            if (!Number.isInteger(a.order))
                return 1;
            if (!Number.isInteger(b.order))
                return -1;
            return a.order - b.order;
        };
        const configState = this.injector.get(ConfigStateService);
        this.subscription = configState
            .createOnUpdateStream(state => state)
            .subscribe(() => this.refresh());
        this.permissionService = injector.get(PermissionService);
    }
    isGranted({ requiredPolicy }) {
        return this.permissionService.getGrantedPolicy(requiredPolicy);
    }
    hasChildren(identifier) {
        var _a;
        const node = this.find(item => item[this.id] === identifier);
        return Boolean((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length);
    }
    hasInvisibleChild(identifier) {
        var _a;
        const node = this.find(item => item[this.id] === identifier);
        return (_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.some(child => child.invisible);
    }
    /* istanbul ignore next */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
AbstractNavTreeService.ɵfac = function AbstractNavTreeService_Factory(t) { return new (t || AbstractNavTreeService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
AbstractNavTreeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: AbstractNavTreeService, factory: AbstractNavTreeService.ɵfac });
AbstractNavTreeService.ctorParameters = () => [
    { type: Injector }
];
class RoutesService extends AbstractNavTreeService {
}
RoutesService.ɵfac = /*@__PURE__*/ function () { let ɵRoutesService_BaseFactory; return function RoutesService_Factory(t) { return (ɵRoutesService_BaseFactory || (ɵRoutesService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RoutesService)))(t || RoutesService); }; }();
RoutesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoutesService_Factory() { return new RoutesService(i0.ɵɵinject(i0.INJECTOR)); }, token: RoutesService, providedIn: "root" });
class SettingTabsService extends AbstractNavTreeService {
}
SettingTabsService.ɵfac = /*@__PURE__*/ function () { let ɵSettingTabsService_BaseFactory; return function SettingTabsService_Factory(t) { return (ɵSettingTabsService_BaseFactory || (ɵSettingTabsService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(SettingTabsService)))(t || SettingTabsService); }; }();
SettingTabsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SettingTabsService_Factory() { return new SettingTabsService(i0.ɵɵinject(i0.INJECTOR)); }, token: SettingTabsService, providedIn: "root" });

class SubscriptionService {
    constructor() {
        this.subscription = new Subscription();
    }
    get isClosed() {
        return this.subscription.closed;
    }
    addOne(source$, nextOrObserver, error) {
        const subscription = source$.subscribe(nextOrObserver, error);
        this.subscription.add(subscription);
        return subscription;
    }
    closeAll() {
        this.subscription.unsubscribe();
    }
    closeOne(subscription) {
        this.removeOne(subscription);
        subscription.unsubscribe();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    removeOne(subscription) {
        if (!subscription)
            return;
        this.subscription.remove(subscription);
    }
    reset() {
        this.subscription.unsubscribe();
        this.subscription = new Subscription();
    }
}
SubscriptionService.ɵfac = function SubscriptionService_Factory(t) { return new (t || SubscriptionService)(); };
SubscriptionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SubscriptionService, factory: SubscriptionService.ɵfac });

class DynamicLayoutComponent {
    constructor(injector, localizationService, replaceableComponents, subscription, routerEvents, dynamicLayoutComponent) {
        this.localizationService = localizationService;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
        this.routerEvents = routerEvents;
        // TODO: Consider a shared enum (eThemeSharedComponents) for known layouts
        this.layouts = new Map([
            ['application', 'Theme.ApplicationLayoutComponent'],
            ['account', 'Theme.AccountLayoutComponent'],
            ['empty', 'Theme.EmptyLayoutComponent'],
        ]);
        this.isLayoutVisible = true;
        if (dynamicLayoutComponent)
            return;
        this.route = injector.get(ActivatedRoute);
        this.router = injector.get(Router);
        this.routes = injector.get(RoutesService);
        this.getLayout();
        this.checkLayoutOnNavigationEnd();
        this.listenToLanguageChange();
    }
    checkLayoutOnNavigationEnd() {
        const navigationEnd$ = this.routerEvents.getNavigationEvents('End');
        this.subscription.addOne(navigationEnd$, () => this.getLayout());
    }
    getLayout() {
        var _a;
        let expectedLayout = (this.route.snapshot.data || {}).layout;
        if (!expectedLayout) {
            let node = findRoute(this.routes, getRoutePath(this.router));
            node = { parent: node };
            while (node.parent) {
                node = node.parent;
                if (node.layout) {
                    expectedLayout = node.layout;
                    break;
                }
            }
        }
        if (!expectedLayout)
            expectedLayout = "empty" /* empty */;
        if (this.layoutKey === expectedLayout)
            return;
        const key = this.layouts.get(expectedLayout);
        this.layout = (_a = this.getComponent(key)) === null || _a === void 0 ? void 0 : _a.component;
        this.layoutKey = expectedLayout;
    }
    listenToLanguageChange() {
        this.subscription.addOne(this.localizationService.languageChange$, () => {
            this.isLayoutVisible = false;
            setTimeout(() => (this.isLayoutVisible = true), 0);
        });
    }
    getComponent(key) {
        return this.replaceableComponents.get(key);
    }
}
DynamicLayoutComponent.ɵfac = function DynamicLayoutComponent_Factory(t) { return new (t || DynamicLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(ReplaceableComponentsService), ɵngcc0.ɵɵdirectiveInject(SubscriptionService), ɵngcc0.ɵɵdirectiveInject(RouterEvents), ɵngcc0.ɵɵdirectiveInject(DynamicLayoutComponent, 12)); };
DynamicLayoutComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DynamicLayoutComponent, selectors: [["abp-dynamic-layout"]], features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService])], decls: 5, vars: 1, consts: [[4, "ngTemplateOutlet"], ["routerOutlet", ""], ["componentOutlet", ""], [3, "ngComponentOutlet", 4, "ngIf"], [3, "ngComponentOutlet"]], template: function DynamicLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DynamicLayoutComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, DynamicLayoutComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, DynamicLayoutComponent_ng_template_3_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        const _r3 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.layout ? _r3 : _r1);
    } }, directives: [ɵngcc4.NgTemplateOutlet, ɵngcc3.RouterOutlet, ɵngcc4.NgIf, ɵngcc4.NgComponentOutlet], encapsulation: 2 });
DynamicLayoutComponent.ctorParameters = () => [
    { type: Injector },
    { type: LocalizationService },
    { type: ReplaceableComponentsService },
    { type: SubscriptionService },
    { type: RouterEvents },
    { type: DynamicLayoutComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

class ReplaceableRouteContainerComponent {
    constructor(route, replaceableComponents, subscription) {
        this.route = route;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
    }
    ngOnInit() {
        this.defaultComponent = this.route.snapshot.data.replaceableComponent.defaultComponent;
        this.componentKey = this.route.snapshot.data
            .replaceableComponent.key;
        const component$ = this.replaceableComponents
            .get$(this.componentKey)
            .pipe(distinctUntilChanged());
        this.subscription.addOne(component$, (res = {}) => {
            this.externalComponent = res.component;
        });
    }
}
ReplaceableRouteContainerComponent.ɵfac = function ReplaceableRouteContainerComponent_Factory(t) { return new (t || ReplaceableRouteContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ReplaceableComponentsService), ɵngcc0.ɵɵdirectiveInject(SubscriptionService)); };
ReplaceableRouteContainerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ReplaceableRouteContainerComponent, selectors: [["abp-replaceable-route-container"]], features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService])], decls: 1, vars: 1, consts: [[4, "ngComponentOutlet"]], template: function ReplaceableRouteContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ReplaceableRouteContainerComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngComponentOutlet", ctx.externalComponent || ctx.defaultComponent);
    } }, directives: [ɵngcc4.NgComponentOutlet], encapsulation: 2 });
ReplaceableRouteContainerComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: ReplaceableComponentsService },
    { type: SubscriptionService }
];

class RouterOutletComponent {
}
RouterOutletComponent.ɵfac = function RouterOutletComponent_Factory(t) { return new (t || RouterOutletComponent)(); };
RouterOutletComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RouterOutletComponent, selectors: [["abp-router-outlet"]], decls: 1, vars: 0, template: function RouterOutletComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "router-outlet");
    } }, directives: [ɵngcc3.RouterOutlet], encapsulation: 2 });

// Different locales from .NET
// Key is .NET locale, value is Angular locale
const differentLocales = {
    aa: 'en',
    'aa-DJ': 'en',
    'aa-ER': 'en',
    'aa-ET': 'en',
    'af-ZA': 'af',
    'agq-CM': 'agq',
    'ak-GH': 'ak',
    'am-ET': 'am',
    'ar-001': 'ar',
    arn: 'en',
    'arn-CL': 'en',
    'as-IN': 'as',
    'asa-TZ': 'asa',
    'ast-ES': 'ast',
    'az-Cyrl-AZ': 'az-Cyrl',
    'az-Latn-AZ': 'az-Latn',
    ba: 'ru',
    'ba-RU': 'ru',
    'bas-CM': 'bas',
    'be-BY': 'be',
    'bem-ZM': 'bem',
    'bez-TZ': 'bez',
    'bg-BG': 'bg',
    bin: 'en',
    'bin-NG': 'en',
    'bm-Latn': 'bm',
    'bm-Latn-ML': 'bm',
    'bn-BD': 'bn',
    'bo-CN': 'bo',
    'br-FR': 'br',
    'brx-IN': 'brx',
    'bs-Cyrl-BA': 'bs-Cyrl',
    'bs-Latn-BA': 'bs-Latn',
    byn: 'en',
    'byn-ER': 'en',
    'ca-ES': 'ca',
    'ca-ES-valencia': 'ca-ES-VALENCIA',
    'ce-RU': 'ce',
    'cgg-UG': 'cgg',
    'chr-Cher': 'chr',
    'chr-Cher-US': 'chr',
    co: 'en',
    'co-FR': 'fr',
    'cs-CZ': 'cs',
    'cu-RU': 'cu',
    'cy-GB': 'cy',
    'da-DK': 'da',
    'dav-KE': 'dav',
    'de-DE': 'de',
    'dje-NE': 'dje',
    'dsb-DE': 'dsb',
    'dua-CM': 'dua',
    dv: 'en',
    'dv-MV': 'en',
    'dyo-SN': 'dyo',
    'dz-BT': 'dz',
    'ebu-KE': 'ebu',
    'ee-GH': 'ee',
    'el-GR': 'el',
    'en-029': 'en',
    'en-ID': 'en',
    'en-US': 'en',
    'eo-001': 'en',
    'es-ES': 'es',
    'et-EE': 'et',
    'eu-ES': 'eu',
    'ewo-CM': 'ewo',
    'fa-IR': 'fa',
    'ff-Latn-SN': 'ff-Latn',
    'ff-NG': 'ff',
    'fi-FI': 'fi',
    'fil-PH': 'fil',
    'fo-FO': 'fo',
    'fr-029': 'fr',
    'fr-FR': 'fr',
    'fur-IT': 'fur',
    'fy-NL': 'fy',
    'ga-IE': 'ga',
    'gd-GB': 'gd',
    'gl-ES': 'gl',
    gn: 'en',
    'gn-PY': 'en',
    'gsw-CH': 'gsw',
    'gu-IN': 'gu',
    'guz-KE': 'guz',
    'gv-IM': 'gv',
    'ha-Latn': 'ha',
    'ha-Latn-GH': 'ha-GH',
    'ha-Latn-NE': 'ha-NE',
    'ha-Latn-NG': 'ha',
    'haw-US': 'haw',
    'he-IL': 'he',
    'hi-IN': 'hi',
    'hr-HR': 'hr',
    'hsb-DE': 'hsb',
    'hu-HU': 'hu',
    'hy-AM': 'hy',
    'ia-001': 'ia',
    'ia-FR': 'ia',
    ibb: 'en',
    'ibb-NG': 'en',
    'id-ID': 'id',
    'ig-NG': 'ig',
    'ii-CN': 'ii',
    'is-IS': 'is',
    'it-IT': 'it',
    iu: 'en',
    'iu-Cans': 'en',
    'iu-Cans-CA': 'en',
    'iu-Latn': 'en',
    'iu-Latn-CA': 'en',
    'ja-JP': 'ja',
    'jgo-CM': 'jgo',
    'jmc-TZ': 'jmc',
    'jv-Java': 'jv',
    'jv-Java-ID': 'jv',
    'jv-Latn': 'jv',
    'jv-Latn-ID': 'jv',
    'ka-GE': 'ka',
    'kab-DZ': 'kab',
    'kam-KE': 'kam',
    'kde-TZ': 'kde',
    'kea-CV': 'kea',
    'khq-ML': 'khq',
    'ki-KE': 'ki',
    'kk-KZ': 'kk',
    'kkj-CM': 'kkj',
    'kl-GL': 'kl',
    'kln-KE': 'kln',
    'km-KH': 'km',
    'kn-IN': 'kn',
    'ko-KR': 'ko',
    'kok-IN': 'kok',
    kr: 'en',
    'kr-NG': 'en',
    'ks-Arab': 'ks',
    'ks-Arab-IN': 'ks',
    'ks-Deva': 'ks',
    'ks-Deva-IN': 'ks',
    'ksb-TZ': 'ksb',
    'ksf-CM': 'ksf',
    'ksh-DE': 'ksh',
    'ku-Arab': 'ku',
    'ku-Arab-IQ': 'ku',
    'ku-Arab-IR': 'ku',
    'kw-GB': 'kw',
    'ky-KG': 'ky',
    la: 'en',
    'la-001': 'en',
    'lag-TZ': 'lag',
    'lb-LU': 'lb',
    'lg-UG': 'lg',
    'lkt-US': 'lkt',
    'ln-CD': 'ln',
    'lo-LA': 'lo',
    'lrc-IR': 'lrc',
    'lt-LT': 'lt',
    'lu-CD': 'lu',
    'luo-KE': 'luo',
    'luy-KE': 'luy',
    'lv-LV': 'lv',
    'mas-KE': 'mas',
    'mer-KE': 'mer',
    'mfe-MU': 'mfe',
    'mg-MG': 'mg',
    'mgh-MZ': 'mgh',
    'mgo-CM': 'mgo',
    'mi-NZ': 'mi',
    'mk-MK': 'mk',
    'ml-IN': 'ml',
    'mn-Cyrl': 'mn',
    'mn-MN': 'mn',
    'mn-Mong': 'mn',
    'mn-Mong-CN': 'mn',
    'mn-Mong-MN': 'mn',
    mni: 'en',
    'mni-IN': 'en',
    moh: 'en',
    'moh-CA': 'en',
    'mr-IN': 'mr',
    'ms-MY': 'ms',
    'mt-MT': 'mt',
    'mua-CM': 'mua',
    'my-MM': 'my',
    'mzn-IR': 'mzn',
    'naq-NA': 'naq',
    'nb-NO': 'nb',
    'nd-ZW': 'nd',
    'ne-NP': 'ne',
    'nl-NL': 'nl',
    'nmg-CM': 'ngm',
    'nn-NO': 'nn',
    'nnh-CM': 'nnh',
    no: 'en',
    nqo: 'en',
    'nqo-GN': 'en',
    nr: 'en',
    'nr-ZA': 'en',
    nso: 'en',
    'nso-ZA': 'en',
    'nus-SS': 'nus',
    'nyn-UG': 'nyn',
    oc: 'en',
    'oc-FR': 'fr',
    'om-ET': 'om',
    'or-IN': 'or',
    'os-GE': 'os',
    'pa-Arab-PK': 'pa-Arab',
    'pa-IN': 'pa',
    pap: 'en',
    'pap-029': 'en',
    'pl-PL': 'pl',
    'prg-001': 'prg',
    prs: 'en',
    'prs-AF': 'en',
    'ps-AF': 'ps',
    'pt-BR': 'pt',
    quc: 'en',
    'quc-Latn': 'en',
    'quc-Latn-GT': 'en',
    quz: 'en',
    'quz-BO': 'en',
    'quz-EC': 'en',
    'quz-PE': 'en',
    'rm-CH': 'rm',
    'rn-BI': 'rn',
    'ro-RO': 'ro',
    'rof-TZ': 'rof',
    'ru-RU': 'ru',
    'rw-RW': 'rw',
    'rwk-TZ': 'rwk',
    sa: 'en',
    'sa-IN': 'en',
    'sah-RU': 'sah',
    'saq-KE': 'saq',
    'sbp-TZ': 'en',
    'sd-Arab': 'sd',
    'sd-Arab-PK': 'sd',
    'sd-Deva': 'sd',
    'sd-Deva-IN': 'sd',
    'se-NO': 'se',
    'seh-MZ': 'seh',
    'ses-ML': 'ses',
    'sg-CF': 'sg',
    'shi-Latn-MA': 'shi-Latn',
    'shi-Tfng-MA': 'shi-Tfng',
    'si-LK': 'si',
    'sk-SK': 'sk',
    'sl-SI': 'sl',
    sma: 'en',
    'sma-NO': 'en',
    'sma-SE': 'en',
    smj: 'en',
    'smj-NO': 'en',
    'smj-SE': 'en',
    'smn-FI': 'en',
    sms: 'en',
    'sms-FI': 'en',
    'sn-Latn': 'sn',
    'sn-Latn-ZW': 'sn',
    'so-SO': 'so',
    'sq-AL': 'so',
    'sr-Cyrl-RS': 'sr-Cryl',
    'sr-Latn-RS': 'sr-Latn',
    ss: 'en',
    'ss-SZ': 'en',
    'ss-ZA': 'en',
    ssy: 'en',
    'ssy-ER': 'en',
    st: 'en',
    'st-LS': 'en',
    'st-ZA': 'en',
    'sv-SE': 'sv',
    'sw-TZ': 'sw',
    syr: 'en',
    'syr-SY': 'en',
    'ta-IN': 'ta',
    'te-IN': 'te',
    'teo-UG': 'teo',
    'tg-Cyrl': 'tg',
    'tg-Cyrl-TJ': 'tg',
    'th-TH': 'th',
    'ti-ET': 'ti',
    tig: 'en',
    'tig-ER': 'en',
    'tk-TM': 'tk',
    tn: 'en',
    'tn-BW': 'en',
    'tn-ZA': 'en',
    'to-TO': 'to',
    'tr-TR': 'tr',
    ts: 'en',
    'ts-ZA': 'en',
    'tt-RU': 'tt',
    'twq-NE': 'twq',
    'tzm-Arab': 'tzm',
    'tzm-Arab-MA': 'tzm',
    'tzm-Latn': 'tzm',
    'tzm-Latn-DZ': 'tzm',
    'tzm-Latn-MA': 'tzm',
    'tzm-Tfng': 'tzm',
    'tzm-Tfng-MA': 'tzm',
    'ug-CN': 'ug',
    'uk-UA': 'uk',
    'ur-PK': 'ur',
    'uz-Arab-AF': 'uz-Arab',
    'uz-Cyrl-UZ': 'uz-Cyrl',
    'uz-Latn-UZ': 'uz-Latn',
    'vai-Latn-LR': 'vai-Latn',
    'vai-Vaii-LR': 'vai-Vaii',
    ve: 'en',
    've-ZA': 'en',
    'vi-VN': 'vi',
    'vo-001': 'vo',
    'vun-TZ': 'vun',
    'wae-CH': 'wae',
    wal: 'en',
    'wal-ET': 'en',
    'wo-SN': 'wo',
    'xh-ZA': 'xh',
    'xog-UG': 'xog',
    'yav-CM': 'yav',
    'yi-001': 'yi',
    'yo-NG': 'yo',
    'zgh-Tfng': 'zgh',
    'zgh-Tfng-MA': 'zgh',
    'zh-CN': 'zh',
    'zh-HK': 'zh',
    'zh-MO': 'zh',
    'zh-SG': 'zh',
    'zh-TW': 'zh',
    'zu-ZA': 'zu',
};

class AutofocusDirective {
    constructor(elRef) {
        this.elRef = elRef;
        this.delay = 0;
    }
    ngAfterViewInit() {
        setTimeout(() => this.elRef.nativeElement.focus(), this.delay);
    }
}
AutofocusDirective.ɵfac = function AutofocusDirective_Factory(t) { return new (t || AutofocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AutofocusDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: AutofocusDirective, selectors: [["", "autofocus", ""]], inputs: { delay: ["autofocus", "delay"] } });
AutofocusDirective.ctorParameters = () => [
    { type: ElementRef }
];
AutofocusDirective.propDecorators = {
    delay: [{ type: Input, args: ['autofocus',] }]
};

class InputEventDebounceDirective {
    constructor(el, subscription) {
        this.el = el;
        this.subscription = subscription;
        this.debounce = 300;
        this.debounceEvent = new EventEmitter();
    }
    ngOnInit() {
        const input$ = fromEvent(this.el.nativeElement, 'input').pipe(debounceTime(this.debounce));
        this.subscription.addOne(input$, (event) => {
            this.debounceEvent.emit(event);
        });
    }
}
InputEventDebounceDirective.ɵfac = function InputEventDebounceDirective_Factory(t) { return new (t || InputEventDebounceDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SubscriptionService)); };
InputEventDebounceDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: InputEventDebounceDirective, selectors: [["", "input.debounce", ""]], inputs: { debounce: "debounce" }, outputs: { debounceEvent: "input.debounce" }, features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService])] });
InputEventDebounceDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: SubscriptionService }
];
InputEventDebounceDirective.propDecorators = {
    debounce: [{ type: Input }],
    debounceEvent: [{ type: Output, args: ['input.debounce',] }]
};

class AbpForContext {
    constructor($implicit, index, count, list) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
        this.list = list;
    }
}
class RecordView {
    constructor(record, view) {
        this.record = record;
        this.view = view;
    }
}
class ForDirective {
    constructor(tempRef, vcRef, differs) {
        this.tempRef = tempRef;
        this.vcRef = vcRef;
        this.differs = differs;
    }
    get compareFn() {
        return this.compareBy || compare;
    }
    get trackByFn() {
        return this.trackBy || ((index, item) => item.id || index);
    }
    iterateOverAppliedOperations(changes) {
        const rw = [];
        changes.forEachOperation((record, previousIndex, currentIndex) => {
            if (record.previousIndex == null) {
                const view = this.vcRef.createEmbeddedView(this.tempRef, new AbpForContext(null, -1, -1, this.items), currentIndex);
                rw.push(new RecordView(record, view));
            }
            else if (currentIndex == null) {
                this.vcRef.remove(previousIndex);
            }
            else {
                const view = this.vcRef.get(previousIndex);
                this.vcRef.move(view, currentIndex);
                rw.push(new RecordView(record, view));
            }
        });
        for (let i = 0, l = rw.length; i < l; i++) {
            rw[i].view.context.$implicit = rw[i].record.item;
        }
    }
    iterateOverAttachedViews(changes) {
        for (let i = 0, l = this.vcRef.length; i < l; i++) {
            const viewRef = this.vcRef.get(i);
            viewRef.context.index = i;
            viewRef.context.count = l;
            viewRef.context.list = this.items;
        }
        changes.forEachIdentityChange((record) => {
            const viewRef = this.vcRef.get(record.currentIndex);
            viewRef.context.$implicit = record.item;
        });
    }
    projectItems(items) {
        if (!items.length && this.emptyRef) {
            this.vcRef.clear();
            // tslint:disable-next-line: no-unused-expression
            this.vcRef.createEmbeddedView(this.emptyRef).rootNodes;
            this.isShowEmptyRef = true;
            this.differ = null;
            return;
        }
        if (this.emptyRef && this.isShowEmptyRef) {
            this.vcRef.clear();
            this.isShowEmptyRef = false;
        }
        if (!this.differ && items) {
            this.differ = this.differs.find(items).create(this.trackByFn);
        }
        if (this.differ) {
            const changes = this.differ.diff(items);
            if (changes) {
                this.iterateOverAppliedOperations(changes);
                this.iterateOverAttachedViews(changes);
            }
        }
    }
    sortItems(items) {
        if (this.orderBy) {
            items.sort((a, b) => (a[this.orderBy] > b[this.orderBy] ? 1 : a[this.orderBy] < b[this.orderBy] ? -1 : 0));
        }
        else {
            items.sort();
        }
    }
    ngOnChanges() {
        let items = clone(this.items);
        if (!Array.isArray(items))
            return;
        const compareFn = this.compareFn;
        if (typeof this.filterBy !== 'undefined' && typeof this.filterVal !== 'undefined' && this.filterVal !== '') {
            items = items.filter(item => compareFn(item[this.filterBy], this.filterVal));
        }
        switch (this.orderDir) {
            case 'ASC':
                this.sortItems(items);
                this.projectItems(items);
                break;
            case 'DESC':
                this.sortItems(items);
                items.reverse();
                this.projectItems(items);
                break;
            default:
                this.projectItems(items);
        }
    }
}
ForDirective.ɵfac = function ForDirective_Factory(t) { return new (t || ForDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
ForDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ForDirective, selectors: [["", "abpFor", ""]], inputs: { items: ["abpForOf", "items"], orderBy: ["abpForOrderBy", "orderBy"], orderDir: ["abpForOrderDir", "orderDir"], filterBy: ["abpForFilterBy", "filterBy"], filterVal: ["abpForFilterVal", "filterVal"], trackBy: ["abpForTrackBy", "trackBy"], compareBy: ["abpForCompareBy", "compareBy"], emptyRef: ["abpForEmptyRef", "emptyRef"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ForDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: IterableDiffers }
];
ForDirective.propDecorators = {
    items: [{ type: Input, args: ['abpForOf',] }],
    orderBy: [{ type: Input, args: ['abpForOrderBy',] }],
    orderDir: [{ type: Input, args: ['abpForOrderDir',] }],
    filterBy: [{ type: Input, args: ['abpForFilterBy',] }],
    filterVal: [{ type: Input, args: ['abpForFilterVal',] }],
    trackBy: [{ type: Input, args: ['abpForTrackBy',] }],
    compareBy: [{ type: Input, args: ['abpForCompareBy',] }],
    emptyRef: [{ type: Input, args: ['abpForEmptyRef',] }]
};

class FormSubmitDirective {
    constructor(formGroupDirective, host, cdRef, subscription) {
        this.formGroupDirective = formGroupDirective;
        this.host = host;
        this.cdRef = cdRef;
        this.subscription = subscription;
        this.debounce = 200;
        this.ngSubmit = new EventEmitter();
        this.executedNgSubmit = false;
    }
    ngOnInit() {
        this.subscription.addOne(this.formGroupDirective.ngSubmit, () => {
            this.markAsDirty();
            this.executedNgSubmit = true;
        });
        const keyup$ = fromEvent(this.host.nativeElement, 'keyup').pipe(debounceTime(this.debounce), filter(event => !(event.target instanceof HTMLTextAreaElement)), filter((event) => event && event.key === 'Enter'));
        this.subscription.addOne(keyup$, () => {
            if (!this.executedNgSubmit) {
                this.host.nativeElement.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            }
            this.executedNgSubmit = false;
        });
    }
    markAsDirty() {
        const { form } = this.formGroupDirective;
        setDirty(form.controls);
        form.markAsDirty();
        this.cdRef.detectChanges();
    }
}
FormSubmitDirective.ɵfac = function FormSubmitDirective_Factory(t) { return new (t || FormSubmitDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.FormGroupDirective, 2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(SubscriptionService)); };
FormSubmitDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FormSubmitDirective, selectors: [["form", "ngSubmit", "", "formGroup", ""]], inputs: { debounce: "debounce", notValidateOnSubmit: "notValidateOnSubmit" }, outputs: { ngSubmit: "ngSubmit" }, features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService])] });
FormSubmitDirective.ctorParameters = () => [
    { type: FormGroupDirective, decorators: [{ type: Self }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: SubscriptionService }
];
FormSubmitDirective.propDecorators = {
    debounce: [{ type: Input }],
    notValidateOnSubmit: [{ type: Input }],
    ngSubmit: [{ type: Output }]
};
function setDirty(controls) {
    if (Array.isArray(controls)) {
        controls.forEach(group => {
            setDirty(group.controls);
        });
        return;
    }
    Object.keys(controls).forEach(key => {
        controls[key].markAsDirty();
        controls[key].updateValueAndValidity();
    });
}

class InitDirective {
    constructor(elRef) {
        this.elRef = elRef;
        this.init = new EventEmitter();
    }
    ngAfterViewInit() {
        this.init.emit(this.elRef);
    }
}
InitDirective.ɵfac = function InitDirective_Factory(t) { return new (t || InitDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
InitDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: InitDirective, selectors: [["", "abpInit", ""]], outputs: { init: "abpInit" } });
InitDirective.ctorParameters = () => [
    { type: ElementRef }
];
InitDirective.propDecorators = {
    init: [{ type: Output, args: ['abpInit',] }]
};

class PermissionDirective {
    constructor(elRef, renderer, templateRef, vcRef, permissionService, cdRef) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.templateRef = templateRef;
        this.vcRef = vcRef;
        this.permissionService = permissionService;
        this.cdRef = cdRef;
    }
    check() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.subscription = this.permissionService
            .getGrantedPolicy$(this.condition)
            .pipe(distinctUntilChanged())
            .subscribe(isGranted => {
            if (this.templateRef)
                this.initStructural(isGranted);
            else
                this.initAttribute(isGranted);
            this.cdRef.detectChanges();
        });
    }
    initStructural(isGranted) {
        this.vcRef.clear();
        if (isGranted)
            this.vcRef.createEmbeddedView(this.templateRef);
    }
    /**
     * @deprecated Will be deleted in v5.0
     */
    initAttribute(isGranted) {
        if (!isGranted) {
            this.renderer.removeChild(this.elRef.nativeElement.parentElement, this.elRef.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.subscription)
            this.subscription.unsubscribe();
    }
    ngOnChanges() {
        this.check();
    }
}
PermissionDirective.ɵfac = function PermissionDirective_Factory(t) { return new (t || PermissionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(PermissionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
PermissionDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PermissionDirective, selectors: [["", "abpPermission", ""]], inputs: { condition: ["abpPermission", "condition"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
PermissionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: TemplateRef, decorators: [{ type: Optional }] },
    { type: ViewContainerRef },
    { type: PermissionService },
    { type: ChangeDetectorRef }
];
PermissionDirective.propDecorators = {
    condition: [{ type: Input, args: ['abpPermission',] }]
};

class ReplaceableTemplateDirective {
    constructor(injector, templateRef, cfRes, vcRef, replaceableComponents, subscription) {
        this.injector = injector;
        this.templateRef = templateRef;
        this.cfRes = cfRes;
        this.vcRef = vcRef;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
        this.providedData = { inputs: {}, outputs: {} };
        this.context = {};
        this.defaultComponentSubscriptions = {};
        this.initialized = false;
        this.context = {
            initTemplate: ref => {
                this.resetDefaultComponent();
                this.defaultComponentRef = ref;
                this.setDefaultComponentInputs();
            },
        };
    }
    ngOnInit() {
        const component$ = this.replaceableComponents
            .get$(this.data.componentKey)
            .pipe(filter((res = {}) => !this.initialized || !compare(res.component, this.externalComponent)));
        this.subscription.addOne(component$, (res = {}) => {
            this.vcRef.clear();
            this.externalComponent = res.component;
            if (this.defaultComponentRef) {
                this.resetDefaultComponent();
            }
            if (res.component) {
                this.setProvidedData();
                const customInjector = Injector.create({
                    providers: [{ provide: 'REPLACEABLE_DATA', useValue: this.providedData }],
                    parent: this.injector,
                });
                this.vcRef.createComponent(this.cfRes.resolveComponentFactory(res.component), 0, customInjector);
            }
            else {
                this.vcRef.createEmbeddedView(this.templateRef, this.context);
            }
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (snq(() => changes.data.currentValue.inputs) && this.defaultComponentRef) {
            this.setDefaultComponentInputs();
        }
    }
    setDefaultComponentInputs() {
        if (!this.defaultComponentRef || (!this.data.inputs && !this.data.outputs))
            return;
        if (this.data.inputs) {
            for (const key in this.data.inputs) {
                if (this.data.inputs.hasOwnProperty(key)) {
                    if (!compare(this.defaultComponentRef[key], this.data.inputs[key].value)) {
                        this.defaultComponentRef[key] = this.data.inputs[key].value;
                    }
                }
            }
        }
        if (this.data.outputs) {
            for (const key in this.data.outputs) {
                if (this.data.outputs.hasOwnProperty(key)) {
                    if (!this.defaultComponentSubscriptions[key]) {
                        this.defaultComponentSubscriptions[key] = this.defaultComponentRef[key].subscribe(value => {
                            this.data.outputs[key](value);
                        });
                    }
                }
            }
        }
    }
    setProvidedData() {
        this.providedData = Object.assign(Object.assign({}, this.data), { inputs: {} });
        if (!this.data.inputs)
            return;
        Object.defineProperties(this.providedData.inputs, Object.assign({}, Object.keys(this.data.inputs).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: Object.assign({ enumerable: true, configurable: true, get: () => this.data.inputs[key].value }, (this.data.inputs[key].twoWay && {
                set: newValue => {
                    this.data.inputs[key].value = newValue;
                    this.data.outputs[`${key}Change`](newValue);
                },
            })) })), {})));
    }
    resetDefaultComponent() {
        Object.keys(this.defaultComponentSubscriptions).forEach(key => {
            this.defaultComponentSubscriptions[key].unsubscribe();
        });
        this.defaultComponentSubscriptions = {};
        this.defaultComponentRef = null;
    }
}
ReplaceableTemplateDirective.ɵfac = function ReplaceableTemplateDirective_Factory(t) { return new (t || ReplaceableTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ReplaceableComponentsService), ɵngcc0.ɵɵdirectiveInject(SubscriptionService)); };
ReplaceableTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ReplaceableTemplateDirective, selectors: [["", "abpReplaceableTemplate", ""]], inputs: { data: ["abpReplaceableTemplate", "data"] }, features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService]), ɵngcc0.ɵɵNgOnChangesFeature] });
ReplaceableTemplateDirective.ctorParameters = () => [
    { type: Injector },
    { type: TemplateRef },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: ReplaceableComponentsService },
    { type: SubscriptionService }
];
ReplaceableTemplateDirective.propDecorators = {
    data: [{ type: Input, args: ['abpReplaceableTemplate',] }]
};

class StopPropagationDirective {
    constructor(el, subscription) {
        this.el = el;
        this.subscription = subscription;
        this.stopPropEvent = new EventEmitter();
    }
    ngOnInit() {
        this.subscription.addOne(fromEvent(this.el.nativeElement, 'click'), (event) => {
            event.stopPropagation();
            this.stopPropEvent.emit(event);
        });
    }
}
StopPropagationDirective.ɵfac = function StopPropagationDirective_Factory(t) { return new (t || StopPropagationDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SubscriptionService)); };
StopPropagationDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StopPropagationDirective, selectors: [["", "click.stop", ""]], outputs: { stopPropEvent: "click.stop" }, features: [ɵngcc0.ɵɵProvidersFeature([SubscriptionService])] });
StopPropagationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: SubscriptionService }
];
StopPropagationDirective.propDecorators = {
    stopPropEvent: [{ type: Output, args: ['click.stop',] }]
};

/**
 *
 * @deprecated To be deleted in v5.0
 */
class VisibilityDirective {
    constructor(elRef, renderer) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.completed$ = new Subject();
    }
    ngAfterViewInit() {
        if (!this.focusedElement && this.elRef) {
            this.focusedElement = this.elRef.nativeElement;
        }
        let observer;
        observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (!mutation.target)
                    return;
                const htmlNodes = snq(() => Array.from(mutation.target.childNodes).filter(node => node instanceof HTMLElement), []);
                if (!htmlNodes.length) {
                    this.removeFromDOM();
                }
            });
        });
        observer.observe(this.focusedElement, {
            childList: true,
        });
        setTimeout(() => {
            const htmlNodes = snq(() => Array.from(this.focusedElement.childNodes).filter(node => node instanceof HTMLElement), []);
            if (!htmlNodes.length)
                this.removeFromDOM();
        }, 0);
        this.completed$.subscribe(() => observer.disconnect());
    }
    disconnect() {
        this.completed$.next();
        this.completed$.complete();
    }
    removeFromDOM() {
        if (!this.elRef.nativeElement)
            return;
        this.renderer.removeChild(this.elRef.nativeElement.parentElement, this.elRef.nativeElement);
        this.disconnect();
    }
}
VisibilityDirective.ɵfac = function VisibilityDirective_Factory(t) { return new (t || VisibilityDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
VisibilityDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: VisibilityDirective, selectors: [["", "abpVisibility", ""]], inputs: { focusedElement: ["abpVisibility", "focusedElement"] } });
VisibilityDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Optional }] },
    { type: Renderer2 }
];
VisibilityDirective.propDecorators = {
    focusedElement: [{ type: Input, args: ['abpVisibility',] }]
};

class OAuthConfigurationHandler {
    constructor(oAuthService, environmentService, options) {
        this.oAuthService = oAuthService;
        this.environmentService = environmentService;
        this.options = options;
        this.listenToSetEnvironment();
    }
    listenToSetEnvironment() {
        this.environmentService
            .createOnUpdateStream(state => state)
            .pipe(map(environment => environment.oAuthConfig), filter(config => !compare(config, this.options.environment.oAuthConfig)))
            .subscribe(config => {
            this.oAuthService.configure(config);
        });
    }
}
OAuthConfigurationHandler.ɵfac = function OAuthConfigurationHandler_Factory(t) { return new (t || OAuthConfigurationHandler)(ɵngcc0.ɵɵinject(ɵngcc6.OAuthService), ɵngcc0.ɵɵinject(EnvironmentService), ɵngcc0.ɵɵinject(CORE_OPTIONS)); };
OAuthConfigurationHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function OAuthConfigurationHandler_Factory() { return new OAuthConfigurationHandler(i0.ɵɵinject(i1$1.OAuthService), i0.ɵɵinject(EnvironmentService), i0.ɵɵinject(CORE_OPTIONS)); }, token: OAuthConfigurationHandler, providedIn: "root" });
OAuthConfigurationHandler.ctorParameters = () => [
    { type: OAuthService },
    { type: EnvironmentService },
    { type: undefined, decorators: [{ type: Inject, args: [CORE_OPTIONS,] }] }
];

class RoutesHandler {
    constructor(routes, router) {
        this.routes = routes;
        this.router = router;
        this.addRoutes();
    }
    addRoutes() {
        var _a, _b;
        (_b = (_a = this.router) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.forEach(({ path = '', data }) => {
            if (!(data === null || data === void 0 ? void 0 : data.routes))
                return;
            if (Array.isArray(data.routes)) {
                this.routes.add(data.routes);
                return;
            }
            const routes = flatRoutes([Object.assign({ path }, data.routes)], { path: '' });
            this.routes.add(routes);
        });
    }
}
RoutesHandler.ɵfac = function RoutesHandler_Factory(t) { return new (t || RoutesHandler)(ɵngcc0.ɵɵinject(RoutesService), ɵngcc0.ɵɵinject(ɵngcc3.Router, 8)); };
RoutesHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoutesHandler_Factory() { return new RoutesHandler(i0.ɵɵinject(RoutesService), i0.ɵɵinject(i1.Router, 8)); }, token: RoutesHandler, providedIn: "root" });
RoutesHandler.ctorParameters = () => [
    { type: RoutesService },
    { type: Router, decorators: [{ type: Optional }] }
];
function flatRoutes(routes, parent) {
    if (!routes)
        return [];
    return routes.reduce((acc, route) => {
        const _a = Object.assign(Object.assign({}, route), { parentName: parent.name, path: (parent.path + '/' + route.path).replace(/\/\//g, '/') }), { children } = _a, current = __rest(_a, ["children"]);
        acc.push(current, ...flatRoutes(children, current));
        return acc;
    }, []);
}

function getPathName(url) {
    const { pathname } = new URL(url, window.location.origin);
    return pathname;
}
class WebHttpUrlEncodingCodec {
    encodeKey(k) {
        return encodeURIComponent(k);
    }
    encodeValue(v) {
        return encodeURIComponent(v);
    }
    decodeKey(k) {
        return decodeURIComponent(k);
    }
    decodeValue(v) {
        return decodeURIComponent(v);
    }
}

const LOADER_DELAY = new InjectionToken('LOADER_DELAY');

class HttpWaitService {
    constructor(injector) {
        this.store = new InternalStore({
            requests: [],
            filteredRequests: [],
        });
        this.destroy$ = new Subject();
        this.delay = injector.get(LOADER_DELAY, 500);
    }
    getLoading() {
        return !!this.applyFilter(this.store.state.requests).length;
    }
    getLoading$() {
        return this.store
            .sliceState(({ requests }) => requests)
            .pipe(map(requests => !!this.applyFilter(requests).length), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()));
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ requests }) => !!this.applyFilter(requests).length);
    }
    clearLoading() {
        this.store.patch({ requests: [] });
    }
    addRequest(request) {
        this.store.patch({ requests: [...this.store.state.requests, request] });
    }
    deleteRequest(request) {
        const requests = this.store.state.requests.filter(r => r !== request);
        this.store.patch({ requests });
    }
    addFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = [
            ...this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r))),
            ...requests,
        ];
        this.store.patch({ filteredRequests });
    }
    removeFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r)));
        this.store.patch({ filteredRequests });
    }
    applyFilter(requests) {
        const { filteredRequests } = this.store.state;
        return requests.filter(({ method, url }) => !filteredRequests.find(filteredRequest => this.isSameRequest(filteredRequest, { method, endpoint: getPathName(url) })));
    }
    isSameRequest(filteredRequest, request) {
        const { method, endpoint } = filteredRequest;
        return endpoint === request.endpoint && method === request.method;
    }
}
HttpWaitService.ɵfac = function HttpWaitService_Factory(t) { return new (t || HttpWaitService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
HttpWaitService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpWaitService_Factory() { return new HttpWaitService(i0.ɵɵinject(i0.INJECTOR)); }, token: HttpWaitService, providedIn: "root" });
HttpWaitService.ctorParameters = () => [
    { type: Injector }
];

const TENANT_KEY = new InjectionToken('TENANT_KEY');

class ApiInterceptor {
    constructor(oAuthService, sessionState, httpWaitService, tenantKey) {
        this.oAuthService = oAuthService;
        this.sessionState = sessionState;
        this.httpWaitService = httpWaitService;
        this.tenantKey = tenantKey;
    }
    intercept(request, next) {
        this.httpWaitService.addRequest(request);
        return next
            .handle(request.clone({
            setHeaders: this.getAdditionalHeaders(request.headers),
        }))
            .pipe(finalize(() => this.httpWaitService.deleteRequest(request)));
    }
    getAdditionalHeaders(existingHeaders) {
        const headers = {};
        const token = this.oAuthService.getAccessToken();
        if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has('Authorization')) && token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        const lang = this.sessionState.getLanguage();
        if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has('Accept-Language')) && lang) {
            headers['Accept-Language'] = lang;
        }
        const tenant = this.sessionState.getTenant();
        if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has(this.tenantKey)) && (tenant === null || tenant === void 0 ? void 0 : tenant.id)) {
            headers[this.tenantKey] = tenant.id;
        }
        return headers;
    }
}
ApiInterceptor.ɵfac = function ApiInterceptor_Factory(t) { return new (t || ApiInterceptor)(ɵngcc0.ɵɵinject(ɵngcc6.OAuthService), ɵngcc0.ɵɵinject(SessionStateService), ɵngcc0.ɵɵinject(HttpWaitService), ɵngcc0.ɵɵinject(TENANT_KEY)); };
ApiInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function ApiInterceptor_Factory() { return new ApiInterceptor(i0.ɵɵinject(i1$1.OAuthService), i0.ɵɵinject(SessionStateService), i0.ɵɵinject(HttpWaitService), i0.ɵɵinject(TENANT_KEY)); }, token: ApiInterceptor, providedIn: "root" });
ApiInterceptor.ctorParameters = () => [
    { type: OAuthService },
    { type: SessionStateService },
    { type: HttpWaitService },
    { type: String, decorators: [{ type: Inject, args: [TENANT_KEY,] }] }
];

class LocalizationPipe {
    constructor(localization) {
        this.localization = localization;
    }
    transform(value = '', ...interpolateParams) {
        return this.localization.instant(value, ...interpolateParams.reduce((acc, val) => (Array.isArray(val) ? [...acc, ...val] : [...acc, val]), []));
    }
}
LocalizationPipe.ɵfac = function LocalizationPipe_Factory(t) { return new (t || LocalizationPipe)(ɵngcc0.ɵɵdirectiveInject(LocalizationService, 16)); };
LocalizationPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "abpLocalization", type: LocalizationPipe, pure: true });
LocalizationPipe.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalizationPipe, factory: LocalizationPipe.ɵfac });
LocalizationPipe.ctorParameters = () => [
    { type: LocalizationService }
];

class LocalizationModule {
}
LocalizationModule.ɵfac = function LocalizationModule_Factory(t) { return new (t || LocalizationModule)(); };
LocalizationModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LocalizationModule });
LocalizationModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

class SortPipe {
    transform(value, sortOrder = 'asc', sortKey) {
        sortOrder = sortOrder && sortOrder.toLowerCase();
        if (!value || (sortOrder !== 'asc' && sortOrder !== 'desc'))
            return value;
        let numberArray = [];
        let stringArray = [];
        if (!sortKey) {
            numberArray = value.filter(item => typeof item === 'number').sort();
            stringArray = value.filter(item => typeof item === 'string').sort();
        }
        else {
            numberArray = value
                .filter(item => typeof item[sortKey] === 'number')
                .sort((a, b) => a[sortKey] - b[sortKey]);
            stringArray = value
                .filter(item => typeof item[sortKey] === 'string')
                .sort((a, b) => {
                if (a[sortKey] < b[sortKey])
                    return -1;
                else if (a[sortKey] > b[sortKey])
                    return 1;
                else
                    return 0;
            });
        }
        const sorted = [
            ...numberArray,
            ...stringArray,
            ...value.filter(item => typeof (sortKey ? item[sortKey] : item) !== 'number' &&
                typeof (sortKey ? item[sortKey] : item) !== 'string'),
        ];
        return sortOrder === 'asc' ? sorted : sorted.reverse();
    }
}
SortPipe.ɵfac = function SortPipe_Factory(t) { return new (t || SortPipe)(); };
SortPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "abpSort", type: SortPipe, pure: true });
SortPipe.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SortPipe, factory: SortPipe.ɵfac });

class LocaleId extends String {
    constructor(localizationService) {
        super();
        this.localizationService = localizationService;
    }
    toString() {
        const { currentLang } = this.localizationService;
        return differentLocales[currentLang] || currentLang;
    }
    valueOf() {
        return this.toString();
    }
}
const LocaleProvider = {
    provide: LOCALE_ID,
    useClass: LocaleId,
    deps: [LocalizationService],
};

class ProfileService {
    constructor(rest) {
        this.rest = rest;
        this.apiName = 'AbpIdentity';
    }
    get() {
        const request = {
            method: 'GET',
            url: '/api/identity/my-profile',
        };
        return this.rest.request(request, { apiName: this.apiName });
    }
    update(body) {
        const request = {
            method: 'PUT',
            url: '/api/identity/my-profile',
            body,
        };
        return this.rest.request(request, {
            apiName: this.apiName,
        });
    }
    changePassword(body, skipHandleError = false) {
        const request = {
            method: 'POST',
            url: '/api/identity/my-profile/change-password',
            body,
        };
        return this.rest.request(request, {
            skipHandleError,
            apiName: this.apiName,
        });
    }
}
ProfileService.ɵfac = function ProfileService_Factory(t) { return new (t || ProfileService)(ɵngcc0.ɵɵinject(RestService)); };
ProfileService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProfileService_Factory() { return new ProfileService(i0.ɵɵinject(RestService)); }, token: ProfileService, providedIn: "root" });
ProfileService.ctorParameters = () => [
    { type: RestService }
];

let ProfileState = class ProfileState {
    constructor(profileService) {
        this.profileService = profileService;
    }
    static getProfile({ profile }) {
        return profile;
    }
    getProfile({ patchState }) {
        return this.profileService.get().pipe(tap(profile => patchState({
            profile,
        })));
    }
    updateProfile({ patchState }, { payload }) {
        return this.profileService.update(payload).pipe(tap(profile => patchState({
            profile,
        })));
    }
    changePassword(_, { payload }) {
        return this.profileService.changePassword(payload, true);
    }
};
ProfileState.ɵfac = function ProfileState_Factory(t) { return new (t || ProfileState)(ɵngcc0.ɵɵinject(ProfileService)); };
ProfileState.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ProfileState, factory: function (t) { return ProfileState.ɵfac(t); } });
ProfileState.ctorParameters = () => [
    { type: ProfileService }
];
__decorate([
    Action(GetProfile)
], ProfileState.prototype, "getProfile", null);
__decorate([
    Action(UpdateProfile)
], ProfileState.prototype, "updateProfile", null);
__decorate([
    Action(ChangePassword)
], ProfileState.prototype, "changePassword", null);
__decorate([
    Selector()
], ProfileState, "getProfile", null);
ProfileState = __decorate([
    State({
        name: 'ProfileState',
        defaults: {},
    })
], ProfileState);

const cookieKey = 'rememberMe';
const storageKey = 'passwordFlow';
function pipeToLogin(params, injector) {
    const configState = injector.get(ConfigStateService);
    const appConfigService = injector.get(AbpApplicationConfigurationService);
    const router = injector.get(Router);
    return pipe(switchMap(() => appConfigService.get()), tap(res => {
        configState.setState(res);
        setRememberMe(params.rememberMe);
        if (params.redirectUrl)
            router.navigate([params.redirectUrl]);
    }));
}
function setTokenResponseToStorage(injector, tokenRes) {
    const { access_token, refresh_token, scope: grantedScopes, expires_in } = tokenRes;
    const storage = injector.get(OAuthStorage);
    storage.setItem('access_token', access_token);
    storage.setItem('refresh_token', refresh_token);
    storage.setItem('access_token_stored_at', '' + Date.now());
    if (grantedScopes) {
        storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));
    }
    if (expires_in) {
        const expiresInMilliSeconds = expires_in * 1000;
        const now = new Date();
        const expiresAt = now.getTime() + expiresInMilliSeconds;
        storage.setItem('expires_at', '' + expiresAt);
    }
}
function setRememberMe(remember) {
    removeRememberMe();
    localStorage.setItem(storageKey, 'true');
    document.cookie = `${cookieKey}=true; path=/${remember ? ' ;expires=Fri, 31 Dec 9999 23:59:59 GMT' : ''}`;
}
function removeRememberMe() {
    localStorage.removeItem(storageKey);
    document.cookie = cookieKey + '= ; path=/; expires = Thu, 01 Jan 1970 00:00:00 GMT';
}

const oAuthStorage = localStorage;
class AuthFlowStrategy {
    constructor(injector) {
        this.injector = injector;
        this.catchError = err => this.store.dispatch(new RestOccurError(err));
        this.store = injector.get(Store);
        this.environment = injector.get(EnvironmentService);
        this.configState = injector.get(ConfigStateService);
        this.oAuthService = injector.get(OAuthService);
        this.appConfigService = injector.get(AbpApplicationConfigurationService);
        this.sessionState = injector.get(SessionStateService);
        this.oAuthConfig = this.environment.getEnvironment().oAuthConfig;
        this.tenantKey = injector.get(TENANT_KEY);
        this.listenToOauthErrors();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldClear = shouldStorageClear(this.environment.getEnvironment().oAuthConfig.clientId, oAuthStorage);
            if (shouldClear)
                clearOAuthStorage(oAuthStorage);
            this.oAuthService.configure(this.oAuthConfig);
            return this.oAuthService
                .loadDiscoveryDocument()
                .then(() => {
                if (this.oAuthService.hasValidAccessToken() || !this.oAuthService.getRefreshToken()) {
                    return Promise.resolve();
                }
                return this.refreshToken();
            })
                .catch(this.catchError);
        });
    }
    refreshToken() {
        return this.oAuthService.refreshToken().catch(() => clearOAuthStorage());
    }
    listenToOauthErrors() {
        this.oAuthService.events
            .pipe(filter(event => event instanceof OAuthErrorEvent), tap(() => clearOAuthStorage()), switchMap(() => this.appConfigService.get()))
            .subscribe(res => {
            this.configState.setState(res);
        });
    }
}
class AuthCodeFlowStrategy extends AuthFlowStrategy {
    constructor() {
        super(...arguments);
        this.isInternalAuth = false;
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.init.call(this)
                .then(() => this.oAuthService.tryLogin().catch(noop))
                .then(() => this.oAuthService.setupAutomaticSilentRefresh({}, 'access_token'));
        });
    }
    navigateToLogin(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
    }
    checkIfInternalAuth(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
        return false;
    }
    logout(queryParams) {
        return from(this.oAuthService.revokeTokenAndLogout(this.getCultureParams(queryParams)));
    }
    login(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
        return of(null);
    }
    getCultureParams(queryParams) {
        const lang = this.sessionState.getLanguage();
        const culture = { culture: lang, 'ui-culture': lang };
        return Object.assign(Object.assign({}, (lang && culture)), queryParams);
    }
}
class AuthPasswordFlowStrategy extends AuthFlowStrategy {
    constructor() {
        super(...arguments);
        this.isInternalAuth = true;
        this.cookieKey = 'rememberMe';
        this.storageKey = 'passwordFlow';
    }
    listenToTokenExpiration() {
        this.oAuthService.events
            .pipe(filter(event => event instanceof OAuthInfoEvent &&
            event.type === 'token_expires' &&
            event.info === 'access_token'))
            .subscribe(() => {
            if (this.oAuthService.getRefreshToken()) {
                this.refreshToken();
            }
            else {
                this.oAuthService.logOut();
                removeRememberMe();
                this.appConfigService.get().subscribe(res => {
                    this.configState.setState(res);
                });
            }
        });
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!getCookieValueByName(this.cookieKey) && localStorage.getItem(this.storageKey)) {
                this.oAuthService.logOut();
            }
            return _super.init.call(this).then(() => this.listenToTokenExpiration());
        });
    }
    navigateToLogin(queryParams) {
        const router = this.injector.get(Router);
        router.navigate(['/login'], { queryParams });
    }
    checkIfInternalAuth() {
        return true;
    }
    login(params) {
        const tenant = this.sessionState.getTenant();
        return from(this.oAuthService.fetchTokenUsingPasswordFlow(params.username, params.password, new HttpHeaders(Object.assign({}, (tenant && tenant.id && { [this.tenantKey]: tenant.id }))))).pipe(this.pipeToLogin(params));
    }
    loginCaptcha(params) {
        const tenant = this.sessionState.getTenant();
        return from(this.oAuthService.fetchTokenUsingPasswordRecaptchaFlow(params.username, params.password, params.recaptcha, new HttpHeaders(Object.assign({}, (tenant && tenant.id && { [this.tenantKey]: tenant.id }))))).pipe(this.pipeToLogin(params));
    }
    pipeToLogin(params) {
        const router = this.injector.get(Router);
        return pipe(switchMap(() => this.appConfigService.get()), tap(res => {
            this.configState.setState(res);
            setRememberMe(params.rememberMe);
            if (params.redirectUrl)
                router.navigate([params.redirectUrl]);
        }));
    }
    logout(queryParams) {
        const router = this.injector.get(Router);
        return from(this.oAuthService.revokeTokenAndLogout(queryParams)).pipe(switchMap(() => this.appConfigService.get()), tap(res => {
            this.configState.setState(res);
            router.navigateByUrl('/');
            removeRememberMe();
        }));
    }
    refreshToken() {
        return this.oAuthService.refreshToken().catch(() => {
            clearOAuthStorage();
            removeRememberMe();
        });
    }
}
const AUTH_FLOW_STRATEGY = {
    Code(injector) {
        return new AuthCodeFlowStrategy(injector);
    },
    Password(injector) {
        return new AuthPasswordFlowStrategy(injector);
    },
};
function clearOAuthStorage(storage = oAuthStorage) {
    const keys = [
        'access_token',
        'id_token',
        'refresh_token',
        'nonce',
        'PKCE_verifier',
        'expires_at',
        'id_token_claims_obj',
        'id_token_expires_at',
        'id_token_stored_at',
        'access_token_stored_at',
        'granted_scopes',
        'session_state',
    ];
    keys.forEach(key => storage.removeItem(key));
}
function shouldStorageClear(clientId, storage) {
    const key = 'abpOAuthClientId';
    if (!storage.getItem(key)) {
        storage.setItem(key, clientId);
        return false;
    }
    const shouldClear = storage.getItem(key) !== clientId;
    if (shouldClear)
        storage.setItem(key, clientId);
    return shouldClear;
}
function getCookieValueByName(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return match ? match[2] : '';
}

Date.prototype.toLocalISOString = function () {
    const timezoneOffset = this.getTimezoneOffset();
    return new Date(this.getTime() - timezoneOffset * 60000).toISOString();
};

class AuthService {
    constructor(injector) {
        this.injector = injector;
    }
    get isInternalAuth() {
        return this.strategy.isInternalAuth;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const environmentService = this.injector.get(EnvironmentService);
            return environmentService
                .getEnvironment$()
                .pipe(map(env => env === null || env === void 0 ? void 0 : env.oAuthConfig), filter(oAuthConfig => !!oAuthConfig), tap(oAuthConfig => {
                this.strategy =
                    oAuthConfig.responseType === 'code'
                        ? AUTH_FLOW_STRATEGY.Code(this.injector)
                        : AUTH_FLOW_STRATEGY.Password(this.injector);
            }), switchMap(() => from(this.strategy.init())), take(1))
                .toPromise();
        });
    }
    logout(queryParams) {
        return this.strategy.logout(queryParams);
    }
    /**
     * @deprecated Use navigateToLogin method instead. To be deleted in v5.0
     */
    initLogin() {
        this.strategy.navigateToLogin();
    }
    navigateToLogin(queryParams) {
        this.strategy.navigateToLogin(queryParams);
    }
    login(params) {
        return this.strategy.login(params);
    }
    loginCaptcha(params) {
        return this.strategy.loginCaptcha(params);
    }l
}
AuthService.ɵfac = function AuthService_Factory(t) { return new (t || AuthService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
AuthService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(i0.ɵɵinject(i0.INJECTOR)); }, token: AuthService, providedIn: "root" });
AuthService.ctorParameters = () => [
    { type: Injector }
];

const APP_INIT_ERROR_HANDLERS = new InjectionToken('APP_INIT_ERROR_HANDLERS');

function getRemoteEnv(injector, environment) {
    const environmentService = injector.get(EnvironmentService);
    const { remoteEnv } = environment;
    const { headers = {}, method = 'GET', url } = remoteEnv || {};
    if (!url)
        return Promise.resolve();
    const http = injector.get(HttpClient);
    const store = injector.get(Store);
    return http
        .request(method, url, { headers })
        .pipe(catchError(err => store.dispatch(new RestOccurError(err))), // TODO: Condiser get handle function from a provider
    tap(env => environmentService.setState(mergeEnvironments(environment, env, remoteEnv))))
        .toPromise();
}
function mergeEnvironments(local, remote, config) {
    switch (config.mergeStrategy) {
        case 'deepmerge':
            return deepMerge(local, remote);
        case 'overwrite':
        case null:
        case undefined:
            return remote;
        default:
            return config.mergeStrategy(local, remote);
    }
}

class AbpTenantService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
        this.findTenantById = (id, headers) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-id/${id}`,
            headers,
        }, { apiName: this.apiName });
        this.findTenantByName = (name, headers) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-name/${name}`,
            headers,
        }, { apiName: this.apiName });
    }
}
AbpTenantService.ɵfac = function AbpTenantService_Factory(t) { return new (t || AbpTenantService)(ɵngcc0.ɵɵinject(RestService)); };
AbpTenantService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbpTenantService_Factory() { return new AbpTenantService(i0.ɵɵinject(RestService)); }, token: AbpTenantService, providedIn: "root" });
AbpTenantService.ctorParameters = () => [
    { type: RestService }
];

class MultiTenancyService {
    constructor(restService, sessionState, tenantService, configStateService, tenantKey) {
        this.restService = restService;
        this.sessionState = sessionState;
        this.tenantService = tenantService;
        this.configStateService = configStateService;
        this.tenantKey = tenantKey;
        this.domainTenant = null;
        this.isTenantBoxVisible = true;
        this.apiName = 'abp';
        this.setTenantToState = (tenant) => {
            this.sessionState.setTenant({ id: tenant.tenantId, name: tenant.name, isAvailable: true });
            return this.configStateService.refreshAppState().pipe(map(_ => tenant));
        };
    }
    /**
     * @deprecated Use AbpTenantService.findTenantByName method instead. To be deleted in v5.0.
     */
    findTenantByName(name, headers) {
        return this.restService.request({
            url: `/api/abp/multi-tenancy/tenants/by-name/${name}`,
            method: 'GET',
            headers,
        }, { apiName: this.apiName });
    }
    /**
     * @deprecated Use AbpTenantService.findTenantById method instead. To be deleted in v5.0.
     */
    findTenantById(id, headers) {
        return this.restService.request({ url: `/api/abp/multi-tenancy/tenants/by-id/${id}`, method: 'GET', headers }, { apiName: this.apiName });
    }
    setTenantByName(tenantName) {
        return this.tenantService
            .findTenantByName(tenantName, { [this.tenantKey]: '' })
            .pipe(switchMap(this.setTenantToState));
    }
    setTenantById(tenantId) {
        return this.tenantService
            .findTenantById(tenantId, { [this.tenantKey]: '' })
            .pipe(switchMap(this.setTenantToState));
    }
}
MultiTenancyService.ɵfac = function MultiTenancyService_Factory(t) { return new (t || MultiTenancyService)(ɵngcc0.ɵɵinject(RestService), ɵngcc0.ɵɵinject(SessionStateService), ɵngcc0.ɵɵinject(AbpTenantService), ɵngcc0.ɵɵinject(ConfigStateService), ɵngcc0.ɵɵinject(TENANT_KEY)); };
MultiTenancyService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MultiTenancyService_Factory() { return new MultiTenancyService(i0.ɵɵinject(RestService), i0.ɵɵinject(SessionStateService), i0.ɵɵinject(AbpTenantService), i0.ɵɵinject(ConfigStateService), i0.ɵɵinject(TENANT_KEY)); }, token: MultiTenancyService, providedIn: "root" });
MultiTenancyService.ctorParameters = () => [
    { type: RestService },
    { type: SessionStateService },
    { type: AbpTenantService },
    { type: ConfigStateService },
    { type: String, decorators: [{ type: Inject, args: [TENANT_KEY,] }] }
];

const tenancyPlaceholder = '{0}';
function getCurrentTenancyName(appBaseUrl) {
    var _a;
    if (appBaseUrl.charAt(appBaseUrl.length - 1) !== '/')
        appBaseUrl += '/';
    const parseTokens = createTokenParser(appBaseUrl);
    const token = tenancyPlaceholder.replace(/[}{]/g, '');
    return (_a = parseTokens(window.location.href)[token]) === null || _a === void 0 ? void 0 : _a[0];
}
function getCurrentTenancyNameFromUrl(tenantKey) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(tenantKey);
}
function parseTenantFromUrl(injector) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const environmentService = injector.get(EnvironmentService);
        const multiTenancyService = injector.get(MultiTenancyService);
        const baseUrl = ((_b = (_a = environmentService.getEnvironment()) === null || _a === void 0 ? void 0 : _a.application) === null || _b === void 0 ? void 0 : _b.baseUrl) || '';
        const tenancyName = getCurrentTenancyName(baseUrl);
        const hideTenantBox = () => {
            multiTenancyService.isTenantBoxVisible = false;
        };
        const setDomainTenant = (tenant) => {
            multiTenancyService.domainTenant = {
                id: tenant.tenantId,
                name: tenant.name,
                isAvailable: true,
            };
        };
        const setEnvironmentWithDomainTenant = (tenant) => {
            hideTenantBox();
            setDomainTenant(tenant);
            replaceTenantNameWithinEnvironment(injector, tenant.name);
        };
        if (tenancyName) {
            return multiTenancyService
                .setTenantByName(tenancyName)
                .pipe(tap(setEnvironmentWithDomainTenant))
                .toPromise();
        }
        else {
            /**
             * If there is no tenant, we still have to clean up {0}. from baseUrl to avoid incorrect http requests.
             */
            replaceTenantNameWithinEnvironment(injector, '', tenancyPlaceholder + '.');
            const tenantIdFromQueryParams = getCurrentTenancyNameFromUrl(multiTenancyService.tenantKey);
            if (tenantIdFromQueryParams) {
                return multiTenancyService.setTenantById(tenantIdFromQueryParams).toPromise();
            }
        }
        return Promise.resolve();
    });
}
function replaceTenantNameWithinEnvironment(injector, tenancyName, placeholder = tenancyPlaceholder) {
    const environmentService = injector.get(EnvironmentService);
    const environment = clone(environmentService.getEnvironment());
    if (environment.application.baseUrl) {
        environment.application.baseUrl = environment.application.baseUrl.replace(placeholder, tenancyName);
    }
    if (environment.oAuthConfig.redirectUri) {
        environment.oAuthConfig.redirectUri = environment.oAuthConfig.redirectUri.replace(placeholder, tenancyName);
    }
    environment.oAuthConfig.issuer = environment.oAuthConfig.issuer.replace(placeholder, tenancyName);
    Object.keys(environment.apis).forEach(api => {
        Object.keys(environment.apis[api]).forEach(key => {
            environment.apis[api][key] = environment.apis[api][key].replace(placeholder, tenancyName);
        });
    });
    return environmentService.setState(environment);
}

function getInitialData(injector) {
    const fn = () => __awaiter(this, void 0, void 0, function* () {
        const environmentService = injector.get(EnvironmentService);
        const configState = injector.get(ConfigStateService);
        const appConfigService = injector.get(AbpApplicationConfigurationService);
        const options = injector.get(CORE_OPTIONS);
        environmentService.setState(options.environment);
        yield getRemoteEnv(injector, options.environment);
        yield parseTenantFromUrl(injector);
        yield injector.get(AuthService).init();
        if (options.skipGetAppConfiguration)
            return;
        return appConfigService
            .get()
            .pipe(tap(res => configState.setState(res)), tap(() => checkAccessToken(injector)), tap(() => {
            const currentTenant = configState.getOne('currentTenant');
            injector.get(SessionStateService).setTenant(currentTenant);
        }), catchError(error => {
            const appInitErrorHandlers = injector.get(APP_INIT_ERROR_HANDLERS, null);
            if (appInitErrorHandlers && appInitErrorHandlers.length) {
                appInitErrorHandlers.forEach(func => func(error));
            }
            return throwError(error);
        }))
            .toPromise();
    });
    return fn;
}
function checkAccessToken(injector) {
    const configState = injector.get(ConfigStateService);
    const oAuth = injector.get(OAuthService);
    if (oAuth.hasValidAccessToken() && !configState.getDeep('currentUser.id')) {
        clearOAuthStorage();
    }
}
function localeInitializer(injector) {
    const fn = () => {
        const sessionState = injector.get(SessionStateService);
        const { registerLocaleFn } = injector.get(CORE_OPTIONS);
        const lang = sessionState.getLanguage() || 'en';
        return new Promise((resolve, reject) => {
            registerLocaleFn(lang).then(module => {
                if (module === null || module === void 0 ? void 0 : module.default)
                    registerLocaleData(module.default);
                return resolve('resolved');
            }, reject);
        });
    };
    return fn;
}

function storageFactory() {
    return oAuthStorage;
}
/**
 * BaseCoreModule is the module that holds
 * all imports, declarations, exports, and entryComponents
 * but not the providers.
 * This module will be imported and exported by all others.
 */
class BaseCoreModule {
}
BaseCoreModule.ɵfac = function BaseCoreModule_Factory(t) { return new (t || BaseCoreModule)(); };
BaseCoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BaseCoreModule });
BaseCoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [LocalizationPipe], imports: [[
            OAuthModule,
            CommonModule,
            HttpClientModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            LocalizationModule,
        ], CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule, LocalizationModule] });
/**
 * RootCoreModule is the module that will be used at root level
 * and it introduces imports useful at root level (e.g. NGXS)
 */
class RootCoreModule {
}
RootCoreModule.ɵfac = function RootCoreModule_Factory(t) { return new (t || RootCoreModule)(); };
RootCoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: RootCoreModule });
RootCoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            BaseCoreModule,
            LocalizationModule,
            NgxsModule.forFeature([ProfileState]),
            OAuthModule.forRoot(),
            HttpClientXsrfModule.withOptions({
                cookieName: 'XSRF-TOKEN',
                headerName: 'RequestVerificationToken'
            }),
        ], BaseCoreModule, LocalizationModule] });
/**
 * CoreModule is the module that is publicly available
 */
class CoreModule {
    static forRoot(options = {}) {
        return {
            ngModule: RootCoreModule,
            providers: [
                LocaleProvider,
                {
                    provide: 'CORE_OPTIONS',
                    useValue: options,
                },
                {
                    provide: CORE_OPTIONS,
                    useFactory: coreOptionsFactory,
                    deps: ['CORE_OPTIONS'],
                },
                {
                    provide: HTTP_INTERCEPTORS,
                    useExisting: ApiInterceptor,
                    multi: true,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [OAuthConfigurationHandler],
                    useFactory: noop,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [Injector],
                    useFactory: getInitialData,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [Injector],
                    useFactory: localeInitializer,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [LocalizationService],
                    useFactory: noop,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [RoutesHandler],
                    useFactory: noop,
                },
                { provide: OAuthStorage, useFactory: storageFactory },
                { provide: TENANT_KEY, useValue: options.tenantKey || '__tenant' },
            ],
        };
    }
}
CoreModule.ɵfac = function CoreModule_Factory(t) { return new (t || CoreModule)(); };
CoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CoreModule });
CoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[BaseCoreModule], BaseCoreModule] });
function ngxsStoragePluginSerialize(data) {
    return data;
}

class AuthGuard {
    constructor(oauthService, authService) {
        this.oauthService = oauthService;
        this.authService = authService;
    }
    canActivate() {
        const hasValidAccessToken = this.oauthService.hasValidAccessToken();
        if (hasValidAccessToken) {
            return true;
        }
        this.authService.navigateToLogin();
        return false;
    }
}
AuthGuard.ɵfac = function AuthGuard_Factory(t) { return new (t || AuthGuard)(ɵngcc0.ɵɵinject(ɵngcc6.OAuthService), ɵngcc0.ɵɵinject(AuthService)); };
AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(i1$1.OAuthService), i0.ɵɵinject(AuthService)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.ctorParameters = () => [
    { type: OAuthService },
    { type: AuthService }
];

class PermissionGuard {
    constructor(router, routesService, store, permissionService) {
        this.router = router;
        this.routesService = routesService;
        this.store = store;
        this.permissionService = permissionService;
    }
    canActivate(route, state) {
        let { requiredPolicy } = route.data || {};
        if (!requiredPolicy) {
            const routeFound = findRoute(this.routesService, getRoutePath(this.router, state.url));
            requiredPolicy = routeFound === null || routeFound === void 0 ? void 0 : routeFound.requiredPolicy;
        }
        if (!requiredPolicy)
            return of(true);
        return this.permissionService.getGrantedPolicy$(requiredPolicy).pipe(tap(access => {
            if (!access) {
                this.store.dispatch(new RestOccurError({ status: 403 }));
            }
        }));
    }
}
PermissionGuard.ɵfac = function PermissionGuard_Factory(t) { return new (t || PermissionGuard)(ɵngcc0.ɵɵinject(ɵngcc3.Router), ɵngcc0.ɵɵinject(RoutesService), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(PermissionService)); };
PermissionGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function PermissionGuard_Factory() { return new PermissionGuard(i0.ɵɵinject(i1.Router), i0.ɵɵinject(RoutesService), i0.ɵɵinject(i4.Store), i0.ɵɵinject(PermissionService)); }, token: PermissionGuard, providedIn: "root" });
PermissionGuard.ctorParameters = () => [
    { type: Router },
    { type: RoutesService },
    { type: Store },
    { type: PermissionService }
];

class ListResultDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (initialValues.hasOwnProperty(key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class PagedResultDto extends ListResultDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class LimitedResultRequestDto {
    constructor(initialValues = {}) {
        this.maxResultCount = 10;
        for (const key in initialValues) {
            if (initialValues.hasOwnProperty(key) && initialValues[key] !== undefined) {
                this[key] = initialValues[key];
            }
        }
    }
}
class PagedResultRequestDto extends LimitedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class PagedAndSortedResultRequestDto extends PagedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class EntityDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (initialValues.hasOwnProperty(key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class CreationAuditedEntityDto extends EntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class CreationAuditedEntityWithUserDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class AuditedEntityDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class AuditedEntityWithUserDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class FullAuditedEntityDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class FullAuditedEntityWithUserDto extends FullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleObject {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (initialValues.hasOwnProperty(key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class ExtensibleEntityDto extends ExtensibleObject {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityDto extends ExtensibleEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityWithUserDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityWithUserDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityWithUserDto extends ExtensibleFullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}

/**
 * @deprecated Use AbpApplicationConfigurationService instead. To be deleted in v5.0.
 */
class ApplicationConfigurationService {
    constructor(rest) {
        this.rest = rest;
    }
    getConfiguration() {
        const request = {
            method: 'GET',
            url: '/api/abp/application-configuration',
        };
        return this.rest.request(request, {});
    }
}
ApplicationConfigurationService.ɵfac = function ApplicationConfigurationService_Factory(t) { return new (t || ApplicationConfigurationService)(ɵngcc0.ɵɵinject(RestService)); };
ApplicationConfigurationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ApplicationConfigurationService_Factory() { return new ApplicationConfigurationService(i0.ɵɵinject(RestService)); }, token: ApplicationConfigurationService, providedIn: "root" });
ApplicationConfigurationService.ctorParameters = () => [
    { type: RestService }
];

class ContentProjectionService {
    constructor(injector) {
        this.injector = injector;
    }
    projectContent(projectionStrategy, injector = this.injector) {
        return projectionStrategy.injectContent(injector);
    }
}
ContentProjectionService.ɵfac = function ContentProjectionService_Factory(t) { return new (t || ContentProjectionService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
ContentProjectionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ContentProjectionService_Factory() { return new ContentProjectionService(i0.ɵɵinject(i0.INJECTOR)); }, token: ContentProjectionService, providedIn: "root" });
ContentProjectionService.ctorParameters = () => [
    { type: Injector }
];

function getShortDateFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat.shortDatePattern;
}
function getShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat.shortTimePattern.replace('tt', 'a');
}
function getShortDateShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return `${dateTimeFormat.shortDatePattern} ${dateTimeFormat.shortTimePattern.replace('tt', 'a')}`;
}

class LazyModuleFactory extends NgModuleFactory {
    constructor(moduleWithProviders) {
        super();
        this.moduleWithProviders = moduleWithProviders;
    }
    get moduleType() {
        return this.moduleWithProviders.ngModule;
    }
    create(parentInjector) {
        const injector = Injector.create({
            parent: parentInjector,
            providers: this.moduleWithProviders.providers,
        });
        const compiler = injector.get(Compiler);
        const factory = compiler.compileModuleSync(this.moduleType);
        return factory.create(injector);
    }
}
function featuresFactory(configState, featureKeys, mapFn = features => features) {
    return configState.getFeatures$(featureKeys).pipe(filter(Boolean), map(mapFn));
}

function downloadBlob(blob, filename) {
    const blobUrl = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = blobUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window,
    }));
    document.body.removeChild(link);
}

function isNumber(value) {
    /* tslint:disable-next-line:triple-equals */
    return value == Number(value);
}

function mapEnumToOptions(_enum) {
    const options = [];
    for (const member in _enum)
        if (!isNumber(member))
            options.push({
                key: member,
                value: _enum[member],
            });
    return options;
}

// tslint:disable: no-bitwise
function uuid(a) {
    return a
        ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)
        : ('' + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);
}
function generateHash(value) {
    let hashed = 0;
    let charCode;
    for (let i = 0; i < value.length; i++) {
        charCode = value.charCodeAt(i);
        hashed = (hashed << 5) - hashed + charCode;
        hashed |= 0;
    }
    return hashed;
}
function generatePassword(length = 8) {
    length = Math.min(Math.max(4, length), 128);
    const lowers = 'abcdefghijklmnopqrstuvwxyz';
    const uppers = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const specials = '!@#$%&*()_+{}<>?[]./';
    const all = lowers + uppers + numbers + specials;
    const getRandom = (chrSet) => chrSet[Math.floor(Math.random() * chrSet.length)];
    const password = Array({ length });
    password[0] = getRandom(lowers);
    password[1] = getRandom(uppers);
    password[2] = getRandom(numbers);
    password[3] = getRandom(specials);
    for (let i = 4; i < length; i++) {
        password[i] = getRandom(all);
    }
    return password.sort(() => 0.5 - Math.random()).join('');
}

class CrossOriginStrategy {
    constructor(crossorigin, integrity) {
        this.crossorigin = crossorigin;
        this.integrity = integrity;
    }
    setCrossOrigin(element) {
        if (this.integrity)
            element.setAttribute('integrity', this.integrity);
        element.setAttribute('crossorigin', this.crossorigin);
    }
}
class NoCrossOriginStrategy extends CrossOriginStrategy {
    setCrossOrigin() { }
}
const CROSS_ORIGIN_STRATEGY = {
    Anonymous(integrity) {
        return new CrossOriginStrategy('anonymous', integrity);
    },
    UseCredentials(integrity) {
        return new CrossOriginStrategy('use-credentials', integrity);
    },
    None() {
        return new NoCrossOriginStrategy(null);
    },
};

class DomStrategy {
    constructor(target = document.head, position = 'beforeend') {
        this.target = target;
        this.position = position;
    }
    insertElement(element) {
        this.target.insertAdjacentElement(this.position, element);
    }
}
const DOM_STRATEGY = {
    AfterElement(element) {
        return new DomStrategy(element, 'afterend');
    },
    AppendToBody() {
        return new DomStrategy(document.body, 'beforeend');
    },
    AppendToHead() {
        return new DomStrategy(document.head, 'beforeend');
    },
    BeforeElement(element) {
        return new DomStrategy(element, 'beforebegin');
    },
    PrependToHead() {
        return new DomStrategy(document.head, 'afterbegin');
    },
};

function fromLazyLoad(element, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
    crossOriginStrategy.setCrossOrigin(element);
    domStrategy.insertElement(element);
    return new Observable((observer) => {
        element.onload = (event) => {
            clearCallbacks(element);
            observer.next(event);
            observer.complete();
        };
        const handleError = createErrorHandler(observer, element);
        element.onerror = handleError;
        element.onabort = handleError;
        element.onemptied = handleError;
        element.onstalled = handleError;
        element.onsuspend = handleError;
        return () => {
            clearCallbacks(element);
            observer.complete();
        };
    });
}
function createErrorHandler(observer, element) {
    /* tslint:disable-next-line:only-arrow-functions */
    return function (event) {
        clearCallbacks(element);
        element.parentNode.removeChild(element);
        observer.error(event);
    };
}
function clearCallbacks(element) {
    element.onload = null;
    element.onerror = null;
    element.onabort = null;
    element.onemptied = null;
    element.onstalled = null;
    element.onsuspend = null;
}

// tslint:disable: max-line-length
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * @deprecated no longer working, please use SubscriptionService (https://docs.abp.io/en/abp/latest/UI/Angular/Subscription-Service) instead.
 */
const takeUntilDestroy = (componentInstance, destroyMethodName = 'ngOnDestroy') => (source) => {
    const originalDestroy = componentInstance[destroyMethodName];
    if (isFunction(originalDestroy) === false) {
        throw new Error(`${componentInstance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    if (!componentInstance['__takeUntilDestroy']) {
        componentInstance['__takeUntilDestroy'] = new Subject();
        componentInstance[destroyMethodName] = function () {
            // tslint:disable-next-line: no-unused-expression
            isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
            componentInstance['__takeUntilDestroy'].next(true);
            componentInstance['__takeUntilDestroy'].complete();
        };
    }
    return source.pipe(takeUntil(componentInstance['__takeUntilDestroy']));
};

class DomInsertionService {
    constructor() {
        this.inserted = new Set();
    }
    insertContent(contentStrategy) {
        const hash = generateHash(contentStrategy.content);
        if (this.inserted.has(hash))
            return;
        const element = contentStrategy.insertElement();
        this.inserted.add(hash);
        return element;
    }
    removeContent(element) {
        const hash = generateHash(element.textContent);
        this.inserted.delete(hash);
        element.parentNode.removeChild(element);
    }
    has(content) {
        const hash = generateHash(content);
        return this.inserted.has(hash);
    }
}
DomInsertionService.ɵfac = function DomInsertionService_Factory(t) { return new (t || DomInsertionService)(); };
DomInsertionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DomInsertionService_Factory() { return new DomInsertionService(); }, token: DomInsertionService, providedIn: "root" });

class ResourceWaitService {
    constructor() {
        this.store = new InternalStore({ resources: new Set() });
    }
    getLoading() {
        return !!this.store.state.resources.size;
    }
    getLoading$() {
        return this.store.sliceState(({ resources }) => !!resources.size);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ resources }) => !!resources.size);
    }
    clearLoading() {
        this.store.patch({ resources: new Set() });
    }
    addResource(resource) {
        const resources = this.store.state.resources;
        resources.add(resource);
        this.store.patch({ resources });
    }
    deleteResource(resource) {
        const resources = this.store.state.resources;
        resources.delete(resource);
        this.store.patch({ resources });
    }
}
ResourceWaitService.ɵfac = function ResourceWaitService_Factory(t) { return new (t || ResourceWaitService)(); };
ResourceWaitService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ResourceWaitService_Factory() { return new ResourceWaitService(); }, token: ResourceWaitService, providedIn: "root" });

class LazyLoadService {
    constructor(resourceWaitService) {
        this.resourceWaitService = resourceWaitService;
        this.loaded = new Map();
    }
    load(strategy, retryTimes, retryDelay) {
        if (this.loaded.has(strategy.path))
            return of(new CustomEvent('load'));
        this.resourceWaitService.addResource(strategy.path);
        return strategy.createStream().pipe(retryWhen(error$ => concat(error$.pipe(delay(retryDelay), take(retryTimes)), throwError(new CustomEvent('error')))), tap(() => {
            this.loaded.set(strategy.path, strategy.element);
            this.resourceWaitService.deleteResource(strategy.path);
        }), delay(100), shareReplay({ bufferSize: 1, refCount: true }));
    }
    remove(path) {
        const element = this.loaded.get(path);
        if (!element)
            return false;
        element.parentNode.removeChild(element);
        this.loaded.delete(path);
        return true;
    }
}
LazyLoadService.ɵfac = function LazyLoadService_Factory(t) { return new (t || LazyLoadService)(ɵngcc0.ɵɵinject(ResourceWaitService)); };
LazyLoadService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyLoadService_Factory() { return new LazyLoadService(i0.ɵɵinject(ResourceWaitService)); }, token: LazyLoadService, providedIn: "root" });
LazyLoadService.ctorParameters = () => [
    { type: ResourceWaitService }
];

const LIST_QUERY_DEBOUNCE_TIME = new InjectionToken('LIST_QUERY_DEBOUNCE_TIME');

class ListService {
    constructor(injector) {
        this._filter = '';
        this._maxResultCount = 10;
        this._skipCount = 0;
        this._page = 0;
        this._sortKey = '';
        this._sortOrder = '';
        this._query$ = new ReplaySubject(1);
        this._isLoading$ = new BehaviorSubject(false);
        this.destroy$ = new Subject();
        this.get = () => {
            this.resetPageWhenUnchanged();
            this.next();
        };
        this.getWithoutPageReset = () => {
            this.next();
        };
        const delay = injector.get(LIST_QUERY_DEBOUNCE_TIME, 300);
        this.delay = delay ? debounceTime(delay) : tap();
        this.get();
    }
    set filter(value) {
        this._filter = value;
        this.get();
    }
    get filter() {
        return this._filter;
    }
    set maxResultCount(value) {
        this._maxResultCount = value;
        this.get();
    }
    get maxResultCount() {
        return this._maxResultCount;
    }
    set page(value) {
        if (value === this._page)
            return;
        this._page = value;
        this.get();
    }
    get page() {
        return this._page;
    }
    set sortKey(value) {
        this._sortKey = value;
        this.get();
    }
    get sortKey() {
        return this._sortKey;
    }
    set sortOrder(value) {
        this._sortOrder = value;
        this.get();
    }
    get sortOrder() {
        return this._sortOrder;
    }
    get query$() {
        return this._query$
            .asObservable()
            .pipe(this.delay, shareReplay({ bufferSize: 1, refCount: true }));
    }
    get isLoading$() {
        return this._isLoading$.asObservable();
    }
    hookToQuery(streamCreatorCallback) {
        this._isLoading$.next(true);
        return this.query$.pipe(switchMap(query => streamCreatorCallback(query).pipe(catchError(() => of(null)))), filter(Boolean), tap(() => this._isLoading$.next(false)), shareReplay({ bufferSize: 1, refCount: true }), takeUntil(this.destroy$));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    resetPageWhenUnchanged() {
        const skipCount = this._page * this._maxResultCount;
        if (skipCount === this._skipCount) {
            this._page = 0;
            this._skipCount = 0;
        }
        else
            this._skipCount = skipCount;
    }
    next() {
        this._query$.next({
            filter: this._filter || undefined,
            maxResultCount: this._maxResultCount,
            skipCount: this._page * this._maxResultCount,
            sorting: this._sortOrder ? `${this._sortKey} ${this._sortOrder}` : undefined,
        });
    }
}
ListService.ɵfac = function ListService_Factory(t) { return new (t || ListService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
ListService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ListService, factory: ListService.ɵfac });
ListService.ctorParameters = () => [
    { type: Injector }
];

var ConfigState_1;
/**
 * @deprecated Use ConfigStateService instead. To be deleted in v5.0.
 */
let ConfigState = ConfigState_1 = class ConfigState {
    constructor(http, store, sessionState, environmentService, configState) {
        this.http = http;
        this.store = store;
        this.sessionState = sessionState;
        this.environmentService = environmentService;
        this.configState = configState;
        this.syncConfigState();
        this.syncEnvironment();
    }
    static getAll(state) {
        return state;
    }
    static getApplicationInfo(state) {
        return state.environment.application || {};
    }
    static getEnvironment(state) {
        return state.environment;
    }
    static getOne(key) {
        const selector = createSelector([ConfigState_1], (state) => {
            return state[key];
        });
        return selector;
    }
    static getDeep(keys) {
        if (typeof keys === 'string') {
            keys = keys.split('.');
        }
        if (!Array.isArray(keys)) {
            throw new Error('The argument must be a dot string or an string array.');
        }
        const selector = createSelector([ConfigState_1], (state) => {
            return keys.reduce((acc, val) => {
                if (acc) {
                    return acc[val];
                }
                return undefined;
            }, state);
        });
        return selector;
    }
    static getApiUrl(key) {
        const selector = createSelector([ConfigState_1], (state) => {
            return (state.environment.apis[key || 'default'] || state.environment.apis.default).url;
        });
        return selector;
    }
    static getFeature(key) {
        const selector = createSelector([ConfigState_1], (state) => {
            return snq(() => state.features.values[key]);
        });
        return selector;
    }
    static getSetting(key) {
        const selector = createSelector([ConfigState_1], (state) => {
            return snq(() => state.setting.values[key]);
        });
        return selector;
    }
    static getSettings(keyword) {
        const selector = createSelector([ConfigState_1], (state) => {
            const settings = snq(() => state.setting.values, {});
            if (!keyword)
                return settings;
            const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
            return keysFound.reduce((acc, key) => {
                acc[key] = settings[key];
                return acc;
            }, {});
        });
        return selector;
    }
    /**
     * @deprecated use PermissionService's getGrantedPolicyStream or getGrantedPolicy methods.
     */
    static getGrantedPolicy(key) {
        const selector = createSelector([ConfigState_1], (state) => {
            if (!key)
                return true;
            const getPolicy = (k) => snq(() => state.auth.grantedPolicies[k], false);
            const orRegexp = /\|\|/g;
            const andRegexp = /&&/g;
            // TODO: Allow combination of ANDs & ORs
            if (orRegexp.test(key)) {
                const keys = key.split('||').filter(Boolean);
                if (keys.length < 2)
                    return false;
                return keys.some(k => getPolicy(k.trim()));
            }
            else if (andRegexp.test(key)) {
                const keys = key.split('&&').filter(Boolean);
                if (keys.length < 2)
                    return false;
                return keys.every(k => getPolicy(k.trim()));
            }
            return getPolicy(key);
        });
        return selector;
    }
    static getLocalizationResource(resourceName) {
        const selector = createSelector([ConfigState_1], (state) => {
            return state.localization.values[resourceName];
        });
        return selector;
    }
    static getLocalization(key, ...interpolateParams) {
        if (!key)
            key = '';
        let defaultValue;
        if (typeof key !== 'string') {
            defaultValue = key.defaultValue;
            key = key.key;
        }
        const keys = key.split('::');
        const selector = createSelector([ConfigState_1], (state) => {
            const warn = (message) => {
                if (!state.environment.production)
                    console.warn(message);
            };
            if (keys.length < 2) {
                warn('The localization source separator (::) not found.');
                return defaultValue || key;
            }
            if (!state.localization)
                return defaultValue || keys[1];
            const sourceName = keys[0] ||
                snq(() => state.environment.localization.defaultResourceName) ||
                state.localization.defaultResourceName;
            const sourceKey = keys[1];
            if (sourceName === '_') {
                return defaultValue || sourceKey;
            }
            if (!sourceName) {
                warn('Localization source name is not specified and the defaultResourceName was not defined!');
                return defaultValue || sourceKey;
            }
            const source = state.localization.values[sourceName];
            if (!source) {
                warn('Could not find localization source: ' + sourceName);
                return defaultValue || sourceKey;
            }
            let localization = source[sourceKey];
            if (typeof localization === 'undefined') {
                return defaultValue || sourceKey;
            }
            interpolateParams = interpolateParams.filter(params => params != null);
            if (localization)
                localization = interpolate(localization, interpolateParams);
            if (typeof localization !== 'string')
                localization = '';
            return localization || defaultValue || key;
        });
        return selector;
    }
    syncConfigState() {
        this.configState
            .createOnUpdateStream(state => state)
            .pipe(distinctUntilChanged(compare))
            .subscribe(config => this.store.dispatch(new PatchConfigState(config)));
    }
    syncEnvironment() {
        this.environmentService
            .createOnUpdateStream(state => state)
            .pipe(distinctUntilChanged(compare))
            .subscribe(env => this.store.dispatch(new PatchConfigState({ environment: env })));
    }
    addData({ patchState, dispatch }) {
        const apiName = 'default';
        const api = this.store.selectSnapshot(ConfigState_1.getApiUrl(apiName));
        return this.http
            .get(`${api}/api/abp/application-configuration`)
            .pipe(tap(configuration => this.configState.setState(configuration)), catchError((err) => {
            dispatch(new RestOccurError(err));
            return throwError(err);
        }));
    }
    setEnvironment(_, { environment }) {
        return this.environmentService.setState(environment);
    }
    setConfig({ patchState, getState }, { state }) {
        patchState(Object.assign(Object.assign({}, getState()), state));
    }
};
ConfigState.ɵfac = function ConfigState_Factory(t) { return new (t || ConfigState)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(SessionStateService), ɵngcc0.ɵɵinject(EnvironmentService), ɵngcc0.ɵɵinject(ConfigStateService)); };
ConfigState.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ConfigState, factory: function (t) { return ConfigState.ɵfac(t); } });
ConfigState.ctorParameters = () => [
    { type: HttpClient },
    { type: Store },
    { type: SessionStateService },
    { type: EnvironmentService },
    { type: ConfigStateService }
];
__decorate([
    Action(GetAppConfiguration)
], ConfigState.prototype, "addData", null);
__decorate([
    Action(SetEnvironment)
], ConfigState.prototype, "setEnvironment", null);
__decorate([
    Action(PatchConfigState)
], ConfigState.prototype, "setConfig", null);
__decorate([
    Selector()
], ConfigState, "getAll", null);
__decorate([
    Selector()
], ConfigState, "getApplicationInfo", null);
__decorate([
    Selector()
], ConfigState, "getEnvironment", null);
ConfigState = ConfigState_1 = __decorate([
    State({
        name: 'ConfigState',
        defaults: {},
    })
], ConfigState);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNgModelComponent, [{
        type: Component,
        args: [{ template: '' }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, { valueFn: [{
            type: Input
        }], valueLimitFn: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EnvironmentService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RestService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [CORE_OPTIONS]
            }] }, { type: ɵngcc1.HttpClient }, { type: EnvironmentService }, { type: ɵngcc2.Store }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbpApplicationConfigurationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RestService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfigStateService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AbpApplicationConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SessionStateService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ConfigStateService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizationService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: SessionStateService }, { type: ɵngcc0.Injector }, { type: LocalizationService, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }, { type: ConfigStateService }, { type: AbpApplicationConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ReplaceableComponentsService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc3.Router }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterEvents, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc3.Router }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PermissionService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ConfigStateService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavTreeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RoutesService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SettingTabsService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SubscriptionService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DynamicLayoutComponent, [{
        type: Component,
        args: [{
                selector: 'abp-dynamic-layout',
                template: `
    <ng-container *ngTemplateOutlet="layout ? componentOutlet : routerOutlet"></ng-container>
    <ng-template #routerOutlet><router-outlet></router-outlet></ng-template>
    <ng-template #componentOutlet
      ><ng-container *ngIf="isLayoutVisible" [ngComponentOutlet]="layout"></ng-container
    ></ng-template>
  `,
                providers: [SubscriptionService]
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: LocalizationService }, { type: ReplaceableComponentsService }, { type: SubscriptionService }, { type: RouterEvents }, { type: DynamicLayoutComponent, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ReplaceableRouteContainerComponent, [{
        type: Component,
        args: [{
                selector: 'abp-replaceable-route-container',
                template: `
    <ng-container *ngComponentOutlet="externalComponent || defaultComponent"></ng-container>
  `,
                providers: [SubscriptionService]
            }]
    }], function () { return [{ type: ɵngcc3.ActivatedRoute }, { type: ReplaceableComponentsService }, { type: SubscriptionService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterOutletComponent, [{
        type: Component,
        args: [{
                selector: 'abp-router-outlet',
                template: `
    <router-outlet></router-outlet>
  `
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AutofocusDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: '[autofocus]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { delay: [{
            type: Input,
            args: ['autofocus']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputEventDebounceDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: '[input.debounce]',
                providers: [SubscriptionService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SubscriptionService }]; }, { debounce: [{
            type: Input
        }], debounceEvent: [{
            type: Output,
            args: ['input.debounce']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ForDirective, [{
        type: Directive,
        args: [{
                selector: '[abpFor]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.IterableDiffers }]; }, { items: [{
            type: Input,
            args: ['abpForOf']
        }], orderBy: [{
            type: Input,
            args: ['abpForOrderBy']
        }], orderDir: [{
            type: Input,
            args: ['abpForOrderDir']
        }], filterBy: [{
            type: Input,
            args: ['abpForFilterBy']
        }], filterVal: [{
            type: Input,
            args: ['abpForFilterVal']
        }], trackBy: [{
            type: Input,
            args: ['abpForTrackBy']
        }], compareBy: [{
            type: Input,
            args: ['abpForCompareBy']
        }], emptyRef: [{
            type: Input,
            args: ['abpForEmptyRef']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormSubmitDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: 'form[ngSubmit][formGroup]',
                providers: [SubscriptionService]
            }]
    }], function () { return [{ type: ɵngcc5.FormGroupDirective, decorators: [{
                type: Self
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: SubscriptionService }]; }, { debounce: [{
            type: Input
        }], ngSubmit: [{
            type: Output
        }], notValidateOnSubmit: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InitDirective, [{
        type: Directive,
        args: [{ selector: '[abpInit]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { init: [{
            type: Output,
            args: ['abpInit']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PermissionDirective, [{
        type: Directive,
        args: [{
                selector: '[abpPermission]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }, { type: PermissionService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { condition: [{
            type: Input,
            args: ['abpPermission']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ReplaceableTemplateDirective, [{
        type: Directive,
        args: [{ selector: '[abpReplaceableTemplate]', providers: [SubscriptionService] }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }, { type: ReplaceableComponentsService }, { type: SubscriptionService }]; }, { data: [{
            type: Input,
            args: ['abpReplaceableTemplate']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StopPropagationDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: '[click.stop]',
                providers: [SubscriptionService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SubscriptionService }]; }, { stopPropEvent: [{
            type: Output,
            args: ['click.stop']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VisibilityDirective, [{
        type: Directive,
        args: [{
                selector: '[abpVisibility]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }]; }, { focusedElement: [{
            type: Input,
            args: ['abpVisibility']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OAuthConfigurationHandler, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc6.OAuthService }, { type: EnvironmentService }, { type: undefined, decorators: [{
                type: Inject,
                args: [CORE_OPTIONS]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RoutesHandler, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RoutesService }, { type: ɵngcc3.Router, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HttpWaitService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ApiInterceptor, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc6.OAuthService }, { type: SessionStateService }, { type: HttpWaitService }, { type: String, decorators: [{
                type: Inject,
                args: [TENANT_KEY]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizationPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{
                name: 'abpLocalization'
            }]
    }], function () { return [{ type: LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizationModule, [{
        type: NgModule,
        args: [{
                exports: [LocalizationPipe],
                declarations: [LocalizationPipe]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LocalizationModule, { declarations: [LocalizationPipe], exports: [LocalizationPipe] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SortPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{
                name: 'abpSort'
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProfileService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RestService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProfileState, [{
        type: Injectable
    }], function () { return [{ type: ProfileService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbpTenantService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RestService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MultiTenancyService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: RestService }, { type: SessionStateService }, { type: AbpTenantService }, { type: ConfigStateService }, { type: String, decorators: [{
                type: Inject,
                args: [TENANT_KEY]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseCoreModule, [{
        type: NgModule,
        args: [{
                exports: [
                    CommonModule,
                    HttpClientModule,
                    FormsModule,
                    ReactiveFormsModule,
                    RouterModule,
                    LocalizationModule,
                    AbstractNgModelComponent,
                    AutofocusDirective,
                    DynamicLayoutComponent,
                    ForDirective,
                    FormSubmitDirective,
                    InitDirective,
                    InputEventDebounceDirective,
                    PermissionDirective,
                    ReplaceableRouteContainerComponent,
                    ReplaceableTemplateDirective,
                    RouterOutletComponent,
                    SortPipe,
                    StopPropagationDirective,
                    VisibilityDirective,
                ],
                imports: [
                    OAuthModule,
                    CommonModule,
                    HttpClientModule,
                    FormsModule,
                    ReactiveFormsModule,
                    RouterModule,
                    LocalizationModule,
                ],
                declarations: [
                    AbstractNgModelComponent,
                    AutofocusDirective,
                    DynamicLayoutComponent,
                    ForDirective,
                    FormSubmitDirective,
                    InitDirective,
                    InputEventDebounceDirective,
                    PermissionDirective,
                    ReplaceableRouteContainerComponent,
                    ReplaceableTemplateDirective,
                    RouterOutletComponent,
                    SortPipe,
                    StopPropagationDirective,
                    VisibilityDirective,
                ],
                providers: [LocalizationPipe],
                entryComponents: [
                    RouterOutletComponent,
                    DynamicLayoutComponent,
                    ReplaceableRouteContainerComponent,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BaseCoreModule, { declarations: function () { return [AbstractNgModelComponent, AutofocusDirective, DynamicLayoutComponent, ForDirective, FormSubmitDirective, InitDirective, InputEventDebounceDirective, PermissionDirective, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, RouterOutletComponent, SortPipe, StopPropagationDirective, VisibilityDirective]; }, imports: function () { return [OAuthModule,
        CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule, LocalizationModule]; }, exports: function () { return [CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule, LocalizationModule, AbstractNgModelComponent, AutofocusDirective, DynamicLayoutComponent, ForDirective, FormSubmitDirective, InitDirective, InputEventDebounceDirective, PermissionDirective, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, RouterOutletComponent, SortPipe, StopPropagationDirective, VisibilityDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RootCoreModule, [{
        type: NgModule,
        args: [{
                exports: [BaseCoreModule, LocalizationModule],
                imports: [
                    BaseCoreModule,
                    LocalizationModule,
                    NgxsModule.forFeature([ProfileState]),
                    OAuthModule.forRoot(),
                    HttpClientXsrfModule.withOptions({
                        cookieName: 'XSRF-TOKEN',
                        headerName: 'RequestVerificationToken'
                    }),
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RootCoreModule, { imports: [BaseCoreModule, LocalizationModule, ɵngcc2.ɵbc, ɵngcc6.OAuthModule, ɵngcc1.HttpClientXsrfModule], exports: [BaseCoreModule, LocalizationModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CoreModule, [{
        type: NgModule,
        args: [{
                exports: [BaseCoreModule],
                imports: [BaseCoreModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CoreModule, { imports: [BaseCoreModule], exports: [BaseCoreModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc6.OAuthService }, { type: AuthService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PermissionGuard, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc3.Router }, { type: RoutesService }, { type: ɵngcc2.Store }, { type: PermissionService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ApplicationConfigurationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RestService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContentProjectionService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DomInsertionService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResourceWaitService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LazyLoadService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ResourceWaitService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfigState, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: ɵngcc2.Store }, { type: SessionStateService }, { type: EnvironmentService }, { type: ConfigStateService }]; }, null); })();

class ProfileStateService {
    constructor(store) {
        this.store = store;
    }
    getProfile() {
        return this.store.selectSnapshot(ProfileState.getProfile);
    }
    dispatchGetProfile() {
        return this.store.dispatch(new GetProfile());
    }
    dispatchUpdateProfile(...args) {
        return this.store.dispatch(new UpdateProfile(...args));
    }
    dispatchChangePassword(...args) {
        return this.store.dispatch(new ChangePassword(...args));
    }
}
ProfileStateService.ɵfac = function ProfileStateService_Factory(t) { return new (t || ProfileStateService)(ɵngcc0.ɵɵinject(ɵngcc2.Store)); };
ProfileStateService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProfileStateService_Factory() { return new ProfileStateService(i0.ɵɵinject(i4.Store)); }, token: ProfileStateService, providedIn: "root" });
ProfileStateService.ctorParameters = () => [
    { type: Store }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProfileStateService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc2.Store }]; }, null); })();

class RouterWaitService {
    constructor(routerEvents, injector) {
        this.routerEvents = routerEvents;
        this.store = new InternalStore({ loading: false });
        this.destroy$ = new Subject();
        this.delay = injector.get(LOADER_DELAY, 500);
        this.updateLoadingStatusOnNavigationEvents();
    }
    updateLoadingStatusOnNavigationEvents() {
        this.routerEvents
            .getAllNavigationEvents()
            .pipe(map(event => event instanceof NavigationStart), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay || 0).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()))
            .subscribe(status => {
            this.setLoading(status);
        });
    }
    getLoading() {
        return this.store.state.loading;
    }
    getLoading$() {
        return this.store.sliceState(({ loading }) => loading);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ loading }) => loading);
    }
    setLoading(loading) {
        this.store.patch({ loading });
    }
}
RouterWaitService.ɵfac = function RouterWaitService_Factory(t) { return new (t || RouterWaitService)(ɵngcc0.ɵɵinject(RouterEvents), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
RouterWaitService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RouterWaitService_Factory() { return new RouterWaitService(i0.ɵɵinject(RouterEvents), i0.ɵɵinject(i0.INJECTOR)); }, token: RouterWaitService, providedIn: "root" });
RouterWaitService.ctorParameters = () => [
    { type: RouterEvents },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterWaitService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RouterEvents }, { type: ɵngcc0.Injector }]; }, null); })();

const trackBy = (key) => (_, item) => item[key];
const trackByDeep = (...keys) => (_, item) => keys.reduce((acc, key) => acc[key], item);
class TrackByService {
    constructor() {
        this.by = trackBy;
        this.byDeep = trackByDeep;
    }
}
TrackByService.ɵfac = function TrackByService_Factory(t) { return new (t || TrackByService)(); };
TrackByService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TrackByService_Factory() { return new TrackByService(); }, token: TrackByService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TrackByService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class ContainerStrategy {
    constructor(containerRef) {
        this.containerRef = containerRef;
    }
    prepare() { }
}
class ClearContainerStrategy extends ContainerStrategy {
    getIndex() {
        return 0;
    }
    prepare() {
        this.containerRef.clear();
    }
}
class InsertIntoContainerStrategy extends ContainerStrategy {
    constructor(containerRef, index) {
        super(containerRef);
        this.index = index;
    }
    getIndex() {
        return Math.min(Math.max(0, this.index), this.containerRef.length);
    }
}
const CONTAINER_STRATEGY = {
    Clear(containerRef) {
        return new ClearContainerStrategy(containerRef);
    },
    Append(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, containerRef.length);
    },
    Prepend(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, 0);
    },
    Insert(containerRef, index) {
        return new InsertIntoContainerStrategy(containerRef, index);
    },
};

class ContentSecurityStrategy {
    constructor(nonce) {
        this.nonce = nonce;
    }
}
class LooseContentSecurityStrategy extends ContentSecurityStrategy {
    constructor(nonce) {
        super(nonce);
    }
    applyCSP(element) {
        element.setAttribute('nonce', this.nonce);
    }
}
class NoContentSecurityStrategy extends ContentSecurityStrategy {
    constructor() {
        super();
    }
    applyCSP(_) { }
}
const CONTENT_SECURITY_STRATEGY = {
    Loose(nonce) {
        return new LooseContentSecurityStrategy(nonce);
    },
    None() {
        return new NoContentSecurityStrategy();
    },
};

class ContentStrategy {
    constructor(content, domStrategy = DOM_STRATEGY.AppendToHead(), contentSecurityStrategy = CONTENT_SECURITY_STRATEGY.None()) {
        this.content = content;
        this.domStrategy = domStrategy;
        this.contentSecurityStrategy = contentSecurityStrategy;
    }
    insertElement() {
        const element = this.createElement();
        this.contentSecurityStrategy.applyCSP(element);
        this.domStrategy.insertElement(element);
        return element;
    }
}
class StyleContentStrategy extends ContentStrategy {
    createElement() {
        const element = document.createElement('style');
        element.textContent = this.content;
        return element;
    }
}
class ScriptContentStrategy extends ContentStrategy {
    createElement() {
        const element = document.createElement('script');
        element.textContent = this.content;
        return element;
    }
}
const CONTENT_STRATEGY = {
    AppendScriptToBody(content) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToBody());
    },
    AppendScriptToHead(content) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToHead());
    },
    AppendStyleToHead(content) {
        return new StyleContentStrategy(content, DOM_STRATEGY.AppendToHead());
    },
    PrependStyleToHead(content) {
        return new StyleContentStrategy(content, DOM_STRATEGY.PrependToHead());
    },
};

class ContextStrategy {
    constructor(context) {
        this.context = context;
    }
    /* tslint:disable-next-line:no-unused-variable */
    setContext(componentRef) {
        return this.context;
    }
}
class NoContextStrategy extends ContextStrategy {
    constructor() {
        super(undefined);
    }
}
class ComponentContextStrategy extends ContextStrategy {
    setContext(componentRef) {
        Object.keys(this.context).forEach(key => (componentRef.instance[key] = this.context[key]));
        componentRef.changeDetectorRef.detectChanges();
        return this.context;
    }
}
class TemplateContextStrategy extends ContextStrategy {
    setContext() {
        return this.context;
    }
}
const CONTEXT_STRATEGY = {
    None() {
        return new NoContextStrategy();
    },
    Component(context) {
        return new ComponentContextStrategy(context);
    },
    Template(context) {
        return new TemplateContextStrategy(context);
    },
};

class LoadingStrategy {
    constructor(path, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
        this.path = path;
        this.domStrategy = domStrategy;
        this.crossOriginStrategy = crossOriginStrategy;
    }
    createStream() {
        this.element = this.createElement();
        return of(null).pipe(switchMap(() => fromLazyLoad(this.element, this.domStrategy, this.crossOriginStrategy)));
    }
}
class ScriptLoadingStrategy extends LoadingStrategy {
    constructor(src, domStrategy, crossOriginStrategy) {
        super(src, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('script');
        element.src = this.path;
        return element;
    }
}
class StyleLoadingStrategy extends LoadingStrategy {
    constructor(href, domStrategy, crossOriginStrategy) {
        super(href, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('link');
        element.rel = 'stylesheet';
        element.href = this.path;
        return element;
    }
}
const LOADING_STRATEGY = {
    AppendScriptToBody(src) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.None());
    },
    AppendAnonymousScriptToBody(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
};

class ProjectionStrategy {
    constructor(content) {
        this.content = content;
    }
}
class ComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(component);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent(injector) {
        this.containerStrategy.prepare();
        const resolver = injector.get(ComponentFactoryResolver);
        const factory = resolver.resolveComponentFactory(this.content);
        const componentRef = this.containerStrategy.containerRef.createComponent(factory, this.containerStrategy.getIndex(), injector);
        this.contextStrategy.setContext(componentRef);
        return componentRef;
    }
}
class RootComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, contextStrategy = CONTEXT_STRATEGY.None(), domStrategy = DOM_STRATEGY.AppendToBody()) {
        super(component);
        this.contextStrategy = contextStrategy;
        this.domStrategy = domStrategy;
    }
    injectContent(injector) {
        const appRef = injector.get(ApplicationRef);
        const resolver = injector.get(ComponentFactoryResolver);
        const componentRef = resolver
            .resolveComponentFactory(this.content)
            .create(injector);
        this.contextStrategy.setContext(componentRef);
        appRef.attachView(componentRef.hostView);
        const element = componentRef.hostView.rootNodes[0];
        this.domStrategy.insertElement(element);
        return componentRef;
    }
}
class TemplateProjectionStrategy extends ProjectionStrategy {
    constructor(templateRef, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(templateRef);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent() {
        this.containerStrategy.prepare();
        const embeddedViewRef = this.containerStrategy.containerRef.createEmbeddedView(this.content, this.contextStrategy.context, this.containerStrategy.getIndex());
        embeddedViewRef.detectChanges();
        return embeddedViewRef;
    }
}
const PROJECTION_STRATEGY = {
    AppendComponentToBody(component, context) {
        return new RootComponentProjectionStrategy(component, context && CONTEXT_STRATEGY.Component(context));
    },
    AppendComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    AppendTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    PrependComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    PrependTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    ProjectComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    ProjectTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
};

const NAVIGATE_TO_MANAGE_PROFILE = new InjectionToken('NAVIGATE_TO_MANAGE_PROFILE', {
    providedIn: 'root',
    factory: () => {
        const environment = inject(EnvironmentService);
        return () => {
            window.open(`${environment.getEnvironment().oAuthConfig.issuer}/Account/Manage?returnUrl=${window.location.href}`, '_self');
        };
    },
});

function validateMinAge({ age = 18 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidMinAge(control.value, age) ? null : { minAge: { age } };
    };
}
function isValidMinAge(value, minAge) {
    const date = new Date();
    date.setFullYear(date.getFullYear() - minAge);
    date.setHours(23, 59, 59, 999);
    return Number(new Date(value)) <= date.valueOf();
}

function validateCreditCard() {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidCreditCard(String(control.value)) ? null : { creditCard: true };
    };
}
function isValidCreditCard(value) {
    value = value.replace(/[ -]/g, '');
    if (!/^[0-9]{13,19}$/.test(value))
        return false;
    let checksum = 0;
    let multiplier = 1;
    for (let i = value.length; i > 0; i--) {
        const digit = Number(value[i - 1]) * multiplier;
        /* tslint:disable-next-line:no-bitwise */
        checksum += (digit % 10) + ~~(digit / 10);
        multiplier = (multiplier * 2) % 3;
    }
    return checksum % 10 === 0;
}

function validateRange({ maximum = Infinity, minimum = 0 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = Number(control.value);
        return getMinError(value, minimum, maximum) || getMaxError(value, maximum, minimum);
    };
}
function getMaxError(value, max, min) {
    return value > max ? { range: { max, min } } : null;
}
function getMinError(value, min, max) {
    return value < min ? { range: { min, max } } : null;
}

function validateRequired({ allowEmptyStrings } = {}) {
    return (control) => {
        return isValidRequired(control.value, allowEmptyStrings) ? null : { required: true };
    };
}
function isValidRequired(value, allowEmptyStrings) {
    if (value || value === 0 || value === false)
        return true;
    if (allowEmptyStrings && value === '')
        return true;
    return false;
}

function validateStringLength({ maximumLength = Infinity, minimumLength = 0, } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = String(control.value);
        return getMinLengthError(value, minimumLength) || getMaxLengthError(value, maximumLength);
    };
}
function getMaxLengthError(value, requiredLength) {
    return value.length > requiredLength ? { maxlength: { requiredLength } } : null;
}
function getMinLengthError(value, requiredLength) {
    return value.length < requiredLength ? { minlength: { requiredLength } } : null;
}

function validateUrl() {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidUrl(control.value) ? null : { url: true };
    };
}
function isValidUrl(value) {
    if (/^http(s)?:\/\/[^/]/.test(value) || /^ftp:\/\/[^/]/.test(value)) {
        const a = document.createElement('a');
        a.href = value;
        return !!a.host;
    }
    return false;
}

const ɵ0 = () => Validators.email;
const AbpValidators = {
    creditCard: validateCreditCard,
    emailAddress: ɵ0,
    minAge: validateMinAge,
    range: validateRange,
    required: validateRequired,
    stringLength: validateStringLength,
    url: validateUrl,
};

class AbpApiDefinitionService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
        this.getByModel = (model) => this.restService.request({
            method: 'GET',
            url: '/api/abp/api-definition',
            params: { includeTypes: model.includeTypes },
        }, { apiName: this.apiName });
    }
}
AbpApiDefinitionService.ɵfac = function AbpApiDefinitionService_Factory(t) { return new (t || AbpApiDefinitionService)(ɵngcc0.ɵɵinject(RestService)); };
AbpApiDefinitionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbpApiDefinitionService_Factory() { return new AbpApiDefinitionService(i0.ɵɵinject(RestService)); }, token: AbpApiDefinitionService, providedIn: "root" });
AbpApiDefinitionService.ctorParameters = () => [
    { type: RestService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbpApiDefinitionService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RestService }]; }, null); })();

var index = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/*
 * Public API Surface of core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APP_INIT_ERROR_HANDLERS, AbpApiDefinitionService, AbpApplicationConfigurationService, AbpTenantService, AbpValidators, AbstractNavTreeService, AbstractNgModelComponent, AbstractTreeService, ApiInterceptor, ApplicationConfigurationService, AuditedEntityDto, AuditedEntityWithUserDto, AuthGuard, AuthService, AutofocusDirective, BaseCoreModule, BaseTreeNode, CONTAINER_STRATEGY, CONTENT_SECURITY_STRATEGY, CONTENT_STRATEGY, CONTEXT_STRATEGY, CORE_OPTIONS, CROSS_ORIGIN_STRATEGY, ChangePassword, ClearContainerStrategy, ComponentContextStrategy, ComponentProjectionStrategy, ConfigState, ConfigStateService, ContainerStrategy, ContentProjectionService, ContentSecurityStrategy, ContentStrategy, ContextStrategy, CoreModule, CreationAuditedEntityDto, CreationAuditedEntityWithUserDto, CrossOriginStrategy, DOM_STRATEGY, DomInsertionService, DomStrategy, DynamicLayoutComponent, EntityDto, EnvironmentService, ExtensibleAuditedEntityDto, ExtensibleAuditedEntityWithUserDto, ExtensibleCreationAuditedEntityDto, ExtensibleCreationAuditedEntityWithUserDto, ExtensibleEntityDto, ExtensibleFullAuditedEntityDto, ExtensibleFullAuditedEntityWithUserDto, ExtensibleObject, ForDirective, FormSubmitDirective, FullAuditedEntityDto, FullAuditedEntityWithUserDto, GetAppConfiguration, GetProfile, HttpWaitService, InitDirective, InputEventDebounceDirective, InsertIntoContainerStrategy, InternalStore, LIST_QUERY_DEBOUNCE_TIME, LOADER_DELAY, LOADING_STRATEGY, LazyLoadService, LazyModuleFactory, LimitedResultRequestDto, ListResultDto, ListService, LoadingStrategy, LocalizationModule, LocalizationPipe, LocalizationService, LooseContentSecurityStrategy, MultiTenancyService, NAVIGATE_TO_MANAGE_PROFILE, NavigationEvent, NoContentSecurityStrategy, NoContextStrategy, NoCrossOriginStrategy, index as ObjectExtending, PROJECTION_STRATEGY, PagedAndSortedResultRequestDto, PagedResultDto, PagedResultRequestDto, PermissionDirective, PermissionGuard, PermissionService, ProfileService, ProfileState, ProfileStateService, ProjectionStrategy, ReplaceableComponentsService, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, ResourceWaitService, RestOccurError, RestService, RootComponentProjectionStrategy, RootCoreModule, RouterEvents, RouterOutletComponent, RouterWaitService, RoutesService, ScriptContentStrategy, ScriptLoadingStrategy, SessionStateService, SetEnvironment, SettingTabsService, SortPipe, StartLoader, StopLoader, StopPropagationDirective, StyleContentStrategy, StyleLoadingStrategy, SubscriptionService, TENANT_KEY, TemplateContextStrategy, TemplateProjectionStrategy, TrackByService, UpdateProfile, VisibilityDirective, WebHttpUrlEncodingCodec, checkAccessToken, coreOptionsFactory, createLocalizationPipeKeyGenerator, createLocalizer, createLocalizerWithFallback, createMapFromList, createTokenParser, createTreeFromList, createTreeNodeFilterCreator, deepMerge, differentLocales, downloadBlob, exists, featuresFactory, findRoute, fromLazyLoad, generateHash, generatePassword, getInitialData, getLocaleDirection, getPathName, getRemoteEnv, getRoutePath, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, interpolate, isArray, isNode, isNullOrUndefined, isNumber, isObject, isObjectAndNotArray, isObjectAndNotArrayNotNode, isUndefinedOrEmptyString, localeInitializer, mapEnumToOptions, ngxsStoragePluginSerialize, noop, parseTenantFromUrl, pipeToLogin, pushValueTo, reloadRoute, removeRememberMe, setRememberMe, setTokenResponseToStorage, storageFactory, takeUntilDestroy, trackBy, trackByDeep, uuid, validateCreditCard, validateMinAge, validateRange, validateRequired, validateStringLength, validateUrl, oAuthStorage as ɵa, LocalizationPipe as ɵb, SortPipe as ɵba, StopPropagationDirective as ɵbb, VisibilityDirective as ɵbc, ProfileState as ɵbd, ProfileService as ɵbe, GetProfile as ɵbf, UpdateProfile as ɵbg, ChangePassword as ɵbh, LocaleId as ɵbj, LocaleProvider as ɵbk, ApiInterceptor as ɵbl, TENANT_KEY as ɵbm, HttpWaitService as ɵbn, OAuthConfigurationHandler as ɵbo, noop as ɵbp, getInitialData as ɵbq, localeInitializer as ɵbr, RoutesHandler as ɵbs, AbstractTreeService as ɵbt, AbstractNavTreeService as ɵbu, RoutesService as ɵbv, LocalizationService as ɵc, SessionStateService as ɵd, ConfigStateService as ɵe, AbpApplicationConfigurationService as ɵf, RestService as ɵg, CORE_OPTIONS as ɵh, coreOptionsFactory as ɵi, EnvironmentService as ɵk, AbstractNgModelComponent as ɵl, AutofocusDirective as ɵm, DynamicLayoutComponent as ɵn, SubscriptionService as ɵo, ReplaceableComponentsService as ɵp, RouterEvents as ɵq, ForDirective as ɵr, FormSubmitDirective as ɵs, InitDirective as ɵt, InputEventDebounceDirective as ɵu, PermissionDirective as ɵv, PermissionService as ɵw, ReplaceableRouteContainerComponent as ɵx, ReplaceableTemplateDirective as ɵy, RouterOutletComponent as ɵz };

//# sourceMappingURL=abp-ng.core.js.map