import { __rest } from "tslib";
import { Injectable, Optional } from '@angular/core';
import { Router } from '@angular/router';
import { RoutesService } from '../services/routes.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/routes.service";
import * as i2 from "@angular/router";
export class RoutesHandler {
    constructor(routes, router) {
        this.routes = routes;
        this.router = router;
        this.addRoutes();
    }
    addRoutes() {
        var _a, _b;
        (_b = (_a = this.router) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.forEach(({ path = '', data }) => {
            if (!(data === null || data === void 0 ? void 0 : data.routes))
                return;
            if (Array.isArray(data.routes)) {
                this.routes.add(data.routes);
                return;
            }
            const routes = flatRoutes([Object.assign({ path }, data.routes)], { path: '' });
            this.routes.add(routes);
        });
    }
}
RoutesHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoutesHandler_Factory() { return new RoutesHandler(i0.ɵɵinject(i1.RoutesService), i0.ɵɵinject(i2.Router, 8)); }, token: RoutesHandler, providedIn: "root" });
RoutesHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
RoutesHandler.ctorParameters = () => [
    { type: RoutesService },
    { type: Router, decorators: [{ type: Optional }] }
];
function flatRoutes(routes, parent) {
    if (!routes)
        return [];
    return routes.reduce((acc, route) => {
        const _a = Object.assign(Object.assign({}, route), { parentName: parent.name, path: (parent.path + '/' + route.path).replace(/\/\//g, '/') }), { children } = _a, current = __rest(_a, ["children"]);
        acc.push(current, ...flatRoutes(children, current));
        return acc;
    }, []);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVzLmhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9saWIvaGFuZGxlcnMvcm91dGVzLmhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUV6QyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7Ozs7QUFLM0QsTUFBTSxPQUFPLGFBQWE7SUFDeEIsWUFBb0IsTUFBcUIsRUFBc0IsTUFBYztRQUF6RCxXQUFNLEdBQU4sTUFBTSxDQUFlO1FBQXNCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDM0UsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRCxTQUFTOztRQUNQLFlBQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsTUFBTSwwQ0FBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtZQUNuRCxJQUFJLEVBQUMsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE1BQU0sQ0FBQTtnQkFBRSxPQUFPO1lBRTFCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDN0IsT0FBTzthQUNSO1lBRUQsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLGlCQUFHLElBQUksSUFBSyxJQUFJLENBQUMsTUFBTSxFQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNwRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUU7SUFDTCxDQUFDOzs7O1lBcEJGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBSlEsYUFBYTtZQUZiLE1BQU0sdUJBUStCLFFBQVE7O0FBbUJ0RCxTQUFTLFVBQVUsQ0FBQyxNQUFrQixFQUFFLE1BQVc7SUFDakQsSUFBSSxDQUFDLE1BQU07UUFBRSxPQUFPLEVBQUUsQ0FBQztJQUV2QixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDbEMsTUFBTSxxQ0FDRCxLQUFLLEtBQ1IsVUFBVSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQ3ZCLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxHQUM3RCxFQUpLLEVBQUUsUUFBUSxPQUlmLEVBSm9CLE9BQU8sY0FBdEIsWUFBd0IsQ0FJN0IsQ0FBQztRQUVGLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsVUFBVSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRXBELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQUJQIH0gZnJvbSAnLi4vbW9kZWxzJztcbmltcG9ydCB7IFJvdXRlc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9yb3V0ZXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBSb3V0ZXNIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXM6IFJvdXRlc1NlcnZpY2UsIEBPcHRpb25hbCgpIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICB0aGlzLmFkZFJvdXRlcygpO1xuICB9XG5cbiAgYWRkUm91dGVzKCkge1xuICAgIHRoaXMucm91dGVyPy5jb25maWc/LmZvckVhY2goKHsgcGF0aCA9ICcnLCBkYXRhIH0pID0+IHtcbiAgICAgIGlmICghZGF0YT8ucm91dGVzKSByZXR1cm47XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEucm91dGVzKSkge1xuICAgICAgICB0aGlzLnJvdXRlcy5hZGQoZGF0YS5yb3V0ZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlcyA9IGZsYXRSb3V0ZXMoW3sgcGF0aCwgLi4uZGF0YS5yb3V0ZXMgfV0sIHsgcGF0aDogJycgfSk7XG4gICAgICB0aGlzLnJvdXRlcy5hZGQocm91dGVzKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0Um91dGVzKHJvdXRlczogUm91dGVEZWZbXSwgcGFyZW50OiBhbnkpIHtcbiAgaWYgKCFyb3V0ZXMpIHJldHVybiBbXTtcblxuICByZXR1cm4gcm91dGVzLnJlZHVjZSgoYWNjLCByb3V0ZSkgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmN1cnJlbnQgfSA9IHtcbiAgICAgIC4uLnJvdXRlLFxuICAgICAgcGFyZW50TmFtZTogcGFyZW50Lm5hbWUsXG4gICAgICBwYXRoOiAocGFyZW50LnBhdGggKyAnLycgKyByb3V0ZS5wYXRoKS5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKSxcbiAgICB9O1xuXG4gICAgYWNjLnB1c2goY3VycmVudCwgLi4uZmxhdFJvdXRlcyhjaGlsZHJlbiwgY3VycmVudCkpO1xuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufVxuXG50eXBlIFJvdXRlRGVmID0gQUJQLlJvdXRlICYgeyBjaGlsZHJlbjogUm91dGVEZWZbXSB9O1xuIl19