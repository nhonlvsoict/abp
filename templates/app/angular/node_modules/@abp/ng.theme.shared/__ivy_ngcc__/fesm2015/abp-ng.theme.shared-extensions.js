import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Optional, SkipSelf, ChangeDetectorRef, Input, ViewChild, InjectionToken, Inject, ViewChildren, LOCALE_ID, Injector, Directive, Host, TemplateRef, ViewContainerRef, NgModule } from '@angular/core';
import { formatDate } from '@angular/common';
import { NgbDateAdapter, NgbTimeAdapter, NgbInputDatepicker, NgbTimepicker, NgbDatepickerModule, NgbDropdownModule, NgbTimepickerModule, NgbTypeaheadModule } from '@ng-bootstrap/ng-bootstrap';
import { ControlContainer, FormGroupDirective, Validators, NgControl, FormGroup, FormControl } from '@angular/forms';
import { RestService, TrackByService, ConfigStateService, AbpValidators, getShortDateShortTimeFormat, getShortTimeFormat, getShortDateFormat, CoreModule, LocalizationService, createLocalizationPipeKeyGenerator } from '@abp/ng.core';
import { of, merge, pipe, zip } from 'rxjs';
import { map, debounceTime, distinctUntilChanged, switchMap, filter, take } from 'rxjs/operators';
import snq from 'snq';
import { LinkedList } from '@abp/utils';
import { ThemeSharedModule } from '@abp/ng.theme.shared';
import { NgxValidateCoreModule } from '@ngx-validate/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ng-bootstrap/ng-bootstrap';
import * as ɵngcc2 from '@angular/forms';
import * as ɵngcc3 from '@ngx-validate/core';
import * as ɵngcc4 from '@abp/ng.core';
import * as ɵngcc5 from '@angular/common';
import * as ɵngcc6 from '@swimlane/ngx-datatable';
import * as ɵngcc7 from '@abp/ng.theme.shared';

const _c0 = ["field"];
function ExtensibleFormPropComponent_div_0_ng_template_1_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelement(1, "input", 14, 15);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r3.prop.id)("formControlName", ctx_r3.prop.name)("autocomplete", ctx_r3.prop.autocomplete)("type", ctx_r3.getType(ctx_r3.prop))("abpDisabled", ctx_r3.disabled)("readonly", ctx_r3.readonly);
} }
function ExtensibleFormPropComponent_div_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 16);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("formControlName", ctx_r4.prop.name);
} }
function ExtensibleFormPropComponent_div_0_ng_template_3_ng_template_3_Template(rf, ctx) { }
const _c1 = function () { return { $implicit: "custom-control-label" }; };
function ExtensibleFormPropComponent_div_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵelement(1, "input", 18, 15);
    ɵngcc0.ɵɵtemplate(3, ExtensibleFormPropComponent_div_0_ng_template_3_ng_template_3_Template, 0, 0, "ng-template", 19);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r5.prop.id)("formControlName", ctx_r5.prop.name)("abpDisabled", ctx_r5.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction0(5, _c1));
} }
function ExtensibleFormPropComponent_div_0_ng_template_4_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_4_option_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 22);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r20 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngValue", option_r20.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", option_r20.key, " ");
} }
function ExtensibleFormPropComponent_div_0_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_4_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelementStart(1, "select", 20, 15);
    ɵngcc0.ɵɵtemplate(3, ExtensibleFormPropComponent_div_0_ng_template_4_option_3_Template, 2, 2, "option", 21);
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r6.prop.id)("formControlName", ctx_r6.prop.name)("abpDisabled", ctx_r6.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(4, 6, ctx_r6.options$))("ngForTrackBy", ctx_r6.track.by("value"));
} }
function ExtensibleFormPropComponent_div_0_ng_template_5_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_5_option_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 22);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r24 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngValue", option_r24.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", option_r24.key, " ");
} }
function ExtensibleFormPropComponent_div_0_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_5_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelementStart(1, "select", 23, 15);
    ɵngcc0.ɵɵtemplate(3, ExtensibleFormPropComponent_div_0_ng_template_5_option_3_Template, 2, 2, "option", 21);
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r7.prop.id)("formControlName", ctx_r7.prop.name)("abpDisabled", ctx_r7.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(4, 6, ctx_r7.options$))("ngForTrackBy", ctx_r7.track.by("value"));
} }
function ExtensibleFormPropComponent_div_0_ng_template_6_ng_template_0_Template(rf, ctx) { }
const _c2 = function () { return { standalone: true }; };
function ExtensibleFormPropComponent_div_0_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r29 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_6_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelementStart(1, "div", 24, 25);
    ɵngcc0.ɵɵelementStart(3, "input", 26, 15);
    ɵngcc0.ɵɵlistener("ngModelChange", function ExtensibleFormPropComponent_div_0_ng_template_6_Template_input_ngModelChange_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r29); const ctx_r28 = ɵngcc0.ɵɵnextContext(2); return ctx_r28.typeaheadModel = $event; })("selectItem", function ExtensibleFormPropComponent_div_0_ng_template_6_Template_input_selectItem_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r29); const ctx_r30 = ɵngcc0.ɵɵnextContext(2); return ctx_r30.setTypeaheadValue($event.item); })("blur", function ExtensibleFormPropComponent_div_0_ng_template_6_Template_input_blur_3_listener() { ɵngcc0.ɵɵrestoreView(_r29); const ctx_r31 = ɵngcc0.ɵɵnextContext(2); return ctx_r31.setTypeaheadValue(ctx_r31.typeaheadModel); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(5, "input", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r26 = ɵngcc0.ɵɵreference(2);
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵclassProp("is-invalid", _r26.classList.contains("is-invalid"));
    ɵngcc0.ɵɵproperty("id", ctx_r8.prop.id)("autocomplete", ctx_r8.prop.autocomplete)("abpDisabled", ctx_r8.disabled)("ngbTypeahead", ctx_r8.search)("editable", false)("inputFormatter", ctx_r8.typeaheadFormatter)("resultFormatter", ctx_r8.typeaheadFormatter)("ngModelOptions", ɵngcc0.ɵɵpureFunction0(13, _c2))("ngModel", ctx_r8.typeaheadModel);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("formControlName", ctx_r8.prop.name);
} }
function ExtensibleFormPropComponent_div_0_ng_template_7_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r35 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_7_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelementStart(1, "input", 27, 28);
    ɵngcc0.ɵɵlistener("click", function ExtensibleFormPropComponent_div_0_ng_template_7_Template_input_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r35); const _r33 = ɵngcc0.ɵɵreference(2); return _r33.open(); })("keyup.space", function ExtensibleFormPropComponent_div_0_ng_template_7_Template_input_keyup_space_1_listener() { ɵngcc0.ɵɵrestoreView(_r35); const _r33 = ɵngcc0.ɵɵreference(2); return _r33.open(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r9.prop.id)("formControlName", ctx_r9.prop.name);
} }
function ExtensibleFormPropComponent_div_0_ng_template_8_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_8_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelement(1, "ngb-timepicker", 29);
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("formControlName", ctx_r10.prop.name);
} }
function ExtensibleFormPropComponent_div_0_ng_template_9_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_9_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelement(1, "abp-date-time-picker", 30);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("prop", ctx_r11.prop)("meridian", ctx_r11.meridian);
} }
function ExtensibleFormPropComponent_div_0_ng_template_10_ng_template_0_Template(rf, ctx) { }
function ExtensibleFormPropComponent_div_0_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_ng_template_10_ng_template_0_Template, 0, 0, "ng-template", 13);
    ɵngcc0.ɵɵelement(1, "textarea", 31, 15);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r12.prop.id)("formControlName", ctx_r12.prop.name)("abpDisabled", ctx_r12.disabled)("readonly", ctx_r12.readonly);
} }
function ExtensibleFormPropComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtemplate(1, ExtensibleFormPropComponent_div_0_ng_template_1_Template, 3, 7, "ng-template", 3);
    ɵngcc0.ɵɵtemplate(2, ExtensibleFormPropComponent_div_0_ng_template_2_Template, 1, 1, "ng-template", 4);
    ɵngcc0.ɵɵtemplate(3, ExtensibleFormPropComponent_div_0_ng_template_3_Template, 4, 6, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(4, ExtensibleFormPropComponent_div_0_ng_template_4_Template, 5, 8, "ng-template", 6);
    ɵngcc0.ɵɵtemplate(5, ExtensibleFormPropComponent_div_0_ng_template_5_Template, 5, 8, "ng-template", 7);
    ɵngcc0.ɵɵtemplate(6, ExtensibleFormPropComponent_div_0_ng_template_6_Template, 6, 14, "ng-template", 8);
    ɵngcc0.ɵɵtemplate(7, ExtensibleFormPropComponent_div_0_ng_template_7_Template, 3, 3, "ng-template", 9);
    ɵngcc0.ɵɵtemplate(8, ExtensibleFormPropComponent_div_0_ng_template_8_Template, 2, 2, "ng-template", 10);
    ɵngcc0.ɵɵtemplate(9, ExtensibleFormPropComponent_div_0_ng_template_9_Template, 2, 3, "ng-template", 11);
    ɵngcc0.ɵɵtemplate(10, ExtensibleFormPropComponent_div_0_ng_template_10_Template, 3, 5, "ng-template", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.getComponent(ctx_r0.prop));
} }
function ExtensibleFormPropComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 32);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "abpLocalization");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const classes_r41 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("htmlFor", ctx_r2.prop.id)("ngClass", classes_r41);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2("", ɵngcc0.ɵɵpipeBind1(2, 4, ctx_r2.prop.displayName), " ", ctx_r2.asterisk, "");
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 5);
    ɵngcc0.ɵɵelement(1, "abp-extensible-form-prop", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const prop_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const data_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("formGroupName", ctx_r7.extraPropertiesKey);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("prop", prop_r4)("data", data_r2);
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_template_2_abp_extensible_form_prop_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "abp-extensible-form-prop", 8);
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(3);
    const prop_r4 = ctx_r13.$implicit;
    const first_r5 = ctx_r13.first;
    const data_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("prop", prop_r4)("data", data_r2)("first", first_r5);
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_template_2_abp_extensible_form_prop_0_Template, 1, 3, "abp-extensible-form-prop", 7);
} if (rf & 2) {
    const prop_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.form.get(prop_r4.name));
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_container_1_Template, 2, 3, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_ng_template_2_Template, 1, 1, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r8 = ɵngcc0.ɵɵreference(3);
    const prop_r4 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.extraProperties.controls[prop_r4.name])("ngIfElse", _r8);
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_ng_container_1_Template, 4, 2, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const prop_r4 = ctx.$implicit;
    const data_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", prop_r4.visible(data_r2));
} }
function ExtensibleFormComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExtensibleFormComponent_ng_container_0_ng_container_1_ng_container_1_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.propList)("ngForTrackBy", ctx_r1.track.by("name"));
} }
function ExtensibleFormComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExtensibleFormComponent_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("abpPropDataFromList", ctx_r0.propList)("abpPropDataWithRecord", ctx_r0.record);
} }
function ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "abp-grid-actions", 7);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    const i_r4 = ctx_r8.rowIndex;
    const row_r3 = ctx_r8.row;
    ɵngcc0.ɵɵproperty("index", i_r4)("record", row_r3);
} }
const _c3 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_ng_container_0_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(1, ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_ng_template_1_Template, 1, 2, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const row_r3 = ctx.row;
    const i_r4 = ctx.rowIndex;
    const _r6 = ɵngcc0.ɵɵreference(2);
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.actionsTemplate || _r6)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c3, row_r3, i_r4));
} }
function ExtensibleTableComponent_ngx_datatable_column_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ngx-datatable-column", 3);
    ɵngcc0.ɵɵpipe(1, "abpLocalization");
    ɵngcc0.ɵɵtemplate(2, ExtensibleTableComponent_ngx_datatable_column_1_ng_template_2_Template, 3, 5, "ng-template", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ɵngcc0.ɵɵpipeBind1(1, 4, ctx_r0.actionsText))("maxWidth", ctx_r0.columnWidths[0])("width", ctx_r0.columnWidths[0])("sortable", false);
} }
function ExtensibleTableComponent_ng_container_2_ng_template_3_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵlistener("click", function ExtensibleTableComponent_ng_container_2_ng_template_3_ng_container_0_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); const row_r12 = ctx_r19.row; const i_r13 = ctx_r19.index; const prop_r9 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(); return prop_r9.action && prop_r9.action({ getInjected: ctx_r16.getInjected, record: row_r12, index: i_r13 }); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r12 = ɵngcc0.ɵɵnextContext(2).row;
    const prop_r9 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("pointer", prop_r9.action);
    ɵngcc0.ɵɵproperty("innerHTML", ɵngcc0.ɵɵpipeBind1(1, 3, row_r12["_" + prop_r9.name].value), ɵngcc0.ɵɵsanitizeHtml);
} }
function ExtensibleTableComponent_ng_container_2_ng_template_3_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExtensibleTableComponent_ng_container_2_ng_template_3_ng_container_0_div_1_Template, 2, 5, "div", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const row_r12 = ɵngcc0.ɵɵnextContext().row;
    const prop_r9 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", row_r12["_" + prop_r9.name].visible);
} }
function ExtensibleTableComponent_ng_container_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExtensibleTableComponent_ng_container_2_ng_template_3_ng_container_0_Template, 2, 1, "ng-container", 9);
} if (rf & 2) {
    const prop_r9 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("abpPermission", prop_r9.permission);
} }
function ExtensibleTableComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "ngx-datatable-column", 8);
    ɵngcc0.ɵɵpipe(2, "abpLocalization");
    ɵngcc0.ɵɵtemplate(3, ExtensibleTableComponent_ng_container_2_ng_template_3_Template, 1, 1, "ng-template", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const prop_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("width", ctx_r1.columnWidths[i_r10 + 1] || 200)("name", ɵngcc0.ɵɵpipeBind1(2, 4, prop_r9.displayName))("prop", prop_r9.name)("sortable", prop_r9.sortable);
} }
const _c4 = function (a0) { return { $implicit: a0 }; };
function GridActionsComponent_div_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 8);
} if (rf & 2) {
    const action_r5 = ctx.$implicit;
    ɵngcc0.ɵɵnextContext(2);
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c4, action_r5));
} }
function GridActionsComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵelementStart(1, "button", 4);
    ɵngcc0.ɵɵelement(2, "i", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "abpLocalization");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 6);
    ɵngcc0.ɵɵtemplate(6, GridActionsComponent_div_0_ng_container_6_Template, 1, 4, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("mr-1", ctx_r0.icon);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ɵngcc0.ɵɵpipeBind1(4, 6, ctx_r0.text), " ");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.actionList)("ngForTrackBy", ctx_r0.trackByFn);
} }
function GridActionsComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 8);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c4, ctx_r1.actionList.get(0).value));
} }
function GridActionsComponent_ng_template_2_ng_container_0_button_1_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "abpLocalization");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r6 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, action_r6.text));
} }
function GridActionsComponent_ng_template_2_ng_container_0_button_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "abpLocalization");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r6 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, action_r6.text));
} }
function GridActionsComponent_ng_template_2_ng_container_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 11);
    ɵngcc0.ɵɵlistener("click", function GridActionsComponent_ng_template_2_ng_container_0_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r15); const action_r6 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r14 = ɵngcc0.ɵɵnextContext(); return action_r6.action(ctx_r14.data); });
    ɵngcc0.ɵɵelement(1, "i", 5);
    ɵngcc0.ɵɵtemplate(2, GridActionsComponent_ng_template_2_ng_container_0_button_1_span_2_Template, 3, 3, "span", 12);
    ɵngcc0.ɵɵtemplate(3, GridActionsComponent_ng_template_2_ng_container_0_button_1_ng_template_3_Template, 3, 3, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r10 = ɵngcc0.ɵɵreference(4);
    const action_r6 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r8.actionList.length === 1 ? "btn btn-primary" : "");
    ɵngcc0.ɵɵclassProp("text-center", ctx_r8.actionList.length === 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("mr-1", action_r6.icon);
    ɵngcc0.ɵɵproperty("ngClass", action_r6.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", action_r6.icon)("ngIfElse", _r10);
} }
function GridActionsComponent_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, GridActionsComponent_ng_template_2_ng_container_0_button_1_Template, 5, 10, "button", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const action_r6 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("abpPermission", action_r6.permission);
} }
function GridActionsComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, GridActionsComponent_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 9);
} if (rf & 2) {
    const action_r6 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", action_r6.visible(ctx_r3.data));
} }
function PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const component_r7 = ctx.ngIf;
    const action_r1 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngComponentOutlet", component_r7)("ngComponentOutletInjector", ctx_r4.createInjector(action_r1));
} }
function PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 8);
    ɵngcc0.ɵɵlistener("click", function PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_template_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const action_r1 = ɵngcc0.ɵɵnextContext(3).$implicit; const ctx_r10 = ɵngcc0.ɵɵnextContext(); return action_r1.action(ctx_r10.data); });
    ɵngcc0.ɵɵelement(1, "i", 9);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "abpLocalization");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r1 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("mr-1", action_r1.icon);
    ɵngcc0.ɵɵproperty("ngClass", action_r1.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(3, 4, action_r1.text), " ");
} }
function PageToolbarComponent_div_1_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_container_1_Template, 2, 2, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(2, PageToolbarComponent_div_1_ng_container_1_ng_container_1_ng_template_2_Template, 4, 6, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r5 = ɵngcc0.ɵɵreference(3);
    const action_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", action_r1.component)("ngIfElse", _r5);
} }
function PageToolbarComponent_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PageToolbarComponent_div_1_ng_container_1_ng_container_1_Template, 4, 2, "ng-container", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const action_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("abpPermission", action_r1.permission);
} }
function PageToolbarComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtemplate(1, PageToolbarComponent_div_1_ng_container_1_Template, 2, 1, "ng-container", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", action_r1.visible(ctx_r0.data));
} }
class DateTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = new Date(value);
        if (isNaN(date))
            return null;
        this.value = {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
        return this.value;
    }
    toModel(value) {
        if (!value)
            return '';
        const now = new Date();
        value = Object.assign(Object.assign({ year: now.getUTCFullYear(), month: now.getMonth() + 1, day: now.getDate(), hour: 0, minute: 0, second: 0 }, this.value), value);
        const date = new Date(value.year, value.month - 1, value.day, value.hour, value.minute, value.second);
        return new Date(date).toISOString();
    }
}
DateTimeAdapter.ɵfac = function DateTimeAdapter_Factory(t) { return new (t || DateTimeAdapter)(); };
DateTimeAdapter.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DateTimeAdapter, factory: DateTimeAdapter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateTimeAdapter, [{
        type: Injectable
    }], null, null); })();

class DateAdapter extends NgbDateAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = new Date(value);
        if (isNaN(date))
            return null;
        return {
            day: date.getDate(),
            month: date.getMonth() + 1,
            year: date.getFullYear(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(value.year, value.month - 1, value.day);
        const formattedDate = formatDate(date, 'yyyy-MM-dd', 'en');
        return formattedDate;
    }
}
DateAdapter.ɵfac = /*@__PURE__*/ function () { let ɵDateAdapter_BaseFactory; return function DateAdapter_Factory(t) { return (ɵDateAdapter_BaseFactory || (ɵDateAdapter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DateAdapter)))(t || DateAdapter); }; }();
DateAdapter.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DateAdapter, factory: DateAdapter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateAdapter, [{
        type: Injectable
    }], null, null); })();

class TimeAdapter extends NgbTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = isTimeStr(value)
            ? new Date(0, 0, 1, ...value.split(':').map(Number))
            : new Date(value);
        if (isNaN(date))
            return null;
        return {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(0, 0, 1, value.hour, value.minute, value.second);
        const formattedDate = formatDate(date, 'HH:mm', 'en');
        return formattedDate;
    }
}
TimeAdapter.ɵfac = /*@__PURE__*/ function () { let ɵTimeAdapter_BaseFactory; return function TimeAdapter_Factory(t) { return (ɵTimeAdapter_BaseFactory || (ɵTimeAdapter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimeAdapter)))(t || TimeAdapter); }; }();
TimeAdapter.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TimeAdapter, factory: TimeAdapter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeAdapter, [{
        type: Injectable
    }], null, null); })();
function isTimeStr(value) {
    return /^((2[123])|[01][0-9])(\:[0-5][0-9]){1,2}$/.test(String(value));
}

function selfFactory(dependency) {
    return dependency;
}

const ɵ0$2 = selfFactory;
class DateTimePickerComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        this.meridian = false;
    }
    setDate(datestr) {
        this.date.writeValue(datestr);
    }
    setTime(datestr) {
        this.time.writeValue(datestr);
    }
}
DateTimePickerComponent.ɵfac = function DateTimePickerComponent_Factory(t) { return new (t || DateTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DateTimePickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateTimePickerComponent, selectors: [["abp-date-time-picker"]], viewQuery: function DateTimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NgbInputDatepicker, 5);
        ɵngcc0.ɵɵviewQuery(NgbTimepicker, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.date = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.time = _t.first);
    } }, inputs: { meridian: "meridian", prop: "prop" }, exportAs: ["abpDateTimePicker"], features: [ɵngcc0.ɵɵProvidersFeature([], [
            {
                provide: ControlContainer,
                useFactory: ɵ0$2,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]]
            },
            {
                provide: NgbDateAdapter,
                useClass: DateTimeAdapter
            },
            {
                provide: NgbTimeAdapter,
                useClass: DateTimeAdapter
            },
        ])], decls: 4, vars: 4, consts: [["ngbDatepicker", "", "type", "text", 1, "form-control", 3, "id", "formControlName", "ngModelChange", "click", "keyup.space"], ["datepicker", "ngbDatepicker"], [3, "formControlName", "meridian", "ngModelChange"], ["timepicker", ""]], template: function DateTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        const _r2 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function DateTimePickerComponent_Template_input_ngModelChange_0_listener($event) { return ctx.setTime($event); })("click", function DateTimePickerComponent_Template_input_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return _r0.open(); })("keyup.space", function DateTimePickerComponent_Template_input_keyup_space_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return _r0.open(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "ngb-timepicker", 2, 3);
        ɵngcc0.ɵɵlistener("ngModelChange", function DateTimePickerComponent_Template_ngb_timepicker_ngModelChange_2_listener($event) { return ctx.setDate($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.prop.id)("formControlName", ctx.prop.name);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("formControlName", ctx.prop.name)("meridian", ctx.meridian);
    } }, directives: [ɵngcc1.NgbInputDatepicker, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.FormControlName, ɵngcc3.ValidationDirective, ɵngcc1.NgbTimepicker], encapsulation: 2, changeDetection: 0 });
DateTimePickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DateTimePickerComponent.propDecorators = {
    prop: [{ type: Input }],
    meridian: [{ type: Input }],
    date: [{ type: ViewChild, args: [NgbInputDatepicker,] }],
    time: [{ type: ViewChild, args: [NgbTimepicker,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateTimePickerComponent, [{
        type: Component,
        args: [{
                exportAs: 'abpDateTimePicker',
                selector: 'abp-date-time-picker',
                template: `
    <input
      [id]="prop.id"
      [formControlName]="prop.name"
      (ngModelChange)="setTime($event)"
      (click)="datepicker.open()"
      (keyup.space)="datepicker.open()"
      ngbDatepicker
      #datepicker="ngbDatepicker"
      type="text"
      class="form-control"
    />
    <ngb-timepicker
      #timepicker
      [formControlName]="prop.name"
      (ngModelChange)="setDate($event)"
      [meridian]="meridian"
    ></ngb-timepicker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0$2,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]]
                    },
                    {
                        provide: NgbDateAdapter,
                        useClass: DateTimeAdapter
                    },
                    {
                        provide: NgbTimeAdapter,
                        useClass: DateTimeAdapter
                    },
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { meridian: [{
            type: Input
        }], prop: [{
            type: Input
        }], date: [{
            type: ViewChild,
            args: [NgbInputDatepicker]
        }], time: [{
            type: ViewChild,
            args: [NgbTimepicker]
        }] }); })();

const EXTRA_PROPERTIES_KEY = 'extraProperties';

const TYPEAHEAD_TEXT_SUFFIX = '_Text';
const TYPEAHEAD_TEXT_SUFFIX_REGEX = /_Text$/;
function createTypeaheadOptions(lookup) {
    return (data, searchText) => searchText
        ? data
            .getInjected(RestService)
            .request({
            method: 'GET',
            url: lookup.url,
            params: {
                [lookup.filterParamName]: searchText,
            },
        }, { apiName: 'Default' })
            .pipe(map(response => {
            const list = response[lookup.resultListPropertyName];
            const mapToOption = (item) => ({
                key: item[lookup.displayPropertyName],
                value: item[lookup.valuePropertyName],
            });
            return list.map(mapToOption);
        }))
        : of([]);
}
function getTypeaheadType(lookup, name) {
    return Boolean(lookup.url)
        ? "typeahead" /* Typeahead */
        : name.endsWith(TYPEAHEAD_TEXT_SUFFIX)
            ? "hidden" /* Hidden */
            : undefined;
}
function createTypeaheadDisplayNameGenerator(displayNameGeneratorFn, properties) {
    return (displayName, fallback) => {
        const name = removeTypeaheadTextSuffix(fallback.name);
        return displayNameGeneratorFn(displayName || properties[name].displayName, {
            name,
            resource: fallback.resource,
        });
    };
}
function addTypeaheadTextSuffix(name) {
    return name + TYPEAHEAD_TEXT_SUFFIX;
}
function hasTypeaheadTextSuffix(name) {
    return TYPEAHEAD_TEXT_SUFFIX_REGEX.test(name);
}
function removeTypeaheadTextSuffix(name) {
    return name.replace(TYPEAHEAD_TEXT_SUFFIX_REGEX, '');
}

const ɵ0$1 = selfFactory;
class ExtensibleFormPropComponent {
    constructor(cdRef, track, configState, groupDirective) {
        this.cdRef = cdRef;
        this.track = track;
        this.configState = configState;
        this.asterisk = '';
        this.options$ = of([]);
        this.validators = [];
        this.search = (text$) => text$
            ? text$.pipe(debounceTime(300), distinctUntilChanged(), switchMap(text => this.prop.options(this.data, text)))
            : of([]);
        this.typeaheadFormatter = (option) => option.key;
        this.form = groupDirective.form;
    }
    setTypeaheadValue(selectedOption) {
        this.typeaheadModel = selectedOption || { key: null, value: null };
        const { key, value } = this.typeaheadModel;
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (valueControl.value && !value)
            valueControl.markAsDirty();
        keyControl.setValue(key);
        valueControl.setValue(value);
    }
    get meridian() {
        return (this.configState.getDeep('localization.currentCulture.dateTimeFormat.shortTimePattern') || '').includes('tt');
    }
    get isInvalid() {
        const control = this.form.get(this.prop.name);
        return control.touched && control.invalid;
    }
    getTypeaheadControls() {
        const { name } = this.prop;
        const extraPropName = `${EXTRA_PROPERTIES_KEY}.${name}`;
        const keyControl = this.form.get(addTypeaheadTextSuffix(extraPropName)) ||
            this.form.get(addTypeaheadTextSuffix(name));
        const valueControl = this.form.get(extraPropName) || this.form.get(name);
        return [keyControl, valueControl];
    }
    setAsterisk() {
        this.asterisk = this.validators.some(isRequired) ? '*' : '';
    }
    ngAfterViewInit() {
        if (this.first && this.fieldRef) {
            this.fieldRef.nativeElement.focus();
        }
    }
    getComponent(prop) {
        switch (prop.type) {
            case "boolean" /* Boolean */:
                return 'checkbox';
            case "date" /* Date */:
                return 'date';
            case "dateTime" /* DateTime */:
                return 'dateTime';
            case "hidden" /* Hidden */:
                return 'hidden';
            case "multiselect" /* MultiSelect */:
                return 'multiselect';
            case "text" /* Text */:
                return 'textarea';
            case "time" /* Time */:
                return 'time';
            case "typeahead" /* Typeahead */:
                return 'typeahead';
            default:
                return prop.options ? 'select' : 'input';
        }
    }
    getType(prop) {
        switch (prop.type) {
            case "date" /* Date */:
            case "string" /* String */:
                return 'text';
            case "boolean" /* Boolean */:
                return 'checkbox';
            case "number" /* Number */:
                return 'number';
            case "email" /* Email */:
                return 'email';
            case "password" /* Password */:
                return 'password';
            default:
                return 'hidden';
        }
    }
    ngOnChanges({ prop }) {
        const currentProp = snq(() => prop.currentValue);
        const { options, readonly, disabled, validators } = currentProp || {};
        if (options)
            this.options$ = options(this.data);
        if (readonly)
            this.readonly = readonly(this.data);
        if (disabled)
            this.disabled = disabled(this.data);
        if (validators) {
            this.validators = validators(this.data);
            this.setAsterisk();
        }
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (keyControl && valueControl)
            this.typeaheadModel = { key: keyControl.value, value: valueControl.value };
    }
}
ExtensibleFormPropComponent.ɵfac = function ExtensibleFormPropComponent_Factory(t) { return new (t || ExtensibleFormPropComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.TrackByService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.ConfigStateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective)); };
ExtensibleFormPropComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExtensibleFormPropComponent, selectors: [["abp-extensible-form-prop"]], viewQuery: function ExtensibleFormPropComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fieldRef = _t.first);
    } }, inputs: { data: "data", prop: "prop", first: "first" }, features: [ɵngcc0.ɵɵProvidersFeature([], [
            {
                provide: ControlContainer,
                useFactory: ɵ0$1,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]]
            },
            { provide: NgbDateAdapter, useClass: DateAdapter },
            { provide: NgbTimeAdapter, useClass: TimeAdapter },
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 1, consts: [["class", "form-group", 3, "ngSwitch", 4, "abpPermission"], ["label", ""], [1, "form-group", 3, "ngSwitch"], ["ngSwitchCase", "input"], ["ngSwitchCase", "hidden"], ["ngSwitchCase", "checkbox"], ["ngSwitchCase", "select"], ["ngSwitchCase", "multiselect"], ["ngSwitchCase", "typeahead"], ["ngSwitchCase", "date"], ["ngSwitchCase", "time"], ["ngSwitchCase", "dateTime"], ["ngSwitchCase", "textarea"], [3, "ngTemplateOutlet"], [1, "form-control", 3, "id", "formControlName", "autocomplete", "type", "abpDisabled", "readonly"], ["field", ""], ["type", "hidden", 3, "formControlName"], ["validationTarget", "", 1, "custom-checkbox", "custom-control"], ["type", "checkbox", 1, "custom-control-input", 3, "id", "formControlName", "abpDisabled"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "custom-select", "form-control", 3, "id", "formControlName", "abpDisabled"], [3, "ngValue", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngValue"], ["multiple", "multiple", 1, "custom-select", "form-control", 3, "id", "formControlName", "abpDisabled"], ["validationStyle", "", "validationTarget", "", 1, "position-relative"], ["typeahead", ""], [1, "form-control", 3, "id", "autocomplete", "abpDisabled", "ngbTypeahead", "editable", "inputFormatter", "resultFormatter", "ngModelOptions", "ngModel", "ngModelChange", "selectItem", "blur"], ["ngbDatepicker", "", "type", "text", 1, "form-control", 3, "id", "formControlName", "click", "keyup.space"], ["datepicker", "ngbDatepicker"], [3, "formControlName"], [3, "prop", "meridian"], [1, "form-control", 3, "id", "formControlName", "abpDisabled", "readonly"], [3, "htmlFor", "ngClass"]], template: function ExtensibleFormPropComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ExtensibleFormPropComponent_div_0_Template, 11, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ExtensibleFormPropComponent_ng_template_1_Template, 3, 6, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("abpPermission", ctx.prop.permission);
    } }, directives: function () { return [ɵngcc4.PermissionDirective, ɵngcc5.NgSwitch, ɵngcc5.NgSwitchCase, ɵngcc5.NgTemplateOutlet, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.FormControlName, ɵngcc3.ValidationDirective, DisabledDirective, ɵngcc3.ValidationTargetDirective, ɵngcc2.CheckboxControlValueAccessor, ɵngcc2.SelectControlValueAccessor, ɵngcc5.NgForOf, ɵngcc2.NgSelectOption, ɵngcc2.ɵNgSelectMultipleOption, ɵngcc2.SelectMultipleControlValueAccessor, ɵngcc3.ValidationStyleDirective, ɵngcc1.NgbTypeahead, ɵngcc2.NgModel, ɵngcc1.NgbInputDatepicker, ɵngcc1.NgbTimepicker, DateTimePickerComponent, ɵngcc5.NgClass]; }, pipes: function () { return [ɵngcc5.AsyncPipe, ɵngcc4.LocalizationPipe]; }, encapsulation: 2, changeDetection: 0 });
ExtensibleFormPropComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TrackByService },
    { type: ConfigStateService },
    { type: FormGroupDirective }
];
ExtensibleFormPropComponent.propDecorators = {
    data: [{ type: Input }],
    prop: [{ type: Input }],
    first: [{ type: Input }],
    fieldRef: [{ type: ViewChild, args: ['field',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExtensibleFormPropComponent, [{
        type: Component,
        args: [{
                selector: 'abp-extensible-form-prop',
                template: "<div class=\"form-group\" *abpPermission=\"prop.permission\" [ngSwitch]=\"getComponent(prop)\">\n  <ng-template ngSwitchCase=\"input\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <input\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [autocomplete]=\"prop.autocomplete\"\n      [type]=\"getType(prop)\"\n      [abpDisabled]=\"disabled\"\n      [readonly]=\"readonly\"\n      class=\"form-control\"\n    />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"hidden\">\n    <input [formControlName]=\"prop.name\" type=\"hidden\" />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"checkbox\">\n    <div class=\"custom-checkbox custom-control\" validationTarget>\n      <input\n        #field\n        [id]=\"prop.id\"\n        [formControlName]=\"prop.name\"\n        [abpDisabled]=\"disabled\"\n        type=\"checkbox\"\n        class=\"custom-control-input\"\n      />\n      <ng-template\n        [ngTemplateOutlet]=\"label\"\n        [ngTemplateOutletContext]=\"{ $implicit: 'custom-control-label' }\"\n      ></ng-template>\n    </div>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"select\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <select\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      class=\"custom-select form-control\"\n    >\n      <option\n        *ngFor=\"let option of options$ | async; trackBy: track.by('value')\"\n        [ngValue]=\"option.value\"\n      >\n        {{ option.key }}\n      </option>\n    </select>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"multiselect\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <select\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      multiple=\"multiple\"\n      class=\"custom-select form-control\"\n    >\n      <option\n        *ngFor=\"let option of options$ | async; trackBy: track.by('value')\"\n        [ngValue]=\"option.value\"\n      >\n        {{ option.key }}\n      </option>\n    </select>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"typeahead\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <div #typeahead class=\"position-relative\" validationStyle validationTarget>\n      <input\n        #field\n        [id]=\"prop.id\"\n        [autocomplete]=\"prop.autocomplete\"\n        [abpDisabled]=\"disabled\"\n        [ngbTypeahead]=\"search\"\n        [editable]=\"false\"\n        [inputFormatter]=\"typeaheadFormatter\"\n        [resultFormatter]=\"typeaheadFormatter\"\n        [ngModelOptions]=\"{ standalone: true }\"\n        [(ngModel)]=\"typeaheadModel\"\n        (selectItem)=\"setTypeaheadValue($event.item)\"\n        (blur)=\"setTypeaheadValue(typeaheadModel)\"\n        [class.is-invalid]=\"typeahead.classList.contains('is-invalid')\"\n        class=\"form-control\"\n      />\n      <input [formControlName]=\"prop.name\" type=\"hidden\" />\n    </div>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"date\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <input\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      (click)=\"datepicker.open()\"\n      (keyup.space)=\"datepicker.open()\"\n      ngbDatepicker\n      #datepicker=\"ngbDatepicker\"\n      type=\"text\"\n      class=\"form-control\"\n    />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"time\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <ngb-timepicker [formControlName]=\"prop.name\"></ngb-timepicker>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"dateTime\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <abp-date-time-picker [prop]=\"prop\" [meridian]=\"meridian\"></abp-date-time-picker>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"textarea\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <textarea\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      [readonly]=\"readonly\"\n      class=\"form-control\"\n    ></textarea>\n  </ng-template>\n</div>\n\n<ng-template #label let-classes>\n  <label [htmlFor]=\"prop.id\" [ngClass]=\"classes\"\n    >{{ prop.displayName | abpLocalization }} {{ asterisk }}</label\n  >\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0$1,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]]
                    },
                    { provide: NgbDateAdapter, useClass: DateAdapter },
                    { provide: NgbTimeAdapter, useClass: TimeAdapter },
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.TrackByService }, { type: ɵngcc4.ConfigStateService }, { type: ɵngcc2.FormGroupDirective }]; }, { data: [{
            type: Input
        }], prop: [{
            type: Input
        }], first: [{
            type: Input
        }], fieldRef: [{
            type: ViewChild,
            args: ['field']
        }] }); })();
function isRequired(validator) {
    return validator === Validators.required || validator === AbpValidators.required;
}

/* tslint:disable:variable-name */
class ActionList extends LinkedList {
}
class ActionData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Action {
    constructor(permission, visible = _ => true, action = _ => { }) {
        this.permission = permission;
        this.visible = visible;
        this.action = action;
    }
}
class ActionsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Actions {
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    get actions() {
        const actionList = new this._ctor();
        this.callbackList.forEach(callback => callback(actionList));
        return actionList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class EntityActionList extends ActionList {
}
class EntityActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = EntityActionList;
    }
}
class EntityActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityActions;
    }
}
class EntityAction extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
    }
    static create(options) {
        return new EntityAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityAction.create);
    }
}

/* tslint:disable:variable-name */
class PropList extends LinkedList {
}
class PropData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Prop {
    constructor(type, name, displayName, permission, visible = _ => true, isExtra = false) {
        this.type = type;
        this.name = name;
        this.displayName = displayName;
        this.permission = permission;
        this.visible = visible;
        this.isExtra = isExtra;
        this.displayName = this.displayName || this.name;
    }
}
class PropsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Props {
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    get props() {
        const propList = new this._ctor();
        this.callbackList.forEach(callback => callback(propList));
        return propList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class EntityPropList extends PropList {
}
class EntityProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = EntityPropList;
    }
}
class EntityPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityProps;
    }
}
class EntityProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName, options.permission, options.visible, options.isExtra);
        this.columnWidth = options.columnWidth;
        this.sortable = options.sortable || false;
        this.valueResolver = options.valueResolver || (data => of(data.record[this.name]));
        this.action = options.action;
    }
    static create(options) {
        return new EntityProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityProp.create);
    }
}

class FormPropList extends PropList {
}
class FormProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = FormPropList;
    }
}
class CreateFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class EditFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class FormProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName, options.permission, options.visible, options.isExtra);
        this.asyncValidators = options.asyncValidators || (_ => []);
        this.validators = options.validators || (_ => []);
        this.disabled = options.disabled || (_ => false);
        this.readonly = options.readonly || (_ => false);
        this.autocomplete = options.autocomplete || 'off';
        this.options = options.options;
        this.id = options.id || options.name;
        const defaultValue = options.defaultValue;
        this.defaultValue = isFalsyValue(defaultValue) ? defaultValue : defaultValue || null;
    }
    static create(options) {
        return new FormProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(FormProp.create);
    }
}
class FormPropData extends PropData {
    constructor(injector, record) {
        super();
        this.record = record;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
    }
}
function isFalsyValue(defaultValue) {
    return [0, '', false].indexOf(defaultValue) > -1;
}

class ToolbarActionList extends ActionList {
}
class ToolbarActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActionList;
    }
}
class ToolbarActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActions;
    }
}
class ToolbarAction extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
    }
    static create(options) {
        return new ToolbarAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarAction.create);
    }
}
class ToolbarComponent extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.component = options.component;
    }
    static create(options) {
        return new ToolbarComponent(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarComponent.create);
    }
}

class ExtensionsService {
    constructor() {
        this.entityActions = new EntityActionsFactory();
        this.toolbarActions = new ToolbarActionsFactory();
        this.entityProps = new EntityPropsFactory();
        this.createFormProps = new CreateFormPropsFactory();
        this.editFormProps = new EditFormPropsFactory();
    }
}
ExtensionsService.ɵfac = function ExtensionsService_Factory(t) { return new (t || ExtensionsService)(); };
ExtensionsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ExtensionsService_Factory() { return new ExtensionsService(); }, token: ExtensionsService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExtensionsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

const EXTENSIONS_IDENTIFIER = new InjectionToken('EXTENSIONS_IDENTIFIER');
const EXTENSIONS_ACTION_TYPE = new InjectionToken('EXTENSIONS_ACTION_TYPE');
const EXTENSIONS_ACTION_DATA = new InjectionToken('EXTENSIONS_ACTION_DATA');
const EXTENSIONS_ACTION_CALLBACK = new InjectionToken('EXTENSIONS_ACTION_DATA');

const ɵ0 = selfFactory;
class ExtensibleFormComponent {
    constructor(cdRef, track, container, extensions, identifier) {
        this.cdRef = cdRef;
        this.track = track;
        this.container = container;
        this.extensions = extensions;
        this.identifier = identifier;
        this.extraPropertiesKey = EXTRA_PROPERTIES_KEY;
    }
    set selectedRecord(record) {
        const type = !record || JSON.stringify(record) === '{}' ? 'create' : 'edit';
        this.propList = this.extensions[`${type}FormProps`].get(this.identifier).props;
        this.record = record;
    }
    get form() {
        return (this.container ? this.container.control : { controls: {} });
    }
    get extraProperties() {
        return (this.form.controls.extraProperties || { controls: {} });
    }
}
ExtensibleFormComponent.ɵfac = function ExtensibleFormComponent_Factory(t) { return new (t || ExtensibleFormComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.TrackByService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ControlContainer), ɵngcc0.ɵɵdirectiveInject(ExtensionsService), ɵngcc0.ɵɵdirectiveInject(EXTENSIONS_IDENTIFIER)); };
ExtensibleFormComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExtensibleFormComponent, selectors: [["abp-extensible-form"]], viewQuery: function ExtensibleFormComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ExtensibleFormPropComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formProps = _t);
    } }, inputs: { selectedRecord: "selectedRecord" }, exportAs: ["abpExtensibleForm"], features: [ɵngcc0.ɵɵProvidersFeature([], [
            {
                provide: ControlContainer,
                useFactory: ɵ0,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]]
            },
        ])], decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "abpPropData", "abpPropDataFromList", "abpPropDataWithRecord"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "formGroupName", 4, "ngIf", "ngIfElse"], ["tempDefault", ""], [3, "formGroupName"], [3, "prop", "data"], [3, "prop", "data", "first", 4, "ngIf"], [3, "prop", "data", "first"]], template: function ExtensibleFormComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ExtensibleFormComponent_ng_container_0_Template, 2, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.form);
    } }, directives: function () { return [ɵngcc5.NgIf, PropDataDirective, ɵngcc5.NgForOf, ɵngcc2.NgControlStatusGroup, ɵngcc2.FormGroupName, ɵngcc3.ValidationGroupDirective, ExtensibleFormPropComponent]; }, encapsulation: 2, changeDetection: 0 });
ExtensibleFormComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TrackByService },
    { type: ControlContainer },
    { type: ExtensionsService },
    { type: String, decorators: [{ type: Inject, args: [EXTENSIONS_IDENTIFIER,] }] }
];
ExtensibleFormComponent.propDecorators = {
    formProps: [{ type: ViewChildren, args: [ExtensibleFormPropComponent,] }],
    selectedRecord: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExtensibleFormComponent, [{
        type: Component,
        args: [{
                exportAs: 'abpExtensibleForm',
                selector: 'abp-extensible-form',
                template: "<ng-container *ngIf=\"form\">\n  <ng-container *abpPropData=\"let data; fromList: propList; withRecord: record\">\n    <ng-container *ngFor=\"let prop of propList; let first = first; trackBy: track.by('name')\">\n      <ng-container *ngIf=\"prop.visible(data)\">\n        <ng-container\n          [formGroupName]=\"extraPropertiesKey\"\n          *ngIf=\"extraProperties.controls[prop.name]; else tempDefault\"\n        >\n          <abp-extensible-form-prop [prop]=\"prop\" [data]=\"data\"></abp-extensible-form-prop>\n        </ng-container>\n\n        <ng-template #tempDefault>\n          <abp-extensible-form-prop\n            *ngIf=\"form.get(prop.name)\"\n            [prop]=\"prop\"\n            [data]=\"data\"\n            [first]=\"first\"\n          ></abp-extensible-form-prop>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]]
                    },
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.TrackByService }, { type: ɵngcc2.ControlContainer }, { type: ExtensionsService }, { type: String, decorators: [{
                type: Inject,
                args: [EXTENSIONS_IDENTIFIER]
            }] }]; }, { selectedRecord: [{
            type: Input
        }], formProps: [{
            type: ViewChildren,
            args: [ExtensibleFormPropComponent]
        }] }); })();

const DEFAULT_ACTIONS_COLUMN_WIDTH = 150;
class ExtensibleTableComponent {
    constructor(locale, config, injector) {
        this.locale = locale;
        this.config = config;
        this.trackByFn = (_, item) => item.name;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        this.propList = extensions.entityProps.get(name).props;
        this.actionList = extensions['entityActions'].get(name)
            .actions;
        this.setColumnWidths(DEFAULT_ACTIONS_COLUMN_WIDTH);
    }
    set actionsText(value) {
        this._actionsText = value;
    }
    get actionsText() {
        var _a;
        return (_a = this._actionsText) !== null && _a !== void 0 ? _a : (this.actionList.length > 1 ? 'AbpUi::Actions' : '');
    }
    set actionsColumnWidth(width) {
        this.setColumnWidths(width ? Number(width) : undefined);
    }
    setColumnWidths(actionsColumn) {
        const widths = [actionsColumn];
        this.propList.forEach(({ value: prop }) => {
            widths.push(prop.columnWidth);
        });
        this.columnWidths = widths;
    }
    getDate(value, format) {
        return value ? formatDate(value, format, this.locale) : '';
    }
    getIcon(value) {
        return value
            ? '<div class="text-center text-success"><i class="fa fa-check"></i></div>'
            : '<div class="text-center text-danger"><i class="fa fa-times"></i></div>';
    }
    getContent(prop, data) {
        return prop.valueResolver(data).pipe(map(value => {
            switch (prop.type) {
                case "boolean" /* Boolean */:
                    return this.getIcon(value);
                case "date" /* Date */:
                    return this.getDate(value, getShortDateFormat(this.config));
                case "time" /* Time */:
                    return this.getDate(value, getShortTimeFormat(this.config));
                case "dateTime" /* DateTime */:
                    return this.getDate(value, getShortDateShortTimeFormat(this.config));
                default:
                    return value;
                // More types can be handled in the future
            }
        }));
    }
    ngOnChanges({ data }) {
        if (!(data === null || data === void 0 ? void 0 : data.currentValue))
            return;
        this.data = data.currentValue.map((record, index) => {
            this.propList.forEach(prop => {
                const propData = { getInjected: this.getInjected, record, index };
                record[`_${prop.value.name}`] = {
                    visible: prop.value.visible(propData),
                    value: this.getContent(prop.value, propData),
                };
            });
            return record;
        });
    }
}
ExtensibleTableComponent.ɵfac = function ExtensibleTableComponent_Factory(t) { return new (t || ExtensibleTableComponent)(ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.ConfigStateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
ExtensibleTableComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExtensibleTableComponent, selectors: [["abp-extensible-table"]], inputs: { actionsText: "actionsText", actionsColumnWidth: "actionsColumnWidth", data: "data", list: "list", recordsTotal: "recordsTotal", actionsTemplate: "actionsTemplate" }, exportAs: ["abpExtensibleTable"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 6, consts: [["default", "", 3, "rows", "count", "list"], [3, "name", "maxWidth", "width", "sortable", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "name", "maxWidth", "width", "sortable"], ["ngx-datatable-cell-template", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["gridActions", ""], ["text", "AbpUi::Actions", 3, "index", "record"], [3, "width", "name", "prop", "sortable"], [4, "abpPermission"], [3, "innerHTML", "pointer", "click", 4, "ngIf"], [3, "innerHTML", "click"]], template: function ExtensibleTableComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-datatable", 0);
        ɵngcc0.ɵɵtemplate(1, ExtensibleTableComponent_ngx_datatable_column_1_Template, 3, 6, "ngx-datatable-column", 1);
        ɵngcc0.ɵɵtemplate(2, ExtensibleTableComponent_ng_container_2_Template, 4, 6, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("rows", ctx.data)("count", ctx.recordsTotal)("list", ctx.list);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionsTemplate || ctx.actionList.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.propList)("ngForTrackBy", ctx.trackByFn);
    } }, directives: function () { return [ɵngcc6.DatatableComponent, ɵngcc7.NgxDatatableDefaultDirective, ɵngcc7.NgxDatatableListDirective, ɵngcc5.NgIf, ɵngcc5.NgForOf, ɵngcc6.DataTableColumnDirective, ɵngcc6.DataTableColumnCellDirective, ɵngcc5.NgTemplateOutlet, GridActionsComponent, ɵngcc4.PermissionDirective]; }, pipes: function () { return [ɵngcc4.LocalizationPipe, ɵngcc5.AsyncPipe]; }, encapsulation: 2, changeDetection: 0 });
ExtensibleTableComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ConfigStateService },
    { type: Injector }
];
ExtensibleTableComponent.propDecorators = {
    actionsText: [{ type: Input }],
    data: [{ type: Input }],
    list: [{ type: Input }],
    recordsTotal: [{ type: Input }],
    actionsColumnWidth: [{ type: Input }],
    actionsTemplate: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExtensibleTableComponent, [{
        type: Component,
        args: [{
                exportAs: 'abpExtensibleTable',
                selector: 'abp-extensible-table',
                template: "<ngx-datatable default [rows]=\"data\" [count]=\"recordsTotal\" [list]=\"list\">\n  <ngx-datatable-column\n    *ngIf=\"actionsTemplate || actionList.length\"\n    [name]=\"actionsText | abpLocalization\"\n    [maxWidth]=\"columnWidths[0]\"\n    [width]=\"columnWidths[0]\"\n    [sortable]=\"false\"\n  >\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\n      <ng-container\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\n      ></ng-container>\n      <ng-template #gridActions>\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\n      </ng-template>\n    </ng-template>\n  </ngx-datatable-column>\n\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\n    <ngx-datatable-column\n      [width]=\"columnWidths[i + 1] || 200\"\n      [name]=\"prop.displayName | abpLocalization\"\n      [prop]=\"prop.name\"\n      [sortable]=\"prop.sortable\"\n    >\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\n        <ng-container *abpPermission=\"prop.permission\">\n          <div\n            *ngIf=\"row['_' + prop.name].visible\"\n            [innerHTML]=\"row['_' + prop.name].value | async\"\n            (click)=\"\n              prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\n            \"\n            [class.pointer]=\"prop.action\"\n          ></div>\n        </ng-container>\n      </ng-template>\n    </ngx-datatable-column>\n  </ng-container>\n</ngx-datatable>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc4.ConfigStateService }, { type: ɵngcc0.Injector }]; }, { actionsText: [{
            type: Input
        }], actionsColumnWidth: [{
            type: Input
        }], data: [{
            type: Input
        }], list: [{
            type: Input
        }], recordsTotal: [{
            type: Input
        }], actionsTemplate: [{
            type: Input
        }] }); })();

// tslint:disable: directive-class-suffix
// Fix for https://github.com/angular/angular/issues/23904
// @dynamic
class AbstractActionsComponent extends ActionData {
    constructor(injector) {
        super();
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        const type = injector.get(EXTENSIONS_ACTION_TYPE);
        this.actionList = extensions[type].get(name).actions;
    }
}
AbstractActionsComponent.ɵfac = function AbstractActionsComponent_Factory(t) { return new (t || AbstractActionsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
AbstractActionsComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: AbstractActionsComponent, inputs: { record: "record" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AbstractActionsComponent.ctorParameters = () => [
    { type: Injector }
];
AbstractActionsComponent.propDecorators = {
    record: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractActionsComponent, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.Injector }]; }, { record: [{
            type: Input
        }] }); })();

class GridActionsComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.icon = 'fa fa-cog';
        this.text = '';
        this.trackByFn = (_, item) => item.text;
    }
}
GridActionsComponent.ɵfac = function GridActionsComponent_Factory(t) { return new (t || GridActionsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
GridActionsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridActionsComponent, selectors: [["abp-grid-actions"]], inputs: { icon: "icon", text: "text", index: "index" }, exportAs: ["abpGridActions"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: EXTENSIONS_ACTION_TYPE,
                useValue: 'entityActions'
            },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 2, consts: [["ngbDropdown", "", "container", "body", "class", "d-inline-block", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["btnItem", ""], ["ngbDropdown", "", "container", "body", 1, "d-inline-block"], ["data-toggle", "dropdown", "aria-haspopup", "true", "ngbDropdownToggle", "", 1, "btn", "btn-primary", "btn-sm", "dropdown-toggle"], [3, "ngClass"], ["ngbDropdownMenu", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], ["ngbDropdownItem", "", "type", "button", 3, "class", "text-center", "click", 4, "abpPermission"], ["ngbDropdownItem", "", "type", "button", 3, "click"], [4, "ngIf", "ngIfElse"], ["ellipsis", ""], ["abpEllipsis", ""]], template: function GridActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridActionsComponent_div_0_Template, 7, 8, "div", 0);
        ɵngcc0.ɵɵtemplate(1, GridActionsComponent_ng_container_1_Template, 1, 4, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, GridActionsComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionList.length > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionList.length === 1);
    } }, directives: [ɵngcc5.NgIf, ɵngcc1.NgbDropdown, ɵngcc1.NgbDropdownToggle, ɵngcc5.NgClass, ɵngcc1.NgbDropdownMenu, ɵngcc5.NgForOf, ɵngcc5.NgTemplateOutlet, ɵngcc4.PermissionDirective, ɵngcc1.NgbDropdownItem, ɵngcc7.EllipsisDirective], pipes: [ɵngcc4.LocalizationPipe], encapsulation: 2, changeDetection: 0 });
GridActionsComponent.ctorParameters = () => [
    { type: Injector }
];
GridActionsComponent.propDecorators = {
    icon: [{ type: Input }],
    index: [{ type: Input }],
    text: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridActionsComponent, [{
        type: Component,
        args: [{
                exportAs: 'abpGridActions',
                selector: 'abp-grid-actions',
                template: "<div *ngIf=\"actionList.length > 1\" ngbDropdown container=\"body\" class=\"d-inline-block\">\n  <button\n    class=\"btn btn-primary btn-sm dropdown-toggle\"\n    data-toggle=\"dropdown\"\n    aria-haspopup=\"true\"\n    ngbDropdownToggle\n  >\n    <i [ngClass]=\"icon\" [class.mr-1]=\"icon\"></i>{{ text | abpLocalization }}\n  </button>\n  <div ngbDropdownMenu>\n    <ng-container\n      *ngFor=\"let action of actionList; trackBy: trackByFn\"\n      [ngTemplateOutlet]=\"btnItem\"\n      [ngTemplateOutletContext]=\"{ $implicit: action }\"\n    >\n    </ng-container>\n  </div>\n</div>\n\n<ng-container\n  *ngIf=\"actionList.length === 1\"\n  [ngTemplateOutlet]=\"btnItem\"\n  [ngTemplateOutletContext]=\"{ $implicit: actionList.get(0).value }\"\n></ng-container>\n\n<ng-template #btnItem let-action>\n  <ng-container *ngIf=\"action.visible(data)\">\n    <button\n      ngbDropdownItem\n      *abpPermission=\"action.permission\"\n      (click)=\"action.action(data)\"\n      type=\"button\"\n      class=\"{{ actionList.length === 1 ? 'btn btn-primary' : '' }}\"\n      [class.text-center]=\"actionList.length === 1\"\n    >\n      <i [ngClass]=\"action.icon\" [class.mr-1]=\"action.icon\"></i>\n      <span *ngIf=\"action.icon; else ellipsis\">{{ action.text | abpLocalization }}</span>\n      <ng-template #ellipsis>\n        <div abpEllipsis>{{ action.text | abpLocalization }}</div>\n      </ng-template>\n    </button>\n  </ng-container>\n</ng-template>\n",
                providers: [
                    {
                        provide: EXTENSIONS_ACTION_TYPE,
                        useValue: 'entityActions'
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, { icon: [{
            type: Input
        }], text: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();

class PageToolbarComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.injector = injector;
        this.trackByFn = (_, item) => item.action || item.component;
    }
    createInjector(action) {
        const get = (token, notFoundValue, flags) => {
            return token === EXTENSIONS_ACTION_DATA
                ? this.data
                : token === EXTENSIONS_ACTION_CALLBACK
                    ? (data = this.data) => action.action(data)
                    : this.getInjected.call(this.injector, token, notFoundValue, flags);
        };
        return { get };
    }
}
PageToolbarComponent.ɵfac = function PageToolbarComponent_Factory(t) { return new (t || PageToolbarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
PageToolbarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PageToolbarComponent, selectors: [["abp-page-toolbar"]], exportAs: ["abpPageToolbar"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: EXTENSIONS_ACTION_TYPE,
                useValue: 'toolbarActions'
            },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["id", "AbpContentToolbar", 1, "row", "justify-content-end", "mx-n1"], ["class", "col-auto px-1 pt-0 pt-md-2", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "col-auto", "px-1", "pt-0", "pt-md-2"], [4, "ngIf"], [4, "abpPermission"], [4, "ngIf", "ngIfElse"], ["button", ""], [4, "ngComponentOutlet", "ngComponentOutletInjector"], ["type", "button", 1, "btn", "btn-primary", "btn-sm", 3, "click"], [3, "ngClass"]], template: function PageToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, PageToolbarComponent_div_1_Template, 2, 1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.actionList)("ngForTrackBy", ctx.trackByFn);
    } }, directives: [ɵngcc5.NgForOf, ɵngcc5.NgIf, ɵngcc4.PermissionDirective, ɵngcc5.NgComponentOutlet, ɵngcc5.NgClass], pipes: [ɵngcc4.LocalizationPipe], encapsulation: 2, changeDetection: 0 });
PageToolbarComponent.ctorParameters = () => [
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PageToolbarComponent, [{
        type: Component,
        args: [{
                exportAs: 'abpPageToolbar',
                selector: 'abp-page-toolbar',
                template: "<div class=\"row justify-content-end mx-n1\" id=\"AbpContentToolbar\">\n  <div class=\"col-auto px-1 pt-0 pt-md-2\" *ngFor=\"let action of actionList; trackBy: trackByFn\">\n    <ng-container *ngIf=\"action.visible(data)\">\n      <ng-container *abpPermission=\"action.permission\">\n        <ng-container *ngIf=\"action.component as component; else button\">\n          <ng-container\n            *ngComponentOutlet=\"component; injector: createInjector(action)\"\n          ></ng-container>\n        </ng-container>\n\n        <ng-template #button>\n          <button (click)=\"action.action(data)\" type=\"button\" class=\"btn btn-primary btn-sm\">\n            <i [ngClass]=\"action.icon\" [class.mr-1]=\"action.icon\"></i>\n            {{ action.text | abpLocalization }}\n          </button>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </div>\n</div>\n",
                providers: [
                    {
                        provide: EXTENSIONS_ACTION_TYPE,
                        useValue: 'toolbarActions'
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();

class DisabledDirective {
    constructor(ngControl) {
        this.ngControl = ngControl;
    }
    // Related issue: https://github.com/angular/angular/issues/35330
    ngOnChanges({ abpDisabled }) {
        if (this.ngControl.control && abpDisabled) {
            this.ngControl.control[abpDisabled.currentValue ? 'disable' : 'enable']();
        }
    }
}
DisabledDirective.ɵfac = function DisabledDirective_Factory(t) { return new (t || DisabledDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 1)); };
DisabledDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DisabledDirective, selectors: [["", "abpDisabled", ""]], inputs: { abpDisabled: "abpDisabled" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
DisabledDirective.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Host }] }
];
DisabledDirective.propDecorators = {
    abpDisabled: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DisabledDirective, [{
        type: Directive,
        args: [{
                selector: '[abpDisabled]'
            }]
    }], function () { return [{ type: ɵngcc2.NgControl, decorators: [{
                type: Host
            }] }]; }, { abpDisabled: [{
            type: Input
        }] }); })();

class PropDataDirective extends PropData {
    constructor(tempRef, vcRef, injector) {
        super();
        this.tempRef = tempRef;
        this.vcRef = vcRef;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
    }
    ngOnChanges() {
        this.vcRef.clear();
        this.vcRef.createEmbeddedView(this.tempRef, {
            $implicit: this.data,
            index: 0,
        });
    }
    ngOnDestroy() {
        this.vcRef.clear();
    }
}
PropDataDirective.ɵfac = function PropDataDirective_Factory(t) { return new (t || PropDataDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
PropDataDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PropDataDirective, selectors: [["", "abpPropData", ""]], inputs: { propList: ["abpPropDataFromList", "propList"], record: ["abpPropDataWithRecord", "record"], index: ["abpPropDataAtIndex", "index"] }, exportAs: ["abpPropData"], features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
PropDataDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: Injector }
];
PropDataDirective.propDecorators = {
    propList: [{ type: Input, args: ['abpPropDataFromList',] }],
    record: [{ type: Input, args: ['abpPropDataWithRecord',] }],
    index: [{ type: Input, args: ['abpPropDataAtIndex',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PropDataDirective, [{
        type: Directive,
        args: [{
                exportAs: 'abpPropData',
                selector: '[abpPropData]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }]; }, { propList: [{
            type: Input,
            args: ['abpPropDataFromList']
        }], record: [{
            type: Input,
            args: ['abpPropDataWithRecord']
        }], index: [{
            type: Input,
            args: ['abpPropDataAtIndex']
        }] }); })();

var objectExtensions = /*#__PURE__*/Object.freeze({
    __proto__: null
});

class BaseUiExtensionsModule {
}
BaseUiExtensionsModule.ɵfac = function BaseUiExtensionsModule_Factory(t) { return new (t || BaseUiExtensionsModule)(); };
BaseUiExtensionsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BaseUiExtensionsModule });
BaseUiExtensionsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CoreModule,
            ThemeSharedModule,
            NgxValidateCoreModule,
            NgbDatepickerModule,
            NgbDropdownModule,
            NgbTimepickerModule,
            NgbTypeaheadModule,
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseUiExtensionsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    DateTimePickerComponent,
                    PageToolbarComponent,
                    GridActionsComponent,
                    ExtensibleFormComponent,
                    ExtensibleTableComponent,
                    PropDataDirective,
                    DisabledDirective,
                ],
                declarations: [
                    DateTimePickerComponent,
                    PageToolbarComponent,
                    GridActionsComponent,
                    ExtensibleFormPropComponent,
                    ExtensibleFormComponent,
                    ExtensibleTableComponent,
                    PropDataDirective,
                    DisabledDirective,
                ],
                imports: [
                    CoreModule,
                    ThemeSharedModule,
                    NgxValidateCoreModule,
                    NgbDatepickerModule,
                    NgbDropdownModule,
                    NgbTimepickerModule,
                    NgbTypeaheadModule,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BaseUiExtensionsModule, { declarations: function () { return [DateTimePickerComponent, PageToolbarComponent, GridActionsComponent, ExtensibleFormPropComponent, ExtensibleFormComponent, ExtensibleTableComponent, PropDataDirective, DisabledDirective]; }, imports: function () { return [CoreModule,
        ThemeSharedModule,
        NgxValidateCoreModule,
        NgbDatepickerModule,
        NgbDropdownModule,
        NgbTimepickerModule,
        NgbTypeaheadModule]; }, exports: function () { return [DateTimePickerComponent, PageToolbarComponent, GridActionsComponent, ExtensibleFormComponent, ExtensibleTableComponent, PropDataDirective, DisabledDirective]; } }); })();
class UiExtensionsModule {
}
UiExtensionsModule.ɵfac = function UiExtensionsModule_Factory(t) { return new (t || UiExtensionsModule)(); };
UiExtensionsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: UiExtensionsModule });
UiExtensionsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[BaseUiExtensionsModule], BaseUiExtensionsModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UiExtensionsModule, [{
        type: NgModule,
        args: [{
                exports: [BaseUiExtensionsModule],
                imports: [BaseUiExtensionsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UiExtensionsModule, { imports: [BaseUiExtensionsModule], exports: [BaseUiExtensionsModule] }); })();

function mergeWithDefaultActions(extension, defaultActions, ...contributors) {
    Object.keys(defaultActions).forEach((name) => {
        const actions = extension.get(name);
        actions.clearContributors();
        actions.addContributor((actionList) => actionList.addManyTail(defaultActions[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => actions.addContributor(callback)));
    });
}

function generateFormFromProps(data) {
    const extensions = data.getInjected(ExtensionsService);
    const identifier = data.getInjected(EXTENSIONS_IDENTIFIER);
    const form = new FormGroup({});
    const extraForm = new FormGroup({});
    form.addControl(EXTRA_PROPERTIES_KEY, extraForm);
    const record = data.record || {};
    const type = JSON.stringify(record) === '{}' ? 'create' : 'edit';
    const props = extensions[`${type}FormProps`].get(identifier).props;
    const extraProperties = record[EXTRA_PROPERTIES_KEY] || {};
    props.forEach(({ value: prop }) => {
        const name = prop.name;
        const isExtraProperty = prop.isExtra || name in extraProperties;
        let value = isExtraProperty ? extraProperties[name] : name in record ? record[name] : undefined;
        if (typeof value === 'undefined')
            value = prop.defaultValue;
        if (value) {
            let adapter;
            switch (prop.type) {
                case "date" /* Date */:
                    adapter = new DateAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "time" /* Time */:
                    adapter = new TimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "dateTime" /* DateTime */:
                    adapter = new DateTimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                default:
                    break;
            }
        }
        const formControl = new FormControl(value, {
            asyncValidators: prop.asyncValidators(data),
            validators: prop.validators(data),
        });
        (isExtraProperty ? extraForm : form).addControl(name, formControl);
    });
    return form;
}

function createExtraPropertyValueResolver(name) {
    return (data) => of(data.record[EXTRA_PROPERTIES_KEY][name]);
}
function mergeWithDefaultProps(extension, defaultProps, ...contributors) {
    Object.keys(defaultProps).forEach((name) => {
        const props = extension.get(name);
        props.clearContributors();
        props.addContributor((propList) => propList.addManyTail(defaultProps[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => props.addContributor(callback)));
    });
}

function createEnum(members) {
    const enumObject = {};
    members.forEach(({ name, value }) => {
        enumObject[(enumObject[name] = value)] = name;
    });
    return enumObject;
}
function createEnumValueResolver(enumType, lookupEnum, propName) {
    return data => {
        const value = data.record[EXTRA_PROPERTIES_KEY][propName];
        const key = lookupEnum.transformed[value];
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, localizeEnum(key));
    };
}
function createEnumOptions(enumType, lookupEnum) {
    return data => {
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, lookupEnum.fields.map(({ name, value }) => ({
            key: localizeEnum(name),
            value,
        })));
    };
}
function createLocalizationStream(l10n, mapTarget) {
    return merge(of(null), l10n.languageChange$).pipe(map(() => mapTarget));
}
function createEnumLocalizer(l10n, enumType, lookupEnum) {
    const resource = lookupEnum.localizationResource;
    const shortType = getShortEnumType(enumType);
    return key => l10n.localizeWithFallbackSync([resource], ['Enum:' + shortType + '.' + key, shortType + '.' + key, key], key);
}
function getShortEnumType(enumType) {
    return enumType.split('.').pop();
}

function createDisplayNameLocalizationPipeKeyGenerator(localization) {
    const generateLocalizationPipeKey = createLocalizationPipeKeyGenerator(localization);
    return (displayName, fallback) => {
        if (displayName && displayName.name)
            return generateLocalizationPipeKey([displayName.resource], [displayName.name], displayName.name);
        const key = generateLocalizationPipeKey([fallback.resource], ['DisplayName:' + fallback.name], undefined);
        if (key)
            return key;
        return generateLocalizationPipeKey([fallback.resource], [fallback.name], fallback.name);
    };
}

function getValidatorsFromProperty(property) {
    const validators = [];
    property.attributes.forEach(attr => {
        if (attr.typeSimple in AbpValidators)
            validators.push(AbpValidators[attr.typeSimple](attr.config));
    });
    return validators;
}

function selectObjectExtensions(configState) {
    return configState.getOne$('objectExtensions');
}
function selectLocalization(configState) {
    return configState.getOne$('localization');
}
function selectEnums(configState) {
    return selectObjectExtensions(configState).pipe(map((extensions) => Object.keys(extensions.enums).reduce((acc, key) => {
        const { fields, localizationResource } = extensions.enums[key];
        acc[key] = {
            fields,
            localizationResource,
            transformed: createEnum(fields),
        };
        return acc;
    }, {})));
}
function getObjectExtensionEntitiesFromStore(configState, moduleKey) {
    return selectObjectExtensions(configState).pipe(map(extensions => {
        if (!extensions)
            return null;
        return (extensions.modules[moduleKey] || {})
            .entities;
    }), map(entities => (isUndefined(entities) ? {} : entities)), filter(Boolean), take(1));
}
function mapEntitiesToContributors(configState, resource) {
    return pipe(switchMap(entities => zip(selectLocalization(configState), selectEnums(configState)).pipe(map(([localization, enums]) => {
        const generateDisplayName = createDisplayNameLocalizationPipeKeyGenerator(localization);
        return Object.keys(entities).reduce((acc, key) => {
            acc.prop[key] = [];
            acc.createForm[key] = [];
            acc.editForm[key] = [];
            const entity = entities[key];
            if (!entity)
                return acc;
            const properties = entity.properties;
            if (!properties)
                return acc;
            const mapPropertiesToContributors = createPropertiesToContributorsMapper(generateDisplayName, resource, enums);
            return mapPropertiesToContributors(properties, acc, key);
        }, {
            prop: {},
            createForm: {},
            editForm: {},
        });
    }))), take(1));
}
function createPropertiesToContributorsMapper(generateDisplayName, resource, enums) {
    return (properties, contributors, key) => {
        const isExtra = true;
        const generateTypeaheadDisplayName = createTypeaheadDisplayNameGenerator(generateDisplayName, properties);
        Object.keys(properties).forEach((name) => {
            const property = properties[name];
            const propName = name;
            const lookup = property.ui.lookup || {};
            const type = getTypeaheadType(lookup, name) || getTypeFromProperty(property);
            const generateDN = hasTypeaheadTextSuffix(name)
                ? generateTypeaheadDisplayName
                : generateDisplayName;
            const displayName = generateDN(property.displayName, { name, resource });
            if (property.ui.onTable.isVisible) {
                const sortable = Boolean(property.ui.onTable.isSortable);
                const columnWidth = type === "boolean" /* Boolean */ ? 150 : 250;
                const valueResolver = type === "enum" /* Enum */
                    ? createEnumValueResolver(property.type, enums[property.type], propName)
                    : createExtraPropertyValueResolver(propName);
                const entityProp = new EntityProp({
                    type,
                    name: propName,
                    displayName,
                    sortable,
                    columnWidth,
                    valueResolver,
                    isExtra,
                });
                const contributor = (propList) => propList.addTail(entityProp);
                contributors.prop[key].push(contributor);
            }
            const isOnCreateForm = property.ui.onCreateForm.isVisible;
            const isOnEditForm = property.ui.onEditForm.isVisible;
            if (isOnCreateForm || isOnEditForm) {
                const defaultValue = property.defaultValue;
                const validators = () => getValidatorsFromProperty(property);
                let options;
                if (type === "enum" /* Enum */)
                    options = createEnumOptions(propName, enums[property.type]);
                else if (type === "typeahead" /* Typeahead */)
                    options = createTypeaheadOptions(lookup);
                const formProp = new FormProp({
                    type,
                    name: propName,
                    displayName,
                    options,
                    defaultValue,
                    validators,
                    isExtra,
                });
                const formContributor = (propList) => propList.addTail(formProp);
                if (isOnCreateForm)
                    contributors.createForm[key].push(formContributor);
                if (isOnEditForm)
                    contributors.editForm[key].push(formContributor);
            }
        });
        return contributors;
    };
}
function getTypeFromProperty(property) {
    return property.typeSimple.replace(/\?$/, '');
}
function isUndefined(obj) {
    return typeof obj === 'undefined';
}

/**
 * Generated bundle index. Do not edit.
 */

export { ActionList, BaseUiExtensionsModule, CreateFormPropsFactory, DateAdapter, DateTimeAdapter, DateTimePickerComponent, DisabledDirective, EXTENSIONS_ACTION_CALLBACK, EXTENSIONS_ACTION_DATA, EXTENSIONS_ACTION_TYPE, EXTENSIONS_IDENTIFIER, EXTRA_PROPERTIES_KEY, EditFormPropsFactory, EntityAction, EntityActionList, EntityActions, EntityActionsFactory, EntityProp, EntityPropList, EntityProps, EntityPropsFactory, ExtensibleFormComponent, ExtensibleFormPropComponent, ExtensibleTableComponent, ExtensionsService, FormProp, FormPropData, FormPropList, FormProps, GridActionsComponent, objectExtensions as ObjectExtensions, PageToolbarComponent, PropDataDirective, PropList, TimeAdapter, ToolbarAction, ToolbarActionList, ToolbarActions, ToolbarActionsFactory, ToolbarComponent, UiExtensionsModule, createExtraPropertyValueResolver, generateFormFromProps, getObjectExtensionEntitiesFromStore, mapEntitiesToContributors, mergeWithDefaultActions, mergeWithDefaultProps, ActionData as ɵa, Action as ɵb, ActionsFactory as ɵc, Actions as ɵd, PropData as ɵe, Prop as ɵf, PropsFactory as ɵg, Props as ɵh, selfFactory as ɵi, AbstractActionsComponent as ɵj };

//# sourceMappingURL=abp-ng.theme.shared-extensions.js.map