import { HttpWaitService, RouterWaitService, SubscriptionService } from '@abp/ng.core';
import { ChangeDetectorRef, Component, Input } from '@angular/core';
import { Router } from '@angular/router';
import { combineLatest, Subscription, timer } from 'rxjs';
export class LoaderBarComponent {
    constructor(router, cdRef, subscription, httpWaitService, routerWaitService) {
        this.router = router;
        this.cdRef = cdRef;
        this.subscription = subscription;
        this.httpWaitService = httpWaitService;
        this.routerWaitService = routerWaitService;
        this.containerClass = 'abp-loader-bar';
        this.color = '#77b6ff';
        this.progressLevel = 0;
        this.interval = new Subscription();
        this.timer = new Subscription();
        this.intervalPeriod = 350;
        this.stopDelay = 800;
        this.clearProgress = () => {
            this.progressLevel = 0;
            this.cdRef.detectChanges();
        };
        this.reportProgress = () => {
            if (this.progressLevel < 75) {
                this.progressLevel += 1 + Math.random() * 9;
            }
            else if (this.progressLevel < 90) {
                this.progressLevel += 0.4;
            }
            else if (this.progressLevel < 100) {
                this.progressLevel += 0.1;
            }
            else {
                this.interval.unsubscribe();
            }
            this.cdRef.detectChanges();
        };
    }
    set isLoading(value) {
        this._isLoading = value;
        this.cdRef.detectChanges();
    }
    get isLoading() {
        return this._isLoading;
    }
    get boxShadow() {
        return `0 0 10px rgba(${this.color}, 0.5)`;
    }
    ngOnInit() {
        this.subscribeLoading();
    }
    subscribeLoading() {
        this.subscription.addOne(combineLatest([this.httpWaitService.getLoading$(), this.routerWaitService.getLoading$()]), ([httpLoading, routerLoading]) => {
            if (httpLoading || routerLoading)
                this.startLoading();
            else
                this.stopLoading();
        });
    }
    ngOnDestroy() {
        this.interval.unsubscribe();
    }
    startLoading() {
        if (this.isLoading || !this.interval.closed)
            return;
        this.isLoading = true;
        this.progressLevel = 0;
        this.cdRef.detectChanges();
        this.interval = timer(0, this.intervalPeriod).subscribe(this.reportProgress);
        this.timer.unsubscribe();
    }
    stopLoading() {
        this.interval.unsubscribe();
        this.progressLevel = 100;
        this.isLoading = false;
        if (!this.timer.closed)
            return;
        this.timer = timer(this.stopDelay).subscribe(this.clearProgress);
    }
}
LoaderBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-loader-bar',
                template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow
        }"
      ></div>
    </div>
  `,
                providers: [SubscriptionService],
                styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}"]
            },] }
];
LoaderBarComponent.ctorParameters = () => [
    { type: Router },
    { type: ChangeDetectorRef },
    { type: SubscriptionService },
    { type: HttpWaitService },
    { type: RouterWaitService }
];
LoaderBarComponent.propDecorators = {
    isLoading: [{ type: Input }],
    containerClass: [{ type: Input }],
    color: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGVyLWJhci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy90aGVtZS1zaGFyZWQvc3JjL2xpYi9jb21wb25lbnRzL2xvYWRlci1iYXIvbG9hZGVyLWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBcUIsTUFBTSxlQUFlLENBQUM7QUFDdkYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQW9CMUQsTUFBTSxPQUFPLGtCQUFrQjtJQWtEN0IsWUFDVSxNQUFjLEVBQ2QsS0FBd0IsRUFDeEIsWUFBaUMsRUFDakMsZUFBZ0MsRUFDaEMsaUJBQW9DO1FBSnBDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN4QixpQkFBWSxHQUFaLFlBQVksQ0FBcUI7UUFDakMsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUExQzlDLG1CQUFjLEdBQUcsZ0JBQWdCLENBQUM7UUFHbEMsVUFBSyxHQUFHLFNBQVMsQ0FBQztRQUVsQixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUVsQixhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUU5QixVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUzQixtQkFBYyxHQUFHLEdBQUcsQ0FBQztRQUVyQixjQUFTLEdBQUcsR0FBRyxDQUFDO1FBRUMsa0JBQWEsR0FBRyxHQUFHLEVBQUU7WUFDcEMsSUFBSSxD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QUFDOzs7WUFqSEYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7O0dBWVQ7Z0JBRUQsU0FBUyxFQUFFLENBQUMsbUJBQW1CLENBQUM7O2FBQ2pDOzs7WUFwQlEsTUFBTTtZQUROLGlCQUFpQjtZQURtQixtQkFBbUI7WUFBdkQsZUFBZTtZQUFFLGlCQUFpQjs7O3dCQTBCeEMsS0FBSzs2QkFTTCxLQUFLO29CQUdMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwV2FpdFNlcnZpY2UsIFJvdXRlcldhaXRTZXJ2aWNlLCBTdWJzY3JpcHRpb25TZXJ2aWNlIH0gZnJvbSAnQGFicC9uZy5jb3JlJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIFN1YnNjcmlwdGlvbiwgdGltZXIgfSBmcm9tICdyeGpzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWJwLWxvYWRlci1iYXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgaWQ9XCJhYnAtbG9hZGVyLWJhclwiIFtuZ0NsYXNzXT1cImNvbnRhaW5lckNsYXNzXCIgW2NsYXNzLmlzLWxvYWRpbmddPVwiaXNMb2FkaW5nXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiYWJwLXByb2dyZXNzXCJcbiAgICAgICAgW2NsYXNzLnByb2dyZXNzaW5nXT1cInByb2dyZXNzTGV2ZWxcIlxuICAgICAgICBbc3R5bGUud2lkdGgudnddPVwicHJvZ3Jlc3NMZXZlbFwiXG4gICAgICAgIFtuZ1N0eWxlXT1cIntcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNvbG9yLFxuICAgICAgICAgICdib3gtc2hhZG93JzogYm94U2hhZG93XG4gICAgICAgIH1cIlxuICAgICAgPjwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICBzdHlsZVVybHM6IFsnLi9sb2FkZXItYmFyLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW1N1YnNjcmlwdGlvblNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBMb2FkZXJCYXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByb3RlY3RlZCBfaXNMb2FkaW5nOiBib29sZWFuO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBpc0xvYWRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pc0xvYWRpbmcgPSB2YWx1ZTtcbiAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuICBnZXQgaXNMb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc0xvYWRpbmc7XG4gIH1cblxuICBASW5wdXQoKVxuICBjb250YWluZXJDbGFzcyA9ICdhYnAtbG9hZGVyLWJhcic7XG5cbiAgQElucHV0KClcbiAgY29sb3IgPSAnIzc3YjZmZic7XG5cbiAgcHJvZ3Jlc3NMZXZlbCA9IDA7XG5cbiAgaW50ZXJ2YWwgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgdGltZXIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgaW50ZXJ2YWxQZXJpb2QgPSAzNTA7XG5cbiAgc3RvcERlbGF5ID0gODAwO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY2xlYXJQcm9ncmVzcyA9ICgpID0+IHtcbiAgICB0aGlzLnByb2dyZXNzTGV2ZWwgPSAwO1xuICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVwb3J0UHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NMZXZlbCA8IDc1KSB7XG4gICAgICB0aGlzLnByb2dyZXNzTGV2ZWwgKz0gMSArIE1hdGgucmFuZG9tKCkgKiA5O1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9ncmVzc0xldmVsIDwgOTApIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCArPSAwLjQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2dyZXNzTGV2ZWwgPCAxMDApIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCArPSAwLjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJ2YWwudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gIH07XG5cbiAgZ2V0IGJveFNoYWRvdygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgMCAwIDEwcHggcmdiYSgke3RoaXMuY29sb3J9LCAwLjUpYDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXG4gICAgcHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBodHRwV2FpdFNlcnZpY2U6IEh0dHBXYWl0U2VydmljZSxcbiAgICBwcml2YXRlIHJvdXRlcldhaXRTZXJ2aWNlOiBSb3V0ZXJXYWl0U2VydmljZSxcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaWJlTG9hZGluZygpO1xuICB9XG5cbiAgc3Vic2NyaWJlTG9hZGluZygpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGRPbmUoXG4gICAgICBjb21iaW5lTGF0ZXN0KFt0aGlzLmh0dHBXYWl0U2VydmljZS5nZXRMb2FkaW5nJCgpLCB0aGlzLnJvdXRlcldhaXRTZXJ2aWNlLmdldExvYWRpbmckKCldKSxcbiAgICAgIChbaHR0cExvYWRpbmcsIHJvdXRlckxvYWRpbmddKSA9PiB7XG4gICAgICAgIGlmIChodHRwTG9hZGluZyB8fCByb3V0ZXJMb2FkaW5nKSB0aGlzLnN0YXJ0TG9hZGluZygpO1xuICAgICAgICBlbHNlIHRoaXMuc3RvcExvYWRpbmcoKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuaW50ZXJ2YWwudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHN0YXJ0TG9hZGluZygpIHtcbiAgICBpZiAodGhpcy5pc0xvYWRpbmcgfHwgIXRoaXMuaW50ZXJ2YWwuY2xvc2VkKSByZXR1cm47XG5cbiAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgdGhpcy5wcm9ncmVzc0xldmVsID0gMDtcbiAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB0aGlzLmludGVydmFsID0gdGltZXIoMCwgdGhpcy5pbnRlcnZhbFBlcmlvZCkuc3Vic2NyaWJlKHRoaXMucmVwb3J0UHJvZ3Jlc3MpO1xuICAgIHRoaXMudGltZXIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHN0b3BMb2FkaW5nKCkge1xuICAgIHRoaXMuaW50ZXJ2YWwudW5zdWJzY3JpYmUoKTtcblxuICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCA9IDEwMDtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLnRpbWVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy50aW1lciA9IHRpbWVyKHRoaXMuc3RvcERlbGF5KS5zdWJzY3JpYmUodGhpcy5jbGVhclByb2dyZXNzKTtcbiAgfVxufVxuIl19