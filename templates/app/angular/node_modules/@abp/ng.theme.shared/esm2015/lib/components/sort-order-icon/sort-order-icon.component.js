import { Component, EventEmitter, Input, Output } from '@angular/core';
/**
 * @deprecated To be deleted in v5.0. Use ngx-datatale instead.
 */
export class SortOrderIconComponent {
    constructor() {
        this.orderChange = new EventEmitter();
        this.selectedSortKeyChange = new EventEmitter();
    }
    set selectedSortKey(value) {
        this._selectedSortKey = value;
        this.selectedSortKeyChange.emit(value);
    }
    get selectedSortKey() {
        return this._selectedSortKey;
    }
    set order(value) {
        this._order = value;
        this.orderChange.emit(value);
    }
    get order() {
        return this._order;
    }
    get icon() {
        if (this.selectedSortKey === this.sortKey)
            return `sorting_${this.order}`;
        else
            return 'sorting';
    }
    sort(key) {
        this.selectedSortKey = key;
        switch (this.order) {
            case '':
                this.order = 'asc';
                this.orderChange.emit('asc');
                break;
            case 'asc':
                this.order = 'desc';
                this.orderChange.emit('desc');
                break;
            case 'desc':
                this.order = '';
                this.orderChange.emit('');
                break;
        }
    }
}
SortOrderIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-sort-order-icon',
                template: "<div class=\"float-right {{ iconClass }}\">\n  <span class=\"{{ icon }}\"></span>\n</div>\n"
            },] }
];
SortOrderIconComponent.propDecorators = {
    sortKey: [{ type: Input }],
    selectedSortKey: [{ type: Input }],
    order: [{ type: Input }],
    orderChange: [{ type: Output }],
    selectedSortKeyChange: [{ type: Output }],
    iconClass: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC1vcmRlci1pY29uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3RoZW1lLXNoYXJlZC9zcmMvbGliL2NvbXBvbmVudHMvc29ydC1vcmRlci1pY29uL3NvcnQtb3JkZXItaWNvbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2RTs7R0FFRztBQUtILE1BQU0sT0FBTyxzQkFBc0I7SUFKbkM7UUE2QnFCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUN6QywwQkFBcUIsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO0lBMkJ4RSxDQUFDO0lBOUNDLElBQ0ksZUFBZSxDQUFDLEtBQWE7UUFDL0IsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztRQUM5QixJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFDRCxJQUFJLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQ0ksS0FBSyxDQUFDLEtBQTBCO1FBQ2xDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDRCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQVFELElBQUksSUFBSTtRQUNOLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBSyxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sV0FBVyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7O1lBQ3JFLE9BQU8sU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFJLENBQUMsR0FBVztRQUNkLElBQUksQ0FBQyxlQUFlLEdBQUcsR0FBRyxDQUFDO1FBQzNCLFFBQVEsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNsQixLQUFLLEVBQUU7Z0JBQ0wsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM3QixNQUFNO1lBQ1IsS0FBSyxLQUFLO2dCQUNSLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO2dCQUNwQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDOUIsTUFBTTtZQUNSLEtBQUssTUFBTTtnQkFDVCxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzFCLE1BQU07U0FDVDtJQUNILENBQUM7OztZQXhERixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IsdUdBQStDO2FBQ2hEOzs7c0JBS0UsS0FBSzs4QkFHTCxLQUFLO29CQVNMLEtBQUs7MEJBU0wsTUFBTTtvQ0FDTixNQUFNO3dCQUVOLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFRvIGJlIGRlbGV0ZWQgaW4gdjUuMC4gVXNlIG5neC1kYXRhdGFsZSBpbnN0ZWFkLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdhYnAtc29ydC1vcmRlci1pY29uJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3NvcnQtb3JkZXItaWNvbi5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIFNvcnRPcmRlckljb25Db21wb25lbnQge1xuICBwcml2YXRlIF9vcmRlcjogJ2FzYycgfCAnZGVzYycgfCAnJztcbiAgcHJpdmF0ZSBfc2VsZWN0ZWRTb3J0S2V5OiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgc29ydEtleTogc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBzZWxlY3RlZFNvcnRLZXkodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3NlbGVjdGVkU29ydEtleSA9IHZhbHVlO1xuICAgIHRoaXMuc2VsZWN0ZWRTb3J0S2V5Q2hhbmdlLmVtaXQodmFsdWUpO1xuICB9XG4gIGdldCBzZWxlY3RlZFNvcnRLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRTb3J0S2V5O1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IG9yZGVyKHZhbHVlOiAnYXNjJyB8ICdkZXNjJyB8ICcnKSB7XG4gICAgdGhpcy5fb3JkZXIgPSB2YWx1ZTtcbiAgICB0aGlzLm9yZGVyQ2hhbmdlLmVtaXQodmFsdWUpO1xuICB9XG4gIGdldCBvcmRlcigpOiAnYXNjJyB8ICdkZXNjJyB8ICcnIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG4gIH1cblxuICBAT3V0cHV0KCkgcmVhZG9ubHkgb3JkZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkU29ydEtleUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gIEBJbnB1dCgpXG4gIGljb25DbGFzczogc3RyaW5nO1xuXG4gIGdldCBpY29uKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRTb3J0S2V5ID09PSB0aGlzLnNvcnRLZXkpIHJldHVybiBgc29ydGluZ18ke3RoaXMub3JkZXJ9YDtcbiAgICBlbHNlIHJldHVybiAnc29ydGluZyc7XG4gIH1cblxuICBzb3J0KGtleTogc3RyaW5nKSB7XG4gICAgdGhpcy5zZWxlY3RlZFNvcnRLZXkgPSBrZXk7XG4gICAgc3dpdGNoICh0aGlzLm9yZGVyKSB7XG4gICAgICBjYXNlICcnOlxuICAgICAgICB0aGlzLm9yZGVyID0gJ2FzYyc7XG4gICAgICAgIHRoaXMub3JkZXJDaGFuZ2UuZW1pdCgnYXNjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXNjJzpcbiAgICAgICAgdGhpcy5vcmRlciA9ICdkZXNjJztcbiAgICAgICAgdGhpcy5vcmRlckNoYW5nZS5lbWl0KCdkZXNjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVzYyc6XG4gICAgICAgIHRoaXMub3JkZXIgPSAnJztcbiAgICAgICAgdGhpcy5vcmRlckNoYW5nZS5lbWl0KCcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXX0=