import { animation, style, animate, keyframes, trigger, state, transition, useAnimation, query } from '@angular/animations';
import { __rest } from 'tslib';
import * as i1 from '@abp/ng.core';
import { getRoutePath, SubscriptionService, RoutesService, RouterEvents, HttpWaitService, RouterWaitService, PROJECTION_STRATEGY, ContentProjectionService, uuid, LocalizationService, SortPipe, RestOccurError, AuthService, getLocaleDirection, LazyLoadService, LOADING_STRATEGY, InternalStore, DomInsertionService, CONTENT_STRATEGY, ConfigStateService, CoreModule, noop } from '@abp/ng.core';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, Renderer2, Input, Output, ViewChild, ElementRef, ViewEncapsulation, Injectable, InjectionToken, isDevMode, Optional, Inject, ContentChild, Directive, HostListener, ViewContainerRef, ComponentFactoryResolver, Injector, HostBinding, Host, Self, NgModule, ApplicationRef, RendererFactory2, APP_INITIALIZER, inject, LOCALE_ID } from '@angular/core';
import { Router, ResolveEnd } from '@angular/router';
import { startWith, map, debounceTime, filter, takeUntil, distinctUntilChanged, take, catchError, switchMap } from 'rxjs/operators';
import { ReplaySubject, BehaviorSubject, fromEvent, Subscription, combineLatest, timer, Subject, throwError, Observable, of } from 'rxjs';
import snq from 'snq';
import { NgbModal, NgbInputDatepickerConfig, NgbTypeaheadConfig, NgbDateParserFormatter, NgbPaginationModule } from '@ng-bootstrap/ng-bootstrap';
import { DOCUMENT, formatDate, DatePipe } from '@angular/common';
import { ColumnMode, DatatableComponent, NgxDatatableModule } from '@swimlane/ngx-datatable';
import clone from 'just-clone';
import { HttpErrorResponse } from '@angular/common/http';
import * as i1$1 from '@ngxs/store';
import { ofActionSuccessful, Actions } from '@ngxs/store';
import { NgxValidateCoreModule, VALIDATION_BLUEPRINTS, VALIDATION_MAP_ERRORS_FN, defaultMapErrorsFn, VALIDATION_VALIDATE_ON_SUBMIT, validatePassword } from '@ngx-validate/core';
import { Validators } from '@angular/forms';

const bounceIn = animation([
    style({ opacity: '0', display: '{{ display }}' }),
    animate('{{ time}} {{ easing }}', keyframes([
        style({ opacity: '0', transform: '{{ transform }} scale(0.0)', offset: 0 }),
        style({ opacity: '0', transform: '{{ transform }} scale(0.8)', offset: 0.5 }),
        style({ opacity: '1', transform: '{{ transform }} scale(1.0)', offset: 1 })
    ]))
], {
    params: {
        time: '350ms',
        easing: 'cubic-bezier(.7,.31,.72,1.47)',
        display: 'block',
        transform: 'translate(-50%, -50%)'
    }
});

const collapseY = animation([
    style({ height: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapseYWithMargin = animation([
    style({ 'margin-top': '0' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-left': '-100%' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const collapseX = animation([
    style({ width: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandY = animation([
    style({ height: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandYWithMargin = animation([
    style({ 'margin-top': '-100%' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-top': '0' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const expandX = animation([
    style({ width: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapse = trigger('collapse', [
    state('collapsed', style({ height: '0', overflow: 'hidden' })),
    state('expanded', style({ height: '*', overflow: 'hidden' })),
    transition('expanded => collapsed', useAnimation(collapseY)),
    transition('collapsed => expanded', useAnimation(expandY)),
]);
const collapseWithMargin = trigger('collapseWithMargin', [
    state('collapsed', style({ 'margin-top': '-100%' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin), {
        params: { time: '400ms', easing: 'linear' },
    }),
    transition('collapsed => expanded', useAnimation(expandYWithMargin)),
]);
const collapseLinearWithMargin = trigger('collapseLinearWithMargin', [
    state('collapsed', style({ 'margin-top': '-100vh' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin, { params: { time: '200ms', easing: 'linear' } })),
    transition('collapsed => expanded', useAnimation(expandYWithMargin, { params: { time: '250ms', easing: 'linear' } })),
]);

const fadeIn = animation([style({ opacity: '0' }), animate('{{ time}} {{ easing }}', style({ opacity: '1' }))], {
    params: { time: '350ms', easing: 'ease' },
});
const fadeOut = animation([style({ opacity: '1' }), animate('{{ time}} {{ easing }}', style({ opacity: '0' }))], { params: { time: '350ms', easing: 'ease' } });
const fadeInDown = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInUp = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInLeft = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInRight = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutDown = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutUp = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutLeft = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutRight = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });

const fadeAnimation = trigger('fade', [
    transition(':enter', useAnimation(fadeIn)),
    transition(':leave', useAnimation(fadeOut)),
]);
const dialogAnimation = trigger('dialog', [
    transition(':enter', useAnimation(fadeInDown)),
    transition(':leave', useAnimation(fadeOut)),
]);

const slideFromBottom = trigger('slideFromBottom', [
    transition('* <=> *', [
        style({ 'margin-top': '20px', opacity: '0' }),
        animate('0.2s ease-out', style({ opacity: '1', 'margin-top': '0px' })),
    ]),
]);

const toastInOut = trigger('toastInOut', [
    transition('* <=> *', [
        query(':enter', [
            style({ opacity: 0, transform: 'translateY(20px)' }),
            animate('350ms ease', style({ opacity: 1, transform: 'translateY(0)' })),
        ], { optional: true }),
        query(':leave', animate('450ms ease', style({ opacity: 0 })), {
            optional: true,
        }),
    ]),
]);

class BreadcrumbComponent {
    constructor(cdRef, router, routes, subscription, routerEvents) {
        this.cdRef = cdRef;
        this.router = router;
        this.routes = routes;
        this.subscription = subscription;
        this.routerEvents = routerEvents;
        this.segments = [];
    }
    ngOnInit() {
        this.subscription.addOne(this.routerEvents.getNavigationEvents('End').pipe(
        // tslint:disable-next-line:deprecation
        startWith(null), map(() => this.routes.search({ path: getRoutePath(this.router) }))), route => {
            this.segments = [];
            if (route) {
                let node = { parent: route };
                while (node.parent) {
                    node = node.parent;
                    const { parent, children, isLeaf } = node, segment = __rest(node, ["parent", "children", "isLeaf"]);
                    if (!isAdministration(segment))
                        this.segments.unshift(segment);
                }
                this.cdRef.detectChanges();
            }
        });
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-breadcrumb',
                template: "<ol class=\"breadcrumb\" *ngIf=\"segments.length\">\n  <li class=\"breadcrumb-item\">\n    <a routerLink=\"/\"><i class=\"fa fa-home\"></i> </a>\n  </li>\n  <li\n    *ngFor=\"let segment of segments; let last = last\"\n    class=\"breadcrumb-item\"\n    [class.active]=\"last\"\n    aria-current=\"page\"\n  >\n    {{ segment.name | abpLocalization }}\n  </li>\n</ol>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [SubscriptionService]
            },] }
];
BreadcrumbComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Router },
    { type: RoutesService },
    { type: SubscriptionService },
    { type: RouterEvents }
];
function isAdministration(route) {
    return route.name === "AbpUiNavigation::Menu:Administration" /* Administration */;
}

class ButtonComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.buttonId = '';
        this.buttonClass = 'btn btn-primary';
        this.buttonType = 'button';
        this.loading = false;
        this.disabled = false;
        // tslint:disable
        this.click = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        // tslint:enable
        this.abpClick = new EventEmitter();
        this.abpFocus = new EventEmitter();
        this.abpBlur = new EventEmitter();
    }
    get icon() {
        return `${this.loading ? 'fa fa-spinner fa-spin' : this.iconClass || 'd-none'}`;
    }
    ngOnInit() {
        if (this.attributes) {
            Object.keys(this.attributes).forEach(key => {
                this.renderer.setAttribute(this.buttonRef.nativeElement, key, this.attributes[key]);
            });
        }
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-button',
                template: `
    <button
      #button
      [id]="buttonId"
      [attr.type]="buttonType"
      [ngClass]="buttonClass"
      [disabled]="loading || disabled"
      (click.stop)="click.next($event); abpClick.next($event)"
      (focus)="focus.next($event); abpFocus.next($event)"
      (blur)="blur.next($event); abpBlur.next($event)"
    >
      <i [ngClass]="icon" class="mr-1"></i><ng-content></ng-content>
    </button>
  `
            },] }
];
ButtonComponent.ctorParameters = () => [
    { type: Renderer2 }
];
ButtonComponent.propDecorators = {
    buttonId: [{ type: Input }],
    buttonClass: [{ type: Input }],
    buttonType: [{ type: Input }],
    iconClass: [{ type: Input }],
    loading: [{ type: Input }],
    disabled: [{ type: Input }],
    attributes: [{ type: Input }],
    click: [{ type: Output }],
    focus: [{ type: Output }],
    blur: [{ type: Output }],
    abpClick: [{ type: Output }],
    abpFocus: [{ type: Output }],
    abpBlur: [{ type: Output }],
    buttonRef: [{ type: ViewChild, args: ['button', { static: true },] }]
};

function getRandomBackgroundColor(count) {
    const colors = [];
    for (let i = 0; i < count; i++) {
        const r = ((i + 5) * (i + 5) * 474) % 255;
        const g = ((i + 5) * (i + 5) * 1600) % 255;
        const b = ((i + 5) * (i + 5) * 84065) % 255;
        colors.push('rgba(' + r + ', ' + g + ', ' + b + ', 0.7)');
    }
    return colors;
}
const chartJsLoaded$ = new ReplaySubject(1);

class ChartComponent {
    constructor(el, cdRef) {
        this.el = el;
        this.cdRef = cdRef;
        this.options = {};
        this.plugins = [];
        this.responsive = true;
        // tslint:disable-next-line: no-output-on-prefix
        this.onDataSelect = new EventEmitter();
        this.initialized = new BehaviorSubject(this);
        this.onCanvasClick = event => {
            if (this.chart) {
                const element = this.chart.getElementAtEvent(event);
                const dataset = this.chart.getDatasetAtEvent(event);
                if (element && element.length && dataset) {
                    this.onDataSelect.emit({
                        originalEvent: event,
                        element: element[0],
                        dataset,
                    });
                }
            }
        };
        this.initChart = () => {
            const opts = this.options || {};
            opts.responsive = this.responsive;
            // allows chart to resize in responsive mode
            if (opts.responsive && (this.height || this.width)) {
                opts.maintainAspectRatio = false;
            }
            this.chart = new Chart(this.canvas, {
                type: this.type,
                data: this.data,
                options: this.options,
                plugins: this.plugins,
            });
            this.cdRef.detectChanges();
        };
        this.generateLegend = () => {
            if (this.chart) {
                return this.chart.generateLegend();
            }
        };
        this.refresh = () => {
            if (this.chart) {
                this.chart.update();
                this.cdRef.detectChanges();
            }
        };
        this.reinit = () => {
            if (this.chart) {
                this.chart.destroy();
                this.initChart();
            }
        };
    }
    get data() {
        return this._data;
    }
    set data(val) {
        this._data = val;
        this.reinit();
    }
    get canvas() {
        return this.el.nativeElement.children[0].children[0];
    }
    get base64Image() {
        return this.chart.toBase64Image();
    }
    ngAfterViewInit() {
        chartJsLoaded$.subscribe(() => {
            this.testChartJs();
            this.initChart();
            this._initialized = true;
        });
    }
    testChartJs() {
        try {
            // tslint:disable-next-line: no-unused-expression
            Chart;
        }
        catch (error) {
            throw new Error(`Chart is not found. Import the Chart from app.module like shown below:
      import('chart.js');
      `);
        }
    }
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this._initialized = false;
            this.chart = null;
        }
    }
}
ChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-chart',
                template: "<div\n  style=\"position:relative\"\n  [style.width]=\"responsive && !width ? null : width\"\n  [style.height]=\"responsive && !height ? null : height\"\n>\n  <canvas\n    [attr.width]=\"responsive && !width ? null : width\"\n    [attr.height]=\"responsive && !height ? null : height\"\n    (click)=\"onCanvasClick($event)\"\n  ></canvas>\n</div>\n"
            },] }
];
ChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
ChartComponent.propDecorators = {
    type: [{ type: Input }],
    options: [{ type: Input }],
    plugins: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    responsive: [{ type: Input }],
    onDataSelect: [{ type: Output }],
    initialized: [{ type: Output }],
    data: [{ type: Input }]
};

var Confirmation;
(function (Confirmation) {
    let Status;
    (function (Status) {
        Status["confirm"] = "confirm";
        Status["reject"] = "reject";
        Status["dismiss"] = "dismiss";
    })(Status = Confirmation.Status || (Confirmation.Status = {}));
})(Confirmation || (Confirmation = {}));

class ConfirmationComponent {
    constructor() {
        this.confirm = Confirmation.Status.confirm;
        this.reject = Confirmation.Status.reject;
        this.dismiss = Confirmation.Status.dismiss;
    }
    close(status) {
        this.clear(status);
    }
    getIconClass({ severity }) {
        switch (severity) {
            case 'info':
                return 'fa-info-circle';
            case 'success':
                return 'fa-check-circle';
            case 'warning':
                return 'fa-exclamation-triangle';
            case 'error':
                return 'fa-times-circle';
            default:
                return 'fa-question-circle';
        }
    }
}
ConfirmationComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-confirmation',
                template: "<div class=\"confirmation\" *ngIf=\"confirmation$ | async as data\">\n  <div\n    class=\"confirmation-backdrop\"\n    (click)=\"data.options?.dismissible ? close(dismiss) : null\"\n  ></div>\n  <div class=\"confirmation-dialog\">\n    <div class=\"icon-container\" [ngClass]=\"data.severity\" *ngIf=\"data.severity\">\n      <i class=\"fa icon\" [ngClass]=\"getIconClass(data)\"></i>\n    </div>\n    <div class=\"content\">\n      <h1\n        class=\"title\"\n        *ngIf=\"data.title\"\n        [innerHTML]=\"data.title | abpLocalization: data.options?.titleLocalizationParams\"\n      ></h1>\n      <p\n        class=\"message\"\n        *ngIf=\"data.message\"\n        [innerHTML]=\"data.message | abpLocalization: data.options?.messageLocalizationParams\"\n      ></p>\n    </div>\n    <div class=\"footer\">\n      <button\n        id=\"cancel\"\n        class=\"confirmation-button confirmation-button--reject\"\n        [innerHTML]=\"data.options?.cancelText || 'AbpUi::Cancel' | abpLocalization\"\n        *ngIf=\"!data?.options?.hideCancelBtn\"\n        (click)=\"close(reject)\"\n      ></button>\n      <button\n        id=\"confirm\"\n        class=\"confirmation-button confirmation-button--approve\"\n        [innerHTML]=\"data.options?.yesText || 'AbpUi::Yes' | abpLocalization\"\n        *ngIf=\"!data?.options?.hideYesBtn\"\n        (click)=\"close(confirm)\"\n      ></button>\n    </div>\n  </div>\n</div>\n",
                styles: [".confirmation{position:fixed;top:0;right:0;bottom:0;left:0;display:flex;align-items:center;justify-content:center;z-index:1060}.confirmation .confirmation-backdrop{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1061!important}.confirmation .confirmation-dialog{display:flex;flex-direction:column;margin:20px auto;padding:0;width:450px;min-height:300px;z-index:1062!important}@media screen and (max-width:500px){.confirmation .confirmation-dialog{width:90vw}}.confirmation .confirmation-dialog .icon-container{display:flex;align-items:center;justify-content:center;margin:0 0 10px;padding:20px}.confirmation .confirmation-dialog .icon-container .icon{width:100px;height:100px;stroke-width:1;font-size:80px;text-align:center}.confirmation .confirmation-dialog .content{flex-grow:1;display:block}.confirmation .confirmation-dialog .content .title{display:block;margin:0;padding:0;font-size:27px;font-weight:600;text-align:center}.confirmation .confirmation-dialog .content .message{display:block;margin:10px auto;padding:20px;font-size:16px;font-weight:400;text-align:center}.confirmation .confirmation-dialog .footer{display:flex;align-items:center;justify-content:flex-end;margin:10px 0 0;padding:20px;width:100%}.confirmation .confirmation-dialog .footer .confirmation-button{display:inline-block;margin:0 5px;padding:10px 20px;border:none;border-radius:6px;font-size:14px;font-weight:600}"]
            },] }
];

class HttpErrorWrapperComponent {
    constructor(subscription) {
        this.subscription = subscription;
        this.status = 0;
        this.title = 'Oops!';
        this.details = 'Sorry, an error has occured.';
        this.customComponent = null;
        this.hideCloseIcon = false;
        this.isHomeShow = true;
    }
    get statusText() {
        return this.status ? `[${this.status}]` : '';
    }
    ngOnInit() {
        this.backgroundColor =
            snq(() => window.getComputedStyle(document.body).getPropertyValue('background-color')) ||
                '#fff';
    }
    ngAfterViewInit() {
        if (this.customComponent) {
            const customComponentRef = this.cfRes
                .resolveComponentFactory(this.customComponent)
                .create(this.injector);
            customComponentRef.instance.errorStatus = this.status;
            customComponentRef.instance.destroy$ = this.destroy$;
            this.appRef.attachView(customComponentRef.hostView);
            this.containerRef.nativeElement.appendChild(customComponentRef.hostView.rootNodes[0]);
            customComponentRef.changeDetectorRef.detectChanges();
        }
        const keyup$ = fromEvent(document, 'keyup').pipe(debounceTime(150), filter((key) => key && key.key === 'Escape'));
        this.subscription.addOne(keyup$, () => this.destroy());
    }
    ngOnDestroy() { }
    destroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
HttpErrorWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-http-error-wrapper',
                template: "<div\n  #container\n  id=\"abp-http-error-container\"\n  class=\"error\"\n  [style.backgroundColor]=\"backgroundColor\"\n>\n  <button\n    *ngIf=\"!hideCloseIcon\"\n    id=\"abp-close-button\"\n    type=\"button\"\n    class=\"close mr-2\"\n    (click)=\"destroy()\"\n  >\n    <span aria-hidden=\"true\">&times;</span>\n  </button>\n\n  <div *ngIf=\"!customComponent\" class=\"row centered\">\n    <div class=\"col-md-12\">\n      <div class=\"error-template\">\n        <h1>{{ statusText }} {{ title | abpLocalization }}</h1>\n        <div class=\"error-details\">\n          {{ details | abpLocalization }}\n        </div>\n        <div class=\"error-actions\">\n          <a\n            *ngIf=\"isHomeShow\"\n            (click)=\"destroy()\"\n            routerLink=\"/\"\n            class=\"btn btn-primary btn-md mt-2\"\n            ><span class=\"glyphicon glyphicon-home\"></span>\n            {{ { key: '::Menu:Home', defaultValue: 'Home' } | abpLocalization }}\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                providers: [SubscriptionService],
                styles: [".error{position:fixed;top:0;width:100vw;height:100vh;z-index:999999}.centered{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}"]
            },] }
];
HttpErrorWrapperComponent.ctorParameters = () => [
    { type: SubscriptionService }
];
HttpErrorWrapperComponent.propDecorators = {
    containerRef: [{ type: ViewChild, args: ['container', { static: false },] }]
};

class LoaderBarComponent {
    constructor(router, cdRef, subscription, httpWaitService, routerWaitService) {
        this.router = router;
        this.cdRef = cdRef;
        this.subscription = subscription;
        this.httpWaitService = httpWaitService;
        this.routerWaitService = routerWaitService;
        this.containerClass = 'abp-loader-bar';
        this.color = '#77b6ff';
        this.progressLevel = 0;
        this.interval = new Subscription();
        this.timer = new Subscription();
        this.intervalPeriod = 350;
        this.stopDelay = 800;
        this.clearProgress = () => {
            this.progressLevel = 0;
            this.cdRef.detectChanges();
        };
        this.reportProgress = () => {
            if (this.progressLevel < 75) {
                this.progressLevel += 1 + Math.random() * 9;
            }
            else if (this.progressLevel < 90) {
                this.progressLevel += 0.4;
            }
            else if (this.progressLevel < 100) {
                this.progressLevel += 0.1;
            }
            else {
                this.interval.unsubscribe();
            }
            this.cdRef.detectChanges();
        };
    }
    set isLoading(value) {
        this._isLoading = value;
        this.cdRef.detectChanges();
    }
    get isLoading() {
        return this._isLoading;
    }
    get boxShadow() {
        return `0 0 10px rgba(${this.color}, 0.5)`;
    }
    ngOnInit() {
        this.subscribeLoading();
    }
    subscribeLoading() {
        this.subscription.addOne(combineLatest([this.httpWaitService.getLoading$(), this.routerWaitService.getLoading$()]), ([httpLoading, routerLoading]) => {
            if (httpLoading || routerLoading)
                this.startLoading();
            else
                this.stopLoading();
        });
    }
    ngOnDestroy() {
        this.interval.unsubscribe();
    }
    startLoading() {
        if (this.isLoading || !this.interval.closed)
            return;
        this.isLoading = true;
        this.progressLevel = 0;
        this.cdRef.detectChanges();
        this.interval = timer(0, this.intervalPeriod).subscribe(this.reportProgress);
        this.timer.unsubscribe();
    }
    stopLoading() {
        this.interval.unsubscribe();
        this.progressLevel = 100;
        this.isLoading = false;
        if (!this.timer.closed)
            return;
        this.timer = timer(this.stopDelay).subscribe(this.clearProgress);
    }
}
LoaderBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-loader-bar',
                template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow
        }"
      ></div>
    </div>
  `,
                providers: [SubscriptionService],
                styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}"]
            },] }
];
LoaderBarComponent.ctorParameters = () => [
    { type: Router },
    { type: ChangeDetectorRef },
    { type: SubscriptionService },
    { type: HttpWaitService },
    { type: RouterWaitService }
];
LoaderBarComponent.propDecorators = {
    isLoading: [{ type: Input }],
    containerClass: [{ type: Input }],
    color: [{ type: Input }]
};

class LoadingComponent {
    constructor() { }
    ngOnInit() { }
}
LoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-loading',
                template: `
    <div class="abp-loading">
      <i class="fa fa-spinner fa-pulse abp-spinner"></i>
    </div>
  `,
                encapsulation: ViewEncapsulation.None,
                styles: [`
      .abp-loading {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1040;
      }

      .abp-loading .abp-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        font-size: 14px;
        -moz-transform: translateX(-50%) translateY(-50%);
        -o-transform: translateX(-50%) translateY(-50%);
        -ms-transform: translateX(-50%) translateY(-50%);
        -webkit-transform: translateX(-50%) translateY(-50%);
        transform: translateX(-50%) translateY(-50%);
      }
    `]
            },] }
];
LoadingComponent.ctorParameters = () => [];

class ConfirmationService {
    constructor(contentProjectionService) {
        this.contentProjectionService = contentProjectionService;
        this.confirmation$ = new ReplaySubject(1);
        this.clear = (status = Confirmation.Status.dismiss) => {
            this.confirmation$.next();
            this.status$.next(status);
        };
    }
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ConfirmationComponent, {
            confirmation$: this.confirmation$,
            clear: this.clear,
        }));
        setTimeout(() => {
            this.containerComponentRef.changeDetectorRef.detectChanges();
        }, 0);
    }
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    show(message, title, severity, options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        this.confirmation$.next({
            message,
            title,
            severity: severity || 'neutral',
            options,
        });
        this.status$ = new Subject();
        const { dismissible = true } = options;
        if (dismissible)
            this.listenToEscape();
        return this.status$;
    }
    listenToEscape() {
        fromEvent(document, 'keyup')
            .pipe(takeUntil(this.status$), debounceTime(150), filter((key) => key && key.key === 'Escape'))
            .subscribe(_ => {
            this.clear();
        });
    }
}
ConfirmationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConfirmationService_Factory() { return new ConfirmationService(i0.ɵɵinject(i1.ContentProjectionService)); }, token: ConfirmationService, providedIn: "root" });
ConfirmationService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ConfirmationService.ctorParameters = () => [
    { type: ContentProjectionService }
];

// TODO: Should be documented
const SUPPRESS_UNSAVED_CHANGES_WARNING = new InjectionToken('SUPPRESS_UNSAVED_CHANGES_WARNING');

class ModalRefService {
    constructor() {
        this.modalRefs = [];
    }
    register(modal) {
        this.modalRefs.push(modal);
    }
    unregister(modal) {
        const index = this.modalRefs.indexOf(modal);
        if (index > -1) {
            this.modalRefs.splice(index, 1);
        }
    }
    dismissAll(mode) {
        this.modalRefs.forEach(modal => modal.dismiss(mode));
    }
}
ModalRefService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ModalRefService_Factory() { return new ModalRefService(); }, token: ModalRefService, providedIn: "root" });
ModalRefService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];

class ModalComponent {
    constructor(confirmationService, subscription, suppressUnsavedChangesWarningToken, modal, modalRefService) {
        this.confirmationService = confirmationService;
        this.subscription = subscription;
        this.suppressUnsavedChangesWarningToken = suppressUnsavedChangesWarningToken;
        this.modal = modal;
        this.modalRefService = modalRefService;
        /**
         * @deprecated Use centered property of options input instead. To be deleted in v5.0.
         */
        this.centered = false;
        /**
         * @deprecated Use windowClass property of options input instead. To be deleted in v5.0.
         */
        this.modalClass = '';
        /**
         * @deprecated Use size property of options input instead. To be deleted in v5.0.
         */
        this.size = 'lg';
        this.options = {};
        this.suppressUnsavedChangesWarning = this.suppressUnsavedChangesWarningToken;
        this.visibleChange = new EventEmitter();
        this.init = new EventEmitter();
        this.appear = new EventEmitter();
        this.disappear = new EventEmitter();
        this._visible = false;
        this._busy = false;
        this.isConfirmationOpen = false;
        this.destroy$ = new Subject();
        this.modalIdentifier = `modal-${uuid()}`;
        this.toggle$ = new Subject();
        this.initToggleStream();
    }
    get visible() {
        return this._visible;
    }
    set visible(value) {
        if (typeof value !== 'boolean')
            return;
        this.toggle$.next(value);
    }
    get busy() {
        return this._busy;
    }
    set busy(value) {
        if (this.abpSubmit && this.abpSubmit instanceof ButtonComponent) {
            this.abpSubmit.loading = value;
        }
        this._busy = value;
    }
    get modalWindowRef() {
        return document.querySelector(`ngb-modal-window.${this.modalIdentifier}`);
    }
    get isFormDirty() {
        return Boolean(this.modalWindowRef.querySelector('.ng-dirty'));
    }
    ngOnInit() {
        this.modalRefService.register(this);
    }
    dismiss(mode) {
        switch (mode) {
            case 'hard':
                this.visible = false;
                break;
            case 'soft':
                this.close();
                break;
            default:
                break;
        }
    }
    initToggleStream() {
        this.subscription.addOne(this.toggle$.pipe(debounceTime(0), distinctUntilChanged()), value => this.toggle(value));
    }
    toggle(value) {
        var _a;
        this._visible = value;
        this.visibleChange.emit(value);
        if (!value) {
            (_a = this.modalRef) === null || _a === void 0 ? void 0 : _a.dismiss();
            this.disappear.emit();
            this.destroy$.next();
            return;
        }
        setTimeout(() => this.listen(), 0);
        this.modalRef = this.modal.open(this.modalContent, Object.assign(Object.assign({ 
            // TODO: set size to 'lg' when removed the size variable
            size: this.size, centered: this.centered, keyboard: false, scrollable: true, beforeDismiss: () => {
                if (!this.visible)
                    return true;
                this.close();
                return !this.visible;
            } }, this.options), { windowClass: `${this.modalClass} ${this.options.windowClass || ''} ${this.modalIdentifier}` }));
        this.appear.emit();
    }
    ngOnDestroy() {
        this.modalRefService.unregister(this);
        this.toggle(false);
        this.destroy$.next();
    }
    close() {
        if (this.busy)
            return;
        if (this.isFormDirty && !this.suppressUnsavedChangesWarning) {
            if (this.isConfirmationOpen)
                return;
            this.isConfirmationOpen = true;
            this.confirmationService
                .warn('AbpAccount::AreYouSureYouWantToCancelEditingWarningMessage', 'AbpAccount::AreYouSure', { dismissible: false })
                .subscribe((status) => {
                this.isConfirmationOpen = false;
                if (status === Confirmation.Status.confirm) {
                    this.visible = false;
                }
            });
        }
        else {
            this.visible = false;
        }
    }
    listen() {
        fromEvent(this.modalWindowRef, 'keyup')
            .pipe(takeUntil(this.destroy$), debounceTime(150), filter((key) => key && key.key === 'Escape'))
            .subscribe(() => this.close());
        fromEvent(window, 'beforeunload')
            .pipe(takeUntil(this.destroy$))
            .subscribe(event => {
            event.preventDefault();
            if (this.isFormDirty && !this.suppressUnsavedChangesWarning) {
                event.returnValue = true;
            }
            else {
                delete event.returnValue;
            }
        });
        setTimeout(() => {
            if (!this.abpClose)
                return;
            this.warnForDeprecatedClose();
            fromEvent(this.abpClose.nativeElement, 'click')
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.close());
        }, 0);
        this.init.emit();
    }
    warnForDeprecatedClose() {
        if (isDevMode()) {
            console.warn('Please use abpClose directive instead of #abpClose template variable. #abpClose will be removed in v5.0');
        }
    }
}
ModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-modal',
                template: "<ng-content></ng-content>\n\n<ng-template #modalContent let-modal>\n  <div id=\"abp-modal-header\" class=\"modal-header\">\n    <ng-container *ngTemplateOutlet=\"abpHeader\"></ng-container>\n    \u200B\n    <button\n      id=\"abp-modal-close-button\"\n      type=\"button\"\n      class=\"close\"\n      aria-label=\"Close\"\n      (click)=\"modal.dismiss()\"\n    >\n      <span aria-hidden=\"true\">&times;</span>\n    </button>\n  </div>\n  <div id=\"abp-modal-body\" class=\"modal-body\">\n    <ng-container *ngTemplateOutlet=\"abpBody\"></ng-container>\n  </div>\n  <div *ngIf=\"abpFooter\" id=\"abp-modal-footer\" class=\"modal-footer\">\n    <ng-container *ngTemplateOutlet=\"abpFooter\"></ng-container>\n  </div>\n</ng-template>\n",
                providers: [SubscriptionService],
                styles: [".modal.show{display:block!important}.modal-backdrop{opacity:.8}.modal::-webkit-scrollbar{width:7px}.modal::-webkit-scrollbar-track{background:#ddd}.modal::-webkit-scrollbar-thumb{background:#8a8686}.modal-dialog{z-index:1050}"]
            },] }
];
ModalComponent.ctorParameters = () => [
    { type: ConfirmationService },
    { type: SubscriptionService },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [SUPPRESS_UNSAVED_CHANGES_WARNING,] }] },
    { type: NgbModal },
    { type: ModalRefService }
];
ModalComponent.propDecorators = {
    centered: [{ type: Input }],
    modalClass: [{ type: Input }],
    size: [{ type: Input }],
    visible: [{ type: Input }],
    busy: [{ type: Input }],
    options: [{ type: Input }],
    suppressUnsavedChangesWarning: [{ type: Input }],
    modalContent: [{ type: ViewChild, args: ['modalContent',] }],
    abpHeader: [{ type: ContentChild, args: ['abpHeader', { static: false },] }],
    abpBody: [{ type: ContentChild, args: ['abpBody', { static: false },] }],
    abpFooter: [{ type: ContentChild, args: ['abpFooter', { static: false },] }],
    abpSubmit: [{ type: ContentChild, args: [ButtonComponent, { static: false, read: ButtonComponent },] }],
    abpClose: [{ type: ContentChild, args: ['abpClose', { static: false, read: ElementRef },] }],
    visibleChange: [{ type: Output }],
    init: [{ type: Output }],
    appear: [{ type: Output }],
    disappear: [{ type: Output }]
};

class ModalCloseDirective {
    constructor(modal) {
        this.modal = modal;
        if (!modal) {
            console.error('Please use abpClose within an abp-modal');
        }
    }
    onClick() {
        var _a;
        (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();
    }
}
ModalCloseDirective.decorators = [
    { type: Directive, args: [{ selector: '[abpClose]' },] }
];
ModalCloseDirective.ctorParameters = () => [
    { type: ModalComponent, decorators: [{ type: Optional }] }
];
ModalCloseDirective.propDecorators = {
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @deprecated To be deleted in v5.0. Use ngx-datatale instead.
 */
class SortOrderIconComponent {
    constructor() {
        this.orderChange = new EventEmitter();
        this.selectedSortKeyChange = new EventEmitter();
    }
    set selectedSortKey(value) {
        this._selectedSortKey = value;
        this.selectedSortKeyChange.emit(value);
    }
    get selectedSortKey() {
        return this._selectedSortKey;
    }
    set order(value) {
        this._order = value;
        this.orderChange.emit(value);
    }
    get order() {
        return this._order;
    }
    get icon() {
        if (this.selectedSortKey === this.sortKey)
            return `sorting_${this.order}`;
        else
            return 'sorting';
    }
    sort(key) {
        this.selectedSortKey = key;
        switch (this.order) {
            case '':
                this.order = 'asc';
                this.orderChange.emit('asc');
                break;
            case 'asc':
                this.order = 'desc';
                this.orderChange.emit('desc');
                break;
            case 'desc':
                this.order = '';
                this.orderChange.emit('');
                break;
        }
    }
}
SortOrderIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-sort-order-icon',
                template: "<div class=\"float-right {{ iconClass }}\">\n  <span class=\"{{ icon }}\"></span>\n</div>\n"
            },] }
];
SortOrderIconComponent.propDecorators = {
    sortKey: [{ type: Input }],
    selectedSortKey: [{ type: Input }],
    order: [{ type: Input }],
    orderChange: [{ type: Output }],
    selectedSortKeyChange: [{ type: Output }],
    iconClass: [{ type: Input }]
};

class TableEmptyMessageComponent {
    constructor() {
        this.colspan = 2;
        this.localizationResource = 'AbpAccount';
        this.localizationProp = 'NoDataAvailableInDatatable';
    }
    get emptyMessage() {
        return this.message || `${this.localizationResource}::${this.localizationProp}`;
    }
}
TableEmptyMessageComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: '[abp-table-empty-message]',
                template: `
    <td class="text-center" [attr.colspan]="colspan">
      {{ emptyMessage | abpLocalization }}
    </td>
  `
            },] }
];
TableEmptyMessageComponent.propDecorators = {
    colspan: [{ type: Input }],
    message: [{ type: Input }],
    localizationResource: [{ type: Input }],
    localizationProp: [{ type: Input }]
};

/**
 *
 * @deprecated To be deleted in v5.0. Use ngx-datatale instead.
 */
class TableComponent {
    constructor() {
        this.bodyScrollLeft = 0;
        this.page = 1;
        this.trackingProp = 'id';
        this.emptyMessage = 'AbpAccount::NoDataAvailableInDatatable';
        this.pageChange = new EventEmitter();
        this.trackByFn = (_, value) => {
            return typeof value === 'object' ? value[this.trackingProp] || value : value;
        };
    }
    get totalRecords() {
        return this._totalRecords || this.value.length;
    }
    set totalRecords(newValue) {
        if (newValue < 0)
            this._totalRecords = 0;
        this._totalRecords = newValue;
    }
    get totalPages() {
        if (!this.rows) {
            return;
        }
        return Math.ceil(this.totalRecords / this.rows);
    }
    get slicedValue() {
        if (!this.rows || this.rows >= this.value.length) {
            return this.value;
        }
        const start = (this.page - 1) * this.rows;
        return this.value.slice(start, start + this.rows);
    }
    ngOnInit() {
        this.marginCalculator = document.body.dir === 'rtl' ? rtlCalculator : ltrCalculator;
    }
}
TableComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-table',
                template: "<div #wrapper class=\"ui-table ui-widget\">\n  <div class=\"ui-table-wrapper\">\n    <ng-container\n      *ngTemplateOutlet=\"scrollable ? scrollableTemplate : defaultTemplate\"\n    ></ng-container>\n    <div class=\"pagination-wrapper\">\n      <ngb-pagination\n        [class.op-0]=\"!totalPages\"\n        [collectionSize]=\"totalPages\"\n        [pageSize]=\"1\"\n        [page]=\"page\"\n        (pageChange)=\"pageChange.emit($event)\"\n        [maxSize]=\"3\"\n        [rotate]=\"true\"\n      ></ngb-pagination>\n    </div>\n  </div>\n</div>\n\n<ng-template #scrollableTemplate>\n  <div class=\"ui-table-scrollable-wrapper\">\n    <div class=\"ui-table-scrollable-view\"></div>\n    <div class=\"ui-table-scrollable-header ui-widget-header\">\n      <div #header class=\"ui-table-scrollable-header-box\">\n        <table class=\"ui-table-scrollable-header-table\">\n          <ng-container *ngTemplateOutlet=\"colGroup\"></ng-container>\n          <ng-container *ngTemplateOutlet=\"head\"></ng-container>\n          <tbody></tbody>\n        </table>\n      </div>\n    </div>\n    <div\n      #scrollableBody\n      (scroll)=\"header.style.margin = marginCalculator(scrollableBody)\"\n      class=\"ui-table-scrollable-body\"\n      [style.max-height]=\"scrollHeight\"\n    >\n      <table class=\"ui-table-scrollable-body-table\">\n        <ng-container *ngTemplateOutlet=\"colGroup\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n      </table>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #defaultTemplate>\n  <table>\n    <ng-container *ngTemplateOutlet=\"colGroup\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"head\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n  </table>\n</ng-template>\n\n<ng-template #colGroup>\n  <ng-container *ngTemplateOutlet=\"colgroupTemplate\"></ng-container>\n</ng-template>\n\n<ng-template #head>\n  <thead class=\"ui-table-thead\">\n    <ng-container *ngTemplateOutlet=\"headerTemplate\"></ng-container>\n  </thead>\n</ng-template>\n\n<ng-template #body>\n  <tbody class=\"ui-table-tbody\" *ngIf=\"value && value.length; else emptyTemplate\">\n    <ng-template\n      #bodyTemplateWrapper\n      *ngFor=\"let val of slicedValue; let index = index; trackBy: trackByFn\"\n      [ngTemplateOutlet]=\"bodyTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: val, rowIndex: index }\"\n    ></ng-template>\n  </tbody>\n</ng-template>\n\n<ng-template #emptyTemplate>\n  <caption class=\"ui-table-empty\">\n    {{\n      emptyMessage | abpLocalization\n    }}\n  </caption>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".ui-table{position:relative}.ui-table .ui-table-tbody>tr:hover,.ui-table .ui-table-tbody>tr:nth-child(2n):hover{filter:brightness(90%)}.ui-table .ui-table-empty{padding:20px 0;text-align:center;border:1px solid #e0e0e0;border-top:0 solid #e0e0e0}.ui-table .ui-table-caption,.ui-table .ui-table-summary{background-color:#f4f4f4;color:#333;border:1px solid #c8c8c8;padding:.571em 1em}.ui-table .ui-table-caption,.ui-table .ui-table-summary{font-weight:700}.ui-table .ui-table-thead>tr>th{padding:.571em .857em;border:1px solid #c8c8c8;font-weight:700;color:#333;background-color:#f4f4f4}.ui-table .ui-table-tbody>tr>td{padding:.571em .857em}.ui-table .ui-table-tfoot>tr>td{padding:.571em .857em;border:1px solid #c8c8c8;font-weight:700;color:#333;background-color:#fff}.ui-table .ui-sortable-column{transition:box-shadow .2s}.ui-table .ui-sortable-column:focus{outline:0 none;outline-offset:0;box-shadow:inset 0 0 0 .2em #8dcdff}.ui-table .ui-sortable-column .ui-sortable-column-icon{color:#848484}.ui-table .ui-sortable-column:not(.ui-state-highlight):hover{background-color:#e0e0e0;color:#333}.ui-table .ui-sortable-column:not(.ui-state-highlight):hover .ui-sortable-column-icon{color:#333}.ui-table .ui-sortable-column.ui-state-highlight{background-color:#007ad9;color:#fff}.ui-table .ui-sortable-column.ui-state-highlight .ui-sortable-column-icon{color:#fff}.ui-table .ui-editable-column input{font-size:14px;font-family:Open Sans,Helvetica Neue,sans-serif}.ui-table .ui-editable-column input:focus{outline:1px solid #007ad9;outline-offset:2px}.ui-table .ui-table-tbody>tr{background-color:#fff;color:#333}.ui-table .ui-table-tbody>tr>td{background-color:inherit;border:1px solid #c8c8c8}.ui-table .ui-table-tbody>tr.ui-state-highlight{background-color:#007ad9;color:#fff}.ui-table .ui-table-tbody>tr.ui-state-highlight a{color:#fff}.ui-table .ui-table-tbody>tr.ui-contextmenu-selected{background-color:#007ad9;color:#fff}.ui-table .ui-table-tbody>tr.ui-table-dragpoint-top>td{box-shadow:inset 0 2px 0 0 #007ad9}.ui-table .ui-table-tbody>tr.ui-table-dragpoint-bottom>td{box-shadow:inset 0 -2px 0 0 #007ad9}.ui-table .ui-table-tbody>tr:nth-child(2n){background-color:#f9f9f9}.ui-table .ui-table-tbody>tr:nth-child(2n).ui-state-highlight{background-color:#007ad9;color:#fff}.ui-table .ui-table-tbody>tr:nth-child(2n).ui-state-highlight a{color:#fff}.ui-table .ui-table-tbody>tr:nth-child(2n).ui-contextmenu-selected{background-color:#007ad9;color:#fff}.ui-table.ui-table-hoverable-rows .ui-table-tbody>tr.ui-selectable-row:not(.ui-state-highlight):not(.ui-contextmenu-selected):hover{cursor:pointer;background-color:#eaeaea;color:#333}.ui-table .ui-column-resizer-helper{background-color:#007ad9}@media screen and (max-width:40em){.ui-table.ui-table-responsive .ui-table-tbody>tr>td{border:0}}.ui-table table{border-collapse:collapse;width:100%;table-layout:fixed}.ui-table .ui-table-tbody>tr>td,.ui-table .ui-table-tfoot>tr>td,.ui-table .ui-table-thead>tr>th{padding:.571em .857em}.ui-table .ui-sortable-column{cursor:pointer}.ui-table p-sorticon{vertical-align:middle}.ui-table .ui-table-auto-layout>.ui-table-wrapper{overflow-x:auto}.ui-table .ui-table-auto-layout>.ui-table-wrapper>table{table-layout:auto}.ui-table .ui-table-caption,.ui-table .ui-table-summary{padding:.25em .5em;text-align:center;font-weight:700}.ui-table .ui-table-caption{border-bottom:0}.ui-table .ui-table-summary{border-top:0}.ui-table .ui-table-scrollable-wrapper{position:relative}.ui-table .ui-table-scrollable-footer,.ui-table .ui-table-scrollable-header{overflow:hidden;border:0}.ui-table .ui-table-scrollable-body{overflow:auto;position:relative}.ui-table .ui-table-virtual-table{position:absolute}.ui-table .ui-table-loading-virtual-table{display:none}.ui-table .ui-table-frozen-view .ui-table-scrollable-body{overflow:hidden}.ui-table .ui-table-frozen-view>.ui-table-scrollable-body>table>.ui-table-tbody>tr>td:last-child{border-right:0}.ui-table .ui-table-unfrozen-view{position:absolute;top:0}.ui-table .ui-table-resizable>.ui-table-wrapper{overflow-x:auto}.ui-table .ui-table-resizable .ui-table-tbody>tr>td,.ui-table .ui-table-resizable .ui-table-tfoot>tr>td,.ui-table .ui-table-resizable .ui-table-thead>tr>th{overflow:hidden}.ui-table .ui-table-resizable .ui-resizable-column{background-clip:padding-box;position:relative}.ui-table .ui-table-resizable-fit .ui-resizable-column:last-child .ui-column-resizer{display:none}.ui-table .ui-column-resizer{display:block;position:absolute!important;top:0;right:0;margin:0;width:.5em;height:100%;padding:0;cursor:col-resize;border:1px solid transparent}.ui-table .ui-column-resizer-helper{width:1px;position:absolute;z-index:10;display:none}.ui-table .ui-table-tbody>tr>td.ui-editing-cell{padding:0}.ui-table .ui-table-tbody>tr>td.ui-editing-cell p-celleditor>*{width:100%}.ui-table .ui-table-reorder-indicator-down,.ui-table .ui-table-reorder-indicator-up{position:absolute;display:none}.ui-table .ui-table-responsive .ui-table-tbody>tr>td .ui-column-title{display:none}@media screen and (max-width:40em){.ui-table .ui-table-responsive .ui-table-tfoot>tr>td,.ui-table .ui-table-responsive .ui-table-thead>tr>th,.ui-table .ui-table-responsive colgroup{display:none!important}.ui-table .ui-table-responsive .ui-table-tbody>tr>td{text-align:left;display:block;border:0;width:100%!important;box-sizing:border-box;float:left;clear:left}.ui-table .ui-table-responsive .ui-table-tbody>tr>td .ui-column-title{padding:.4em;min-width:30%;display:inline-block;margin:-.4em 1em -.4em -.4em;font-weight:700}}.ui-table .ui-widget{font-family:Open Sans,Helvetica Neue,sans-serif;font-size:14px;text-decoration:none}.ui-table .page-item.disabled .page-link,.ui-table .page-link{background-color:transparent;border:none}.ui-table .page-item.disabled .page-link{box-shadow:none}.ui-table .pagination{margin-bottom:0}.ui-table .pagination-wrapper{display:flex;justify-content:center;border-top:0;padding:0}.ui-table .op-0{opacity:0}"]
            },] }
];
TableComponent.propDecorators = {
    value: [{ type: Input }],
    headerTemplate: [{ type: Input }],
    bodyTemplate: [{ type: Input }],
    colgroupTemplate: [{ type: Input }],
    scrollHeight: [{ type: Input }],
    scrollable: [{ type: Input }],
    rows: [{ type: Input }],
    page: [{ type: Input }],
    trackingProp: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    pageChange: [{ type: Output }],
    wrapperRef: [{ type: ViewChild, args: ['wrapper', { read: ElementRef },] }],
    totalRecords: [{ type: Input }]
};
function ltrCalculator(div) {
    return `0 auto 0 -${div.scrollLeft}px`;
}
function rtlCalculator(div) {
    return `0 ${-(div.scrollWidth - div.clientWidth - div.scrollLeft)}px 0 auto`;
}

class ToastContainerComponent {
    constructor() {
        this.toasts = [];
        this.right = '30px';
        this.bottom = '30px';
    }
    ngOnInit() {
        this.toasts$.subscribe(toasts => {
            this.toasts = this.toastKey
                ? toasts.filter(t => {
                    return t.options && t.options.containerKey !== this.toastKey;
                })
                : toasts;
        });
    }
    trackByFunc(index, toast) {
        if (!toast)
            return null;
        return toast.options.id;
    }
}
ToastContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-toast-container',
                template: "<div\n  class=\"abp-toast-container\"\n  [style.top]=\"top || 'auto'\"\n  [style.right]=\"right || 'auto'\"\n  [style.bottom]=\"bottom || 'auto'\"\n  [style.left]=\"left || 'auto'\"\n  [style.display]=\"toasts.length ? 'flex' : 'none'\"\n  [@toastInOut]=\"toasts.length\"\n>\n  <abp-toast [toast]=\"toast\" *ngFor=\"let toast of toasts; trackBy: trackByFunc\"></abp-toast>\n</div>\n",
                animations: [toastInOut],
                styles: [".abp-toast-container{position:fixed;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;min-width:350px;min-height:80px;z-index:1900}.abp-toast-container.new-on-top{flex-direction:column-reverse}"]
            },] }
];
ToastContainerComponent.propDecorators = {
    top: [{ type: Input }],
    right: [{ type: Input }],
    bottom: [{ type: Input }],
    left: [{ type: Input }],
    toastKey: [{ type: Input }]
};

class ToasterService {
    constructor(contentProjectionService) {
        this.contentProjectionService = contentProjectionService;
        this.toasts$ = new ReplaySubject(1);
        this.lastId = -1;
        this.toasts = [];
    }
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ToastContainerComponent, { toasts$: this.toasts$ }));
        this.containerComponentRef.changeDetectorRef.detectChanges();
    }
    /**
     * Creates an info toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    /**
     * Creates a success toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    /**
     * Creates a warning toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    /**
     * Creates an error toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    /**
     * Creates a toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param severity Sets color of the toast. "success", "warning" etc.
     * @param options Spesific style or structural options for individual toast
     */
    show(message, title = null, severity = 'neutral', options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        const id = ++this.lastId;
        this.toasts.push({
            message,
            title,
            severity,
            options: Object.assign({ closable: true, id }, options),
        });
        this.toasts$.next(this.toasts);
        return id;
    }
    /**
     * Removes the toast with given id.
     * @param id ID of the toast to be removed.
     */
    remove(id) {
        this.toasts = this.toasts.filter(toast => snq(() => toast.options.id) !== id);
        this.toasts$.next(this.toasts);
    }
    /**
     * Removes all open toasts at once.
     */
    clear(containerKey) {
        this.toasts = !containerKey
            ? []
            : this.toasts.filter(toast => snq(() => toast.options.containerKey) !== containerKey);
        this.toasts$.next(this.toasts);
    }
}
ToasterService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ToasterService_Factory() { return new ToasterService(i0.ɵɵinject(i1.ContentProjectionService)); }, token: ToasterService, providedIn: "root" });
ToasterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ToasterService.ctorParameters = () => [
    { type: ContentProjectionService }
];

class ToastComponent {
    constructor(toasterService) {
        this.toasterService = toasterService;
    }
    get severityClass() {
        if (!this.toast || !this.toast.severity)
            return '';
        return `abp-toast-${this.toast.severity}`;
    }
    get iconClass() {
        switch (this.toast.severity) {
            case 'success':
                return 'fa-check-circle';
            case 'info':
                return 'fa-info-circle';
            case 'warning':
                return 'fa-exclamation-triangle';
            case 'error':
                return 'fa-times-circle';
            default:
                return 'fa-exclamation-circle';
        }
    }
    ngOnInit() {
        if (snq(() => this.toast.options.sticky))
            return;
        const timeout = snq(() => this.toast.options.life) || 5000;
        setTimeout(() => {
            this.close();
        }, timeout);
    }
    close() {
        this.toasterService.remove(this.toast.options.id);
    }
    tap() {
        var _a;
        if ((_a = this.toast.options) === null || _a === void 0 ? void 0 : _a.tapToDismiss)
            this.close();
    }
}
ToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-toast',
                template: "<div class=\"abp-toast\" [ngClass]=\"severityClass\" (click)=\"tap()\">\n  <div class=\"abp-toast-icon\">\n    <i class=\"fa icon\" [ngClass]=\"iconClass\"></i>\n  </div>\n  <div class=\"abp-toast-content\">\n    <button class=\"abp-toast-close-button\" (click)=\"close()\" *ngIf=\"toast.options.closable\">\n      <i class=\"fa fa-times\"></i>\n    </button>\n    <div class=\"abp-toast-title\">\n      {{ toast.title | abpLocalization: toast.options?.titleLocalizationParams }}\n    </div>\n    <p\n      class=\"abp-toast-message\"\n      [innerHTML]=\"toast.message | abpLocalization: toast.options?.messageLocalizationParams\"\n    ></p>\n  </div>\n</div>\n",
                styles: [".abp-toast{display:grid;grid-template-columns:50px 1fr;gap:10px;margin:5px 0;padding:10px;border-radius:0;width:350px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:9999;border:2px solid #f0f0f0;background-color:#f0f0f0;color:#000;box-shadow:0 0 10px -5px rgba(0,0,0,.4);opacity:1}.abp-toast:hover{border:2px solid #e3e3e3;background-color:#e3e3e3;box-shadow:0 0 15px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-success{border:2px solid #51a351;background-color:#51a351;color:#fff;box-shadow:0 0 10px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-success:hover{border:2px solid #499249;background-color:#499249;box-shadow:0 0 15px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-info{border:2px solid #2f96b4;background-color:#2f96b4;color:#fff;box-shadow:0 0 10px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-info:hover{border:2px solid #2a85a0;background-color:#2a85a0;box-shadow:0 0 15px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-warning{border:2px solid #f89406;background-color:#f89406;color:#fff;box-shadow:0 0 10px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-warning:hover{border:2px solid #df8505;background-color:#df8505;box-shadow:0 0 15px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-error{border:2px solid #bd362f;background-color:#bd362f;color:#fff;box-shadow:0 0 10px -5px rgba(0,0,0,.4)}.abp-toast.abp-toast-error:hover{border:2px solid #a9302a;background-color:#a9302a;box-shadow:0 0 15px -5px rgba(0,0,0,.4)}.abp-toast .abp-toast-icon{display:flex;align-items:center;justify-content:center}.abp-toast .abp-toast-icon .icon{font-size:36px}.abp-toast .abp-toast-content{position:relative}.abp-toast .abp-toast-content .abp-toast-close-button{position:absolute;top:0;right:0;display:flex;align-items:center;justify-content:center;margin:0;padding:0 5px 0 0;width:25px;height:25px;border:none;border-radius:50%;background:transparent;color:inherit}.abp-toast .abp-toast-content .abp-toast-close-button:focus{outline:none}.abp-toast .abp-toast-content .abp-toast-title{margin:0;padding:0;font-size:1rem;font-weight:600}.abp-toast .abp-toast-content .abp-toast-message{margin:0;padding:0;max-width:240px}"]
            },] }
];
ToastComponent.ctorParameters = () => [
    { type: ToasterService }
];
ToastComponent.propDecorators = {
    toast: [{ type: Input }]
};

var styles = `
.is-invalid .form-control {
  border-color: #dc3545;
  border-style: solid !important;
  padding-right: calc(1.5em + .75rem);
  background-image: url(data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e);
  background-repeat: no-repeat;
  background-position: right calc(.375em + .1875rem) center;
  background-size: calc(.75em + .375rem) calc(.75em + .375rem);
}

.is-invalid .invalid-feedback,
.is-invalid + * .invalid-feedback {
  display: block;
}

.data-tables-filter {
  text-align: right;
}

[dir=rtl] .data-tables-filter {
  text-align: left;
}

.pointer {
  cursor: pointer;
}

.navbar .dropdown-submenu a::after {
  transform: rotate(-90deg);
  position: absolute;
  right: 16px;
  top: 18px;
}

.navbar .dropdown-menu {
  min-width: 215px;
}

.datatable-scroll {
  margin-bottom: 5px !important;
  width: unset !important;
}

.ui-table-scrollable-body::-webkit-scrollbar {
  height: 5px !important;
  width: 5px !important;
}

.ui-table-scrollable-body::-webkit-scrollbar-track {
  background: #ddd;
}

.ui-table-scrollable-body::-webkit-scrollbar-thumb {
  background: #8a8686;
}

.abp-ellipsis-inline {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.abp-ellipsis {
  overflow: hidden !important;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ui-widget-overlay {
  z-index: 1000;
}

.color-white {
  color: #FFF !important;
}

.custom-checkbox > label {
  cursor: pointer;
}

/* <animations */

.fade-in-top {
  animation: fadeInTop 0.2s ease-in-out;
}

.fade-out-top {
  animation: fadeOutTop 0.2s ease-in-out;
}

.abp-collapsed-height {
  -moz-transition: max-height linear 0.35s;
  -ms-transition: max-height linear 0.35s;
  -o-transition: max-height linear 0.35s;
  -webkit-transition: max-height linear 0.35s;
  overflow:hidden;
  transition:max-height 0.35s linear;
  height:auto;
  max-height: 0;
}

.abp-mh-25 {
  max-height: 25vh;
}

.abp-mh-50 {
  transition:max-height 0.65s linear;
  max-height: 50vh;
}

.abp-mh-75 {
  transition:max-height 0.85s linear;
  max-height: 75vh;
}

.abp-mh-100 {
  transition:max-height 1s linear;
  max-height: 100vh;
}

[class^="sorting"] {
  opacity: .3;
  cursor: pointer;
}
[class^="sorting"]:before {
  right: 0.5rem;
  content: "↑";
}
[class^="sorting"]:after {
  right: 0.5rem;
  content: "↓";
}

.sorting_desc {
  opacity: 1;
}
.sorting_desc:before {
  opacity: .3;
}

.sorting_asc {
  opacity: 1;
}
.sorting_asc:after {
  opacity: .3;
}
.ngx-datatable.material {
  box-shadow: none;
}
ngb-typeahead-window, ngb-typeahead-window.dropdown-menu {
  max-height: 25em;
  overflow-y: scroll !important;
  z-index: 1050;
}

@keyframes fadeInTop {
  from {
    transform: translateY(-5px);
    opacity: 0;
  }

  to {
    transform: translateY(0px);
    opacity: 1;
  }
}

@keyframes fadeOutTop {
  to {
    transform: translateY(-5px);
    opacity: 0;
  }
}

/* </animations */

`;
const BOOTSTRAP = 'bootstrap-{{dir}}.min.css';

const DEFAULT_VALIDATION_BLUEPRINTS = {
    creditCard: 'AbpValidation::ThisFieldIsNotAValidCreditCardNumber.',
    email: 'AbpValidation::ThisFieldIsNotAValidEmailAddress.',
    invalid: 'AbpValidation::ThisFieldIsNotValid.',
    max: 'AbpValidation::ThisFieldMustBeBetween{0}And{1}[{{ min }},{{ max }}]',
    maxlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMaximumLengthOf{0}[{{ requiredLength }}]',
    min: 'AbpValidation::ThisFieldMustBeBetween{0}And{1}[{{ min }},{{ max }}]',
    minlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMinimumLengthOf{0}[{{ requiredLength }}]',
    ngbDate: 'AbpValidation::ThisFieldIsNotValid.',
    passwordMismatch: 'AbpIdentity::Volo.Abp.Identity:PasswordConfirmationFailed',
    range: 'AbpValidation::ThisFieldMustBeBetween{0}And{1}[{{ min }},{{ max }}]',
    required: 'AbpValidation::ThisFieldIsRequired.',
    url: 'AbpValidation::ThisFieldIsNotAValidFullyQualifiedHttpHttpsOrFtpUrl',
};

class LoadingDirective {
    constructor(elRef, vcRef, cdRes, injector, renderer) {
        this.elRef = elRef;
        this.vcRef = vcRef;
        this.cdRes = cdRes;
        this.injector = injector;
        this.renderer = renderer;
        this.position = 'relative';
        this.delay = 0;
    }
    get loading() {
        return this._loading;
    }
    set loading(newValue) {
        setTimeout(() => {
            if (!newValue && this.timerSubscription) {
                this.timerSubscription.unsubscribe();
                this.timerSubscription = null;
                this._loading = newValue;
                if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                return;
            }
            this.timerSubscription = timer(this.delay)
                .pipe(take(1))
                .subscribe(() => {
                if (!this.componentRef) {
                    this.componentRef = this.cdRes
                        .resolveComponentFactory(LoadingComponent)
                        .create(this.injector);
                }
                if (newValue && !this.rootNode) {
                    this.rootNode = this.componentRef.hostView.rootNodes[0];
                    this.targetElement.appendChild(this.rootNode);
                }
                else if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                this._loading = newValue;
                this.timerSubscription = null;
            });
        }, 0);
    }
    ngOnInit() {
        if (!this.targetElement) {
            const { offsetHeight, offsetWidth } = this.elRef.nativeElement;
            if (!offsetHeight && !offsetWidth && this.elRef.nativeElement.children.length) {
                this.targetElement = this.elRef.nativeElement.children[0];
            }
            else {
                this.targetElement = this.elRef.nativeElement;
            }
        }
    }
    ngOnDestroy() {
        if (this.timerSubscription) {
            this.timerSubscription.unsubscribe();
        }
    }
}
LoadingDirective.decorators = [
    { type: Directive, args: [{ selector: '[abpLoading]' },] }
];
LoadingDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: Renderer2 }
];
LoadingDirective.propDecorators = {
    position: [{ type: HostBinding, args: ['style.position',] }],
    loading: [{ type: Input, args: ['abpLoading',] }],
    targetElement: [{ type: Input, args: ['abpLoadingTargetElement',] }],
    delay: [{ type: Input, args: ['abpLoadingDelay',] }]
};

class NgxDatatableDefaultDirective {
    constructor(table, document) {
        this.table = table;
        this.document = document;
        this.subscription = new Subscription();
        this.resizeDiff = 0;
        this.class = 'material bordered';
        this.table.columnMode = ColumnMode.force;
        this.table.footerHeight = 50;
        this.table.headerHeight = 50;
        this.table.rowHeight = 'auto';
        this.table.scrollbarH = true;
        this.table.virtualization = false;
    }
    get classes() {
        return `ngx-datatable ${this.class}`;
    }
    fixHorizontalGap(scroller) {
        const { body, documentElement } = this.document;
        if (documentElement.scrollHeight !== documentElement.clientHeight) {
            if (this.resizeDiff === 0) {
                this.resizeDiff = window.innerWidth - body.offsetWidth;
                scroller.scrollWidth -= this.resizeDiff;
            }
        }
        else {
            scroller.scrollWidth += this.resizeDiff;
            this.resizeDiff = 0;
        }
    }
    fixStyleOnWindowResize() {
        // avoided @HostListener('window:resize') in favor of performance
        const subscription = fromEvent(window, 'resize')
            .pipe(debounceTime(500))
            .subscribe(() => {
            const { scroller } = this.table.bodyComponent;
            if (!scroller)
                return;
            this.fixHorizontalGap(scroller);
        });
        this.subscription.add(subscription);
    }
    ngAfterViewInit() {
        this.fixStyleOnWindowResize();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
NgxDatatableDefaultDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line
                selector: 'ngx-datatable[default]',
                exportAs: 'ngxDatatableDefault',
            },] }
];
NgxDatatableDefaultDirective.ctorParameters = () => [
    { type: DatatableComponent },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NgxDatatableDefaultDirective.propDecorators = {
    class: [{ type: Input }],
    classes: [{ type: HostBinding, args: ['class',] }]
};

const defaultNgxDatatableMessages = {
    emptyMessage: 'AbpUi::NoDataAvailableInDatatable',
    totalMessage: 'AbpUi::Total',
    selectedMessage: 'AbpUi::Selected',
};
const NGX_DATATABLE_MESSAGES = new InjectionToken('NGX_DATATABLE_MESSAGES');

class NgxDatatableListDirective {
    constructor(table, cdRef, localizationService, ngxDatatableMessages) {
        this.table = table;
        this.cdRef = cdRef;
        this.localizationService = localizationService;
        this.ngxDatatableMessages = ngxDatatableMessages;
        this.subscription = new Subscription();
        this.querySubscription = new Subscription();
        this.setInitialValues();
    }
    setInitialValues() {
        this.table.externalPaging = true;
        this.table.externalSorting = true;
        const { emptyMessage, selectedMessage, totalMessage } = this.ngxDatatableMessages || defaultNgxDatatableMessages;
        this.table.messages = {
            emptyMessage: this.localizationService.instant(emptyMessage),
            totalMessage: this.localizationService.instant(totalMessage),
            selectedMessage: this.localizationService.instant(selectedMessage),
        };
    }
    subscribeToPage() {
        const sub = this.table.page.subscribe(({ offset }) => {
            this.list.page = offset;
            this.table.offset = offset;
        });
        this.subscription.add(sub);
    }
    subscribeToSort() {
        const sub = this.table.sort.subscribe(({ sorts: [{ prop, dir }] }) => {
            if (prop === this.list.sortKey && this.list.sortOrder === 'desc') {
                this.list.sortKey = '';
                this.list.sortOrder = '';
                this.table.sorts = [];
                this.cdRef.detectChanges();
            }
            else {
                this.list.sortKey = prop;
                this.list.sortOrder = dir;
            }
        });
        this.subscription.add(sub);
    }
    subscribeToQuery() {
        if (!this.querySubscription.closed)
            this.querySubscription.unsubscribe();
        this.querySubscription = this.list.query$.subscribe(() => {
            const offset = this.list.page;
            if (this.table.offset !== offset)
                this.table.offset = offset;
        });
    }
    ngOnChanges({ list }) {
        this.subscribeToQuery();
        if (!list.firstChange)
            return;
        const { maxResultCount, page } = list.currentValue;
        this.table.limit = maxResultCount;
        this.table.offset = page;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.querySubscription.unsubscribe();
    }
    ngOnInit() {
        this.subscribeToPage();
        this.subscribeToSort();
    }
}
NgxDatatableListDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line
                selector: 'ngx-datatable[list]',
                exportAs: 'ngxDatatableList',
            },] }
];
NgxDatatableListDirective.ctorParameters = () => [
    { type: DatatableComponent },
    { type: ChangeDetectorRef },
    { type: LocalizationService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NGX_DATATABLE_MESSAGES,] }] }
];
NgxDatatableListDirective.propDecorators = {
    list: [{ type: Input }]
};

/**
 *
 * @deprecated To be deleted in v5.0
 */
class TableSortDirective {
    constructor(abpTable, sortPipe, cdRef) {
        this.abpTable = abpTable;
        this.sortPipe = sortPipe;
        this.cdRef = cdRef;
        this.value = [];
    }
    get table() {
        return (this.abpTable || snq(() => this.cdRef['_view'].component) || snq(() => this.cdRef['context']) // 'context' for ivy
        );
    }
    ngOnChanges({ value, abpTableSort }) {
        if (this.table && (value || abpTableSort)) {
            this.abpTableSort = this.abpTableSort || {};
            this.table.value = this.sortPipe.transform(clone(this.value), this.abpTableSort.order, this.abpTableSort.key);
        }
    }
}
TableSortDirective.decorators = [
    { type: Directive, args: [{
                selector: '[abpTableSort]',
                providers: [SortPipe],
            },] }
];
TableSortDirective.ctorParameters = () => [
    { type: TableComponent, decorators: [{ type: Host }, { type: Optional }, { type: Self }] },
    { type: SortPipe },
    { type: ChangeDetectorRef }
];
TableSortDirective.propDecorators = {
    abpTableSort: [{ type: Input }],
    value: [{ type: Input }]
};

class EllipsisDirective {
    constructor(cdRef, elRef) {
        this.cdRef = cdRef;
        this.elRef = elRef;
        this.enabled = true;
    }
    get inlineClass() {
        return this.enabled && this.width;
    }
    get class() {
        return this.enabled && !this.width;
    }
    get maxWidth() {
        return this.enabled && this.width ? this.width || '170px' : undefined;
    }
    ngAfterViewInit() {
        this.title = this.title || this.elRef.nativeElement.innerText;
        this.cdRef.detectChanges();
    }
}
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[abpEllipsis]',
            },] }
];
EllipsisDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
EllipsisDirective.propDecorators = {
    width: [{ type: Input, args: ['abpEllipsis',] }],
    title: [{ type: HostBinding, args: ['title',] }, { type: Input }],
    enabled: [{ type: Input, args: ['abpEllipsisEnabled',] }],
    inlineClass: [{ type: HostBinding, args: ['class.abp-ellipsis-inline',] }],
    class: [{ type: HostBinding, args: ['class.abp-ellipsis',] }],
    maxWidth: [{ type: HostBinding, args: ['style.max-width',] }]
};
class EllipsisModule {
}
EllipsisModule.decorators = [
    { type: NgModule, args: [{
                exports: [EllipsisDirective],
                declarations: [EllipsisDirective],
            },] }
];

function httpErrorConfigFactory(config = {}) {
    if (config.errorScreen && config.errorScreen.component && !config.errorScreen.forWhichErrors) {
        config.errorScreen.forWhichErrors = [401, 403, 404, 500];
    }
    return Object.assign({ skipHandledErrorCodes: [], errorScreen: {} }, config);
}
const HTTP_ERROR_CONFIG = new InjectionToken('HTTP_ERROR_CONFIG');
const HTTP_ERROR_HANDLER = new InjectionToken('HTTP_ERROR_HANDLER');

const DEFAULT_ERROR_MESSAGES = {
    defaultError: {
        title: 'An error has occurred!',
        details: 'Error detail not sent by server.',
    },
    defaultError401: {
        title: 'You are not authenticated!',
        details: 'You should be authenticated (sign in) in order to perform this operation.',
    },
    defaultError403: {
        title: 'You are not authorized!',
        details: 'You are not allowed to perform this operation.',
    },
    defaultError404: {
        title: 'Resource not found!',
        details: 'The resource requested could not found on the server.',
    },
    defaultError500: {
        title: 'Internal server error',
        details: 'Error detail not sent by server.',
    },
};
const DEFAULT_ERROR_LOCALIZATIONS = {
    defaultError: {
        title: 'AbpUi::DefaultErrorMessage',
        details: 'AbpUi::DefaultErrorMessageDetail',
    },
    defaultError401: {
        title: 'AbpUi::DefaultErrorMessage401',
        details: 'AbpUi::DefaultErrorMessage401Detail',
    },
    defaultError403: {
        title: 'AbpUi::DefaultErrorMessage403',
        details: 'AbpUi::DefaultErrorMessage403Detail',
    },
    defaultError404: {
        title: 'AbpUi::DefaultErrorMessage404',
        details: 'AbpUi::DefaultErrorMessage404Detail',
    },
    defaultError500: {
        title: 'AbpUi::500Message',
        details: 'AbpUi::DefaultErrorMessage',
    },
};
class ErrorHandler {
    constructor(actions, routerEvents, confirmationService, cfRes, rendererFactory, injector, httpErrorConfig) {
        this.actions = actions;
        this.routerEvents = routerEvents;
        this.confirmationService = confirmationService;
        this.cfRes = cfRes;
        this.rendererFactory = rendererFactory;
        this.injector = injector;
        this.httpErrorConfig = httpErrorConfig;
        this.httpErrorHandler = this.injector.get(HTTP_ERROR_HANDLER, (_, err) => throwError(err));
        this.executeErrorHandler = error => {
            const returnValue = this.httpErrorHandler(this.injector, error);
            return (returnValue instanceof Observable ? returnValue : of(null)).pipe(catchError(err => {
                this.handleError(err);
                return of(null);
            }));
        };
        this.filterRestErrors = ({ status }) => {
            if (typeof status !== 'number')
                return false;
            return this.httpErrorConfig.skipHandledErrorCodes.findIndex(code => code === status) < 0;
        };
        this.filterRouteErrors = (navigationError) => {
            return (snq(() => navigationError.error.message.indexOf('Cannot match') > -1) &&
                this.httpErrorConfig.skipHandledErrorCodes.findIndex(code => code === 404) < 0);
        };
        this.listenToRestError();
        this.listenToRouterError();
        this.listenToRouterDataResolved();
    }
    listenToRouterError() {
        this.routerEvents
            .getNavigationEvents('Error')
            .pipe(filter(this.filterRouteErrors))
            .subscribe(() => this.show404Page());
    }
    listenToRouterDataResolved() {
        this.routerEvents
            .getEvents(ResolveEnd)
            .pipe(filter(() => !!this.componentRef))
            .subscribe(() => {
            this.componentRef.destroy();
            this.componentRef = null;
        });
    }
    listenToRestError() {
        this.actions
            .pipe(ofActionSuccessful(RestOccurError), map(action => action.payload), filter(this.filterRestErrors), switchMap(this.executeErrorHandler))
            .subscribe();
    }
    handleError(err) {
        const body = snq(() => err.error.error, {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        });
        if (err instanceof HttpErrorResponse && err.headers.get('_AbpErrorFormat')) {
            const confirmation$ = this.showError(null, null, body);
            if (err.status === 401) {
                confirmation$.subscribe(() => {
                    this.navigateToLogin();
                });
            }
        }
        else {
            switch (err.status) {
                case 401:
                    this.canCreateCustomError(401)
                        ? this.show401Page()
                        : this.showError({
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError401.title,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError401.title,
                        }, {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError401.details,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError401.details,
                        }).subscribe(() => this.navigateToLogin());
                    break;
                case 403:
                    this.createErrorComponent({
                        title: {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError403.title,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError403.title,
                        },
                        details: {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError403.details,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError403.details,
                        },
                        status: 403,
                    });
                    break;
                case 404:
                    this.canCreateCustomError(404)
                        ? this.show404Page()
                        : this.showError({
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError404.details,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError404.details,
                        }, {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError404.title,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError404.title,
                        });
                    break;
                case 500:
                    this.createErrorComponent({
                        title: {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError500.title,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError500.title,
                        },
                        details: {
                            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError500.details,
                            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError500.details,
                        },
                        status: 500,
                    });
                    break;
                case 0:
                    if (err.statusText === 'Unknown Error') {
                        this.createErrorComponent({
                            title: {
                                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
                            },
                            details: err.message,
                            isHomeShow: false,
                        });
                    }
                    break;
                default:
                    this.showError({
                        key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.details,
                        defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.details,
                    }, {
                        key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                        defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
                    });
                    break;
            }
        }
    }
    show401Page() {
        this.createErrorComponent({
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError401.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError401.title,
            },
            status: 401,
        });
    }
    show404Page() {
        this.createErrorComponent({
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError404.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError404.title,
            },
            status: 404,
        });
    }
    showError(message, title, body) {
        if (body) {
            if (body.details) {
                message = body.details;
                title = body.message;
            }
            else if (body.message) {
                title = {
                    key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                    defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
                };
                message = body.message;
            }
            else {
                message = body.message || {
                    key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                    defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
                };
            }
        }
        return this.confirmationService.error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        });
    }
    navigateToLogin() {
        this.injector.get(AuthService).navigateToLogin();
    }
    createErrorComponent(instance) {
        const renderer = this.rendererFactory.createRenderer(null, null);
        const host = renderer.selectRootElement(document.body, true);
        this.componentRef = this.cfRes
            .resolveComponentFactory(HttpErrorWrapperComponent)
            .create(this.injector);
        for (const key in instance) {
            /* istanbul ignore else */
            if (this.componentRef.instance.hasOwnProperty(key)) {
                this.componentRef.instance[key] = instance[key];
            }
        }
        this.componentRef.instance.hideCloseIcon = this.httpErrorConfig.errorScreen.hideCloseIcon;
        const appRef = this.injector.get(ApplicationRef);
        if (this.canCreateCustomError(instance.status)) {
            this.componentRef.instance.cfRes = this.cfRes;
            this.componentRef.instance.appRef = appRef;
            this.componentRef.instance.injector = this.injector;
            this.componentRef.instance.customComponent = this.httpErrorConfig.errorScreen.component;
        }
        appRef.attachView(this.componentRef.hostView);
        renderer.appendChild(host, this.componentRef.hostView.rootNodes[0]);
        const destroy$ = new Subject();
        this.componentRef.instance.destroy$ = destroy$;
        destroy$.subscribe(() => {
            this.componentRef.destroy();
            this.componentRef = null;
        });
    }
    canCreateCustomError(status) {
        return snq(() => this.httpErrorConfig.errorScreen.component &&
            this.httpErrorConfig.errorScreen.forWhichErrors.indexOf(status) > -1);
    }
}
ErrorHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorHandler_Factory() { return new ErrorHandler(i0.ɵɵinject(i1$1.Actions), i0.ɵɵinject(i1.RouterEvents), i0.ɵɵinject(ConfirmationService), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject("HTTP_ERROR_CONFIG")); }, token: ErrorHandler, providedIn: "root" });
ErrorHandler.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ErrorHandler.ctorParameters = () => [
    { type: Actions },
    { type: RouterEvents },
    { type: ConfirmationService },
    { type: ComponentFactoryResolver },
    { type: RendererFactory2 },
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: ['HTTP_ERROR_CONFIG',] }] }
];

const LAZY_STYLES = new InjectionToken('LAZY_STYLES');

class LazyStyleHandler {
    constructor(injector) {
        this._dir = 'ltr';
        this.loaded = new Map();
        this.setStyles(injector);
        this.setLazyLoad(injector);
        this.listenToLanguageChanges(injector);
    }
    set dir(dir) {
        if (dir === this._dir)
            return;
        this.switchCSS(dir);
        this.setBodyDir(dir);
        this._dir = dir;
    }
    get dir() {
        return this._dir;
    }
    getHrefFromLink(link) {
        if (!link)
            return '';
        const a = document.createElement('a');
        a.href = link.href;
        return a.pathname.replace(/^\//, '');
    }
    getLoadedBootstrap() {
        const href = createLazyStyleHref(BOOTSTRAP, this.dir);
        const selector = `[href*="${href.replace(/\.css$/, '')}"]`;
        const link = document.querySelector(selector);
        return { href, link };
    }
    listenToLanguageChanges(injector) {
        const l10n = injector.get(LocalizationService);
        // will always listen, no need to unsubscribe
        l10n.languageChange$.pipe(startWith(l10n.currentLang)).subscribe(locale => {
            this.dir = getLocaleDirection(locale);
        });
    }
    setBodyDir(dir) {
        document.body.dir = dir;
    }
    setLazyLoad(injector) {
        this.lazyLoad = injector.get(LazyLoadService);
        const { href, link } = this.getLoadedBootstrap();
        this.lazyLoad.loaded.set(href, link);
    }
    setStyles(injector) {
        this.styles = injector.get(LAZY_STYLES, [BOOTSTRAP]);
    }
    switchCSS(dir) {
        this.styles.forEach(style => {
            const oldHref = createLazyStyleHref(style, this.dir);
            const newHref = createLazyStyleHref(style, dir);
            const link = this.loaded.get(newHref);
            const href = this.getHrefFromLink(link) || newHref;
            const strategy = LOADING_STRATEGY.PrependAnonymousStyleToHead(href);
            this.lazyLoad.load(strategy).subscribe(() => {
                const oldLink = this.lazyLoad.loaded.get(oldHref);
                this.loaded.delete(newHref);
                this.loaded.set(oldHref, oldLink);
                const newLink = this.lazyLoad.loaded.get(href);
                this.lazyLoad.loaded.delete(href);
                this.lazyLoad.loaded.set(newHref, newLink);
                this.lazyLoad.remove(oldHref);
            });
        });
    }
}
LazyStyleHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyStyleHandler_Factory() { return new LazyStyleHandler(i0.ɵɵinject(i0.INJECTOR)); }, token: LazyStyleHandler, providedIn: "root" });
LazyStyleHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
LazyStyleHandler.ctorParameters = () => [
    { type: Injector }
];
function createLazyStyleHref(style, dir) {
    return style.replace(/{{\s*dir\s*}}/g, dir);
}
function initLazyStyleHandler(injector) {
    return () => new LazyStyleHandler(injector);
}

class NavItem {
    constructor(props) {
        props = Object.assign(Object.assign({}, props), { visible: props.visible || (() => true) });
        Object.assign(this, props);
    }
}

const NG_BOOTSTRAP_CONFIG_PROVIDERS = [
    {
        provide: APP_INITIALIZER,
        useFactory: configureNgBootstrap,
        deps: [NgbInputDatepickerConfig, NgbTypeaheadConfig],
        multi: true,
    },
];
function configureNgBootstrap(datepicker, typeahead) {
    return () => {
        datepicker.container = 'body';
        typeahead.container = 'body';
    };
}

const THEME_SHARED_ROUTE_PROVIDERS = [
    { provide: APP_INITIALIZER, useFactory: configureRoutes, deps: [RoutesService], multi: true },
];
function configureRoutes(routesService) {
    return () => {
        routesService.add([
            {
                path: undefined,
                name: "AbpUiNavigation::Menu:Administration" /* Administration */,
                iconClass: 'fa fa-wrench',
                order: 100,
            },
        ]);
    };
}

/**
 * @deprecated To be removed in v5.0
 */
class ModalContainerComponent {
}
ModalContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-modal-container',
                template: '<ng-container #container></ng-container>'
            },] }
];
ModalContainerComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { static: true, read: ViewContainerRef },] }]
};

/**
 * @deprecated Use ng-bootstrap modal. To be deleted in v5.0.
 */
class ModalService {
    constructor(contentProjectionService) {
        this.contentProjectionService = contentProjectionService;
        this.setContainer();
    }
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ModalContainerComponent));
        this.containerComponentRef.changeDetectorRef.detectChanges();
    }
    clearModal() {
        this.getContainer().clear();
        this.detectChanges();
    }
    detectChanges() {
        this.containerComponentRef.changeDetectorRef.detectChanges();
    }
    getContainer() {
        return this.containerComponentRef.instance.container;
    }
    renderTemplate(template, context) {
        const containerRef = this.getContainer();
        const strategy = PROJECTION_STRATEGY.ProjectTemplateToContainer(template, containerRef, context);
        this.contentProjectionService.projectContent(strategy);
    }
    ngOnDestroy() {
        this.containerComponentRef.destroy();
    }
}
ModalService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ModalService_Factory() { return new ModalService(i0.ɵɵinject(i1.ContentProjectionService)); }, token: ModalService, providedIn: "root" });
ModalService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ModalService.ctorParameters = () => [
    { type: ContentProjectionService }
];

class NavItemsService {
    constructor() {
        this._items$ = new BehaviorSubject([]);
    }
    get items() {
        return this._items$.value;
    }
    get items$() {
        return this._items$.asObservable();
    }
    addItems(newItems) {
        const items = [...this.items];
        newItems.forEach(item => items.push(new NavItem(item)));
        items.sort(sortItems);
        this._items$.next(items);
    }
    removeItem(id) {
        const index = this.items.findIndex(item => item.id === id);
        if (index < 0)
            return;
        const items = [...this.items.slice(0, index), ...this.items.slice(index + 1)];
        this._items$.next(items);
    }
    patchItem(id, item) {
        const index = this.items.findIndex(i => i.id === id);
        if (index < 0)
            return;
        const items = [...this.items];
        items[index] = new NavItem(Object.assign(Object.assign({}, items[index]), item));
        items.sort(sortItems);
        this._items$.next(items);
    }
}
NavItemsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NavItemsService_Factory() { return new NavItemsService(); }, token: NavItemsService, providedIn: "root" });
NavItemsService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
function sortItems(a, b) {
    if (!a.order)
        return 1;
    if (!b.order)
        return -1;
    return a.order - b.order;
}

class PageAlertService {
    constructor() {
        this.alerts = new InternalStore([]);
        this.alerts$ = this.alerts.sliceState(state => state);
    }
    show(alert) {
        var _a;
        const newAlert = Object.assign(Object.assign({}, alert), { dismissible: (_a = alert.dismissible) !== null && _a !== void 0 ? _a : true });
        this.alerts.set([newAlert, ...this.alerts.state]);
    }
    remove(index) {
        const alerts = [...this.alerts.state];
        alerts.splice(index, 1);
        this.alerts.set(alerts);
    }
}
PageAlertService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PageAlertService_Factory() { return new PageAlertService(); }, token: PageAlertService, providedIn: "root" });
PageAlertService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PageAlertService.ctorParameters = () => [];

const THEME_SHARED_APPEND_CONTENT = new InjectionToken('THEME_SHARED_APPEND_CONTENT', {
    providedIn: 'root',
    factory: () => {
        const domInsertion = inject(DomInsertionService);
        domInsertion.insertContent(CONTENT_STRATEGY.AppendStyleToHead(styles));
        import('chart.js').then(() => chartJsLoaded$.next(true));
    },
});

function isNumber(value) {
    return !isNaN(toInteger(value));
}
function toInteger(value) {
    return parseInt(`${value}`, 10);
}
class DateParserFormatter extends NgbDateParserFormatter {
    constructor(configState, locale) {
        super();
        this.configState = configState;
        this.locale = locale;
    }
    parse(value) {
        if (value) {
            const dateParts = value.trim().split('-');
            if (dateParts.length === 1 && isNumber(dateParts[0])) {
                return { year: toInteger(dateParts[0]), month: null, day: null };
            }
            else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {
                return { year: toInteger(dateParts[0]), month: toInteger(dateParts[1]), day: null };
            }
            else if (dateParts.length === 3 &&
                isNumber(dateParts[0]) &&
                isNumber(dateParts[1]) &&
                isNumber(dateParts[2])) {
                return {
                    year: toInteger(dateParts[0]),
                    month: toInteger(dateParts[1]),
                    day: toInteger(dateParts[2]),
                };
            }
        }
        return null;
    }
    format(date) {
        if (!date)
            return '';
        const localization = this.configState.getOne('localization');
        const dateFormat = snq(() => localization.currentCulture.dateTimeFormat.shortDatePattern) || 'yyyy-MM-dd';
        return formatDate(new Date(date.year, date.month - 1, date.day), dateFormat, this.locale);
    }
}
DateParserFormatter.decorators = [
    { type: Injectable }
];
DateParserFormatter.ctorParameters = () => [
    { type: ConfigStateService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];

const declarationsWithExports = [
    BreadcrumbComponent,
    ButtonComponent,
    ChartComponent,
    ConfirmationComponent,
    LoaderBarComponent,
    LoadingComponent,
    ModalComponent,
    TableComponent,
    TableEmptyMessageComponent,
    ToastComponent,
    ToastContainerComponent,
    SortOrderIconComponent,
    NgxDatatableDefaultDirective,
    NgxDatatableListDirective,
    LoadingDirective,
    TableSortDirective,
    ModalCloseDirective,
];
class BaseThemeSharedModule {
}
BaseThemeSharedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    NgxDatatableModule,
                    NgxValidateCoreModule,
                    NgbPaginationModule,
                    EllipsisModule,
                ],
                declarations: [...declarationsWithExports, HttpErrorWrapperComponent, ModalContainerComponent],
                exports: [NgxDatatableModule, EllipsisModule, ...declarationsWithExports],
                providers: [DatePipe],
                entryComponents: [
                    HttpErrorWrapperComponent,
                    LoadingComponent,
                    ModalContainerComponent,
                    ToastContainerComponent,
                    ConfirmationComponent,
                ],
            },] }
];
class ThemeSharedModule {
    static forRoot({ httpErrorConfig, validation = {} } = {}) {
        return {
            ngModule: ThemeSharedModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [ErrorHandler],
                    useFactory: noop,
                },
                THEME_SHARED_ROUTE_PROVIDERS,
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [THEME_SHARED_APPEND_CONTENT],
                    useFactory: noop,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [Injector],
                    useFactory: initLazyStyleHandler,
                },
                { provide: HTTP_ERROR_CONFIG, useValue: httpErrorConfig },
                {
                    provide: 'HTTP_ERROR_CONFIG',
                    useFactory: httpErrorConfigFactory,
                    deps: [HTTP_ERROR_CONFIG],
                },
                { provide: NgbDateParserFormatter, useClass: DateParserFormatter },
                NG_BOOTSTRAP_CONFIG_PROVIDERS,
                {
                    provide: VALIDATION_BLUEPRINTS,
                    useValue: Object.assign(Object.assign({}, DEFAULT_VALIDATION_BLUEPRINTS), (validation.blueprints || {})),
                },
                {
                    provide: VALIDATION_MAP_ERRORS_FN,
                    useValue: validation.mapErrorsFn || defaultMapErrorsFn,
                },
                {
                    provide: VALIDATION_VALIDATE_ON_SUBMIT,
                    useValue: validation.validateOnSubmit,
                },
            ],
        };
    }
}
ThemeSharedModule.decorators = [
    { type: NgModule, args: [{
                imports: [BaseThemeSharedModule],
                exports: [BaseThemeSharedModule],
            },] }
];

const { minLength, maxLength } = Validators;
function getPasswordValidators(injector) {
    const getRule = getRuleFn(injector);
    const passwordRulesArr = [];
    let requiredLength = 1;
    if (getRule('RequireDigit') === 'true') {
        passwordRulesArr.push('number');
    }
    if (getRule('RequireLowercase') === 'true') {
        passwordRulesArr.push('small');
    }
    if (getRule('RequireUppercase') === 'true') {
        passwordRulesArr.push('capital');
    }
    if (getRule('RequireNonAlphanumeric') === 'true') {
        passwordRulesArr.push('special');
    }
    if (Number.isInteger(+getRule('RequiredLength'))) {
        requiredLength = +getRule('RequiredLength');
    }
    return [validatePassword(passwordRulesArr), minLength(requiredLength), maxLength(128)];
}
function getRuleFn(injector) {
    const configState = injector.get(ConfigStateService);
    return (key) => {
        const passwordRules = configState.getSettings('Identity.Password');
        return (passwordRules[`Abp.Identity.Password.${key}`] || '').toLowerCase();
    };
}

/*
 * Public API Surface of theme-shared
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BOOTSTRAP, BaseThemeSharedModule, BreadcrumbComponent, ButtonComponent, ChartComponent, Confirmation, ConfirmationComponent, ConfirmationService, DEFAULT_ERROR_LOCALIZATIONS, DEFAULT_ERROR_MESSAGES, DEFAULT_VALIDATION_BLUEPRINTS, DateParserFormatter, EllipsisDirective, EllipsisModule, ErrorHandler, HTTP_ERROR_CONFIG, HTTP_ERROR_HANDLER, HttpErrorWrapperComponent, LAZY_STYLES, LazyStyleHandler, LoaderBarComponent, LoadingComponent, LoadingDirective, ModalCloseDirective, ModalComponent, ModalRefService, ModalService, NGX_DATATABLE_MESSAGES, NG_BOOTSTRAP_CONFIG_PROVIDERS, NavItem, NavItemsService, NgxDatatableDefaultDirective, NgxDatatableListDirective, PageAlertService, SUPPRESS_UNSAVED_CHANGES_WARNING, SortOrderIconComponent, THEME_SHARED_APPEND_CONTENT, THEME_SHARED_ROUTE_PROVIDERS, TableComponent, TableEmptyMessageComponent, TableSortDirective, ThemeSharedModule, ToastComponent, ToastContainerComponent, ToasterService, bounceIn, chartJsLoaded$, collapse, collapseLinearWithMargin, collapseWithMargin, collapseX, collapseY, collapseYWithMargin, configureNgBootstrap, configureRoutes, createLazyStyleHref, defaultNgxDatatableMessages, dialogAnimation, expandX, expandY, expandYWithMargin, fadeAnimation, fadeIn, fadeInDown, fadeInLeft, fadeInRight, fadeInUp, fadeOut, fadeOutDown, fadeOutLeft, fadeOutRight, fadeOutUp, getPasswordValidators, getRandomBackgroundColor, httpErrorConfigFactory, initLazyStyleHandler, slideFromBottom, toastInOut, EllipsisDirective as ɵa, EllipsisModule as ɵb, HttpErrorWrapperComponent as ɵba, ModalContainerComponent as ɵbb, ErrorHandler as ɵbc, THEME_SHARED_ROUTE_PROVIDERS as ɵbe, configureRoutes as ɵbf, THEME_SHARED_APPEND_CONTENT as ɵbg, initLazyStyleHandler as ɵbh, httpErrorConfigFactory as ɵbi, HTTP_ERROR_CONFIG as ɵbj, DateParserFormatter as ɵbk, NG_BOOTSTRAP_CONFIG_PROVIDERS as ɵbl, BreadcrumbComponent as ɵc, ButtonComponent as ɵd, ChartComponent as ɵe, ConfirmationComponent as ɵf, LoaderBarComponent as ɵg, LoadingComponent as ɵh, ModalComponent as ɵi, SUPPRESS_UNSAVED_CHANGES_WARNING as ɵj, ConfirmationService as ɵk, ModalRefService as ɵl, TableComponent as ɵm, TableEmptyMessageComponent as ɵn, ToastComponent as ɵo, ToasterService as ɵp, ToastContainerComponent as ɵq, toastInOut as ɵr, SortOrderIconComponent as ɵs, NgxDatatableDefaultDirective as ɵt, NgxDatatableListDirective as ɵu, NGX_DATATABLE_MESSAGES as ɵw, LoadingDirective as ɵx, TableSortDirective as ɵy, ModalCloseDirective as ɵz };
//# sourceMappingURL=abp-ng.theme.shared.js.map
