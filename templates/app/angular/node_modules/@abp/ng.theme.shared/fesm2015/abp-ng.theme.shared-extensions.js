import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Optional, SkipSelf, ChangeDetectorRef, Input, ViewChild, InjectionToken, Inject, ViewChildren, LOCALE_ID, Injector, Directive, Host, TemplateRef, ViewContainerRef, NgModule } from '@angular/core';
import { formatDate } from '@angular/common';
import { NgbDateAdapter, NgbTimeAdapter, NgbInputDatepicker, NgbTimepicker, NgbDatepickerModule, NgbDropdownModule, NgbTimepickerModule, NgbTypeaheadModule } from '@ng-bootstrap/ng-bootstrap';
import { ControlContainer, FormGroupDirective, Validators, NgControl, FormGroup, FormControl } from '@angular/forms';
import { RestService, TrackByService, ConfigStateService, AbpValidators, getShortDateShortTimeFormat, getShortTimeFormat, getShortDateFormat, CoreModule, LocalizationService, createLocalizationPipeKeyGenerator } from '@abp/ng.core';
import { of, merge, pipe, zip } from 'rxjs';
import { map, debounceTime, distinctUntilChanged, switchMap, filter, take } from 'rxjs/operators';
import snq from 'snq';
import { LinkedList } from '@abp/utils';
import { ThemeSharedModule } from '@abp/ng.theme.shared';
import { NgxValidateCoreModule } from '@ngx-validate/core';

class DateTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = new Date(value);
        if (isNaN(date))
            return null;
        this.value = {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
        return this.value;
    }
    toModel(value) {
        if (!value)
            return '';
        const now = new Date();
        value = Object.assign(Object.assign({ year: now.getUTCFullYear(), month: now.getMonth() + 1, day: now.getDate(), hour: 0, minute: 0, second: 0 }, this.value), value);
        const date = new Date(value.year, value.month - 1, value.day, value.hour, value.minute, value.second);
        return new Date(date).toISOString();
    }
}
DateTimeAdapter.decorators = [
    { type: Injectable }
];

class DateAdapter extends NgbDateAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = new Date(value);
        if (isNaN(date))
            return null;
        return {
            day: date.getDate(),
            month: date.getMonth() + 1,
            year: date.getFullYear(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(value.year, value.month - 1, value.day);
        const formattedDate = formatDate(date, 'yyyy-MM-dd', 'en');
        return formattedDate;
    }
}
DateAdapter.decorators = [
    { type: Injectable }
];

class TimeAdapter extends NgbTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = isTimeStr(value)
            ? new Date(0, 0, 1, ...value.split(':').map(Number))
            : new Date(value);
        if (isNaN(date))
            return null;
        return {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(0, 0, 1, value.hour, value.minute, value.second);
        const formattedDate = formatDate(date, 'HH:mm', 'en');
        return formattedDate;
    }
}
TimeAdapter.decorators = [
    { type: Injectable }
];
function isTimeStr(value) {
    return /^((2[123])|[01][0-9])(\:[0-5][0-9]){1,2}$/.test(String(value));
}

function selfFactory(dependency) {
    return dependency;
}

const ɵ0$2 = selfFactory;
class DateTimePickerComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        this.meridian = false;
    }
    setDate(datestr) {
        this.date.writeValue(datestr);
    }
    setTime(datestr) {
        this.time.writeValue(datestr);
    }
}
DateTimePickerComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'abpDateTimePicker',
                selector: 'abp-date-time-picker',
                template: `
    <input
      [id]="prop.id"
      [formControlName]="prop.name"
      (ngModelChange)="setTime($event)"
      (click)="datepicker.open()"
      (keyup.space)="datepicker.open()"
      ngbDatepicker
      #datepicker="ngbDatepicker"
      type="text"
      class="form-control"
    />
    <ngb-timepicker
      #timepicker
      [formControlName]="prop.name"
      (ngModelChange)="setDate($event)"
      [meridian]="meridian"
    ></ngb-timepicker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0$2,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                    },
                    {
                        provide: NgbDateAdapter,
                        useClass: DateTimeAdapter,
                    },
                    {
                        provide: NgbTimeAdapter,
                        useClass: DateTimeAdapter,
                    },
                ]
            },] }
];
DateTimePickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DateTimePickerComponent.propDecorators = {
    prop: [{ type: Input }],
    meridian: [{ type: Input }],
    date: [{ type: ViewChild, args: [NgbInputDatepicker,] }],
    time: [{ type: ViewChild, args: [NgbTimepicker,] }]
};

const EXTRA_PROPERTIES_KEY = 'extraProperties';

const TYPEAHEAD_TEXT_SUFFIX = '_Text';
const TYPEAHEAD_TEXT_SUFFIX_REGEX = /_Text$/;
function createTypeaheadOptions(lookup) {
    return (data, searchText) => searchText
        ? data
            .getInjected(RestService)
            .request({
            method: 'GET',
            url: lookup.url,
            params: {
                [lookup.filterParamName]: searchText,
            },
        }, { apiName: 'Default' })
            .pipe(map(response => {
            const list = response[lookup.resultListPropertyName];
            const mapToOption = (item) => ({
                key: item[lookup.displayPropertyName],
                value: item[lookup.valuePropertyName],
            });
            return list.map(mapToOption);
        }))
        : of([]);
}
function getTypeaheadType(lookup, name) {
    return Boolean(lookup.url)
        ? "typeahead" /* Typeahead */
        : name.endsWith(TYPEAHEAD_TEXT_SUFFIX)
            ? "hidden" /* Hidden */
            : undefined;
}
function createTypeaheadDisplayNameGenerator(displayNameGeneratorFn, properties) {
    return (displayName, fallback) => {
        const name = removeTypeaheadTextSuffix(fallback.name);
        return displayNameGeneratorFn(displayName || properties[name].displayName, {
            name,
            resource: fallback.resource,
        });
    };
}
function addTypeaheadTextSuffix(name) {
    return name + TYPEAHEAD_TEXT_SUFFIX;
}
function hasTypeaheadTextSuffix(name) {
    return TYPEAHEAD_TEXT_SUFFIX_REGEX.test(name);
}
function removeTypeaheadTextSuffix(name) {
    return name.replace(TYPEAHEAD_TEXT_SUFFIX_REGEX, '');
}

const ɵ0$1 = selfFactory;
class ExtensibleFormPropComponent {
    constructor(cdRef, track, configState, groupDirective) {
        this.cdRef = cdRef;
        this.track = track;
        this.configState = configState;
        this.asterisk = '';
        this.options$ = of([]);
        this.validators = [];
        this.search = (text$) => text$
            ? text$.pipe(debounceTime(300), distinctUntilChanged(), switchMap(text => this.prop.options(this.data, text)))
            : of([]);
        this.typeaheadFormatter = (option) => option.key;
        this.form = groupDirective.form;
    }
    setTypeaheadValue(selectedOption) {
        this.typeaheadModel = selectedOption || { key: null, value: null };
        const { key, value } = this.typeaheadModel;
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (valueControl.value && !value)
            valueControl.markAsDirty();
        keyControl.setValue(key);
        valueControl.setValue(value);
    }
    get meridian() {
        return (this.configState.getDeep('localization.currentCulture.dateTimeFormat.shortTimePattern') || '').includes('tt');
    }
    get isInvalid() {
        const control = this.form.get(this.prop.name);
        return control.touched && control.invalid;
    }
    getTypeaheadControls() {
        const { name } = this.prop;
        const extraPropName = `${EXTRA_PROPERTIES_KEY}.${name}`;
        const keyControl = this.form.get(addTypeaheadTextSuffix(extraPropName)) ||
            this.form.get(addTypeaheadTextSuffix(name));
        const valueControl = this.form.get(extraPropName) || this.form.get(name);
        return [keyControl, valueControl];
    }
    setAsterisk() {
        this.asterisk = this.validators.some(isRequired) ? '*' : '';
    }
    ngAfterViewInit() {
        if (this.first && this.fieldRef) {
            this.fieldRef.nativeElement.focus();
        }
    }
    getComponent(prop) {
        switch (prop.type) {
            case "boolean" /* Boolean */:
                return 'checkbox';
            case "date" /* Date */:
                return 'date';
            case "dateTime" /* DateTime */:
                return 'dateTime';
            case "hidden" /* Hidden */:
                return 'hidden';
            case "multiselect" /* MultiSelect */:
                return 'multiselect';
            case "text" /* Text */:
                return 'textarea';
            case "time" /* Time */:
                return 'time';
            case "typeahead" /* Typeahead */:
                return 'typeahead';
            default:
                return prop.options ? 'select' : 'input';
        }
    }
    getType(prop) {
        switch (prop.type) {
            case "date" /* Date */:
            case "string" /* String */:
                return 'text';
            case "boolean" /* Boolean */:
                return 'checkbox';
            case "number" /* Number */:
                return 'number';
            case "email" /* Email */:
                return 'email';
            case "password" /* Password */:
                return 'password';
            default:
                return 'hidden';
        }
    }
    ngOnChanges({ prop }) {
        const currentProp = snq(() => prop.currentValue);
        const { options, readonly, disabled, validators } = currentProp || {};
        if (options)
            this.options$ = options(this.data);
        if (readonly)
            this.readonly = readonly(this.data);
        if (disabled)
            this.disabled = disabled(this.data);
        if (validators) {
            this.validators = validators(this.data);
            this.setAsterisk();
        }
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (keyControl && valueControl)
            this.typeaheadModel = { key: keyControl.value, value: valueControl.value };
    }
}
ExtensibleFormPropComponent.decorators = [
    { type: Component, args: [{
                selector: 'abp-extensible-form-prop',
                template: "<div class=\"form-group\" *abpPermission=\"prop.permission\" [ngSwitch]=\"getComponent(prop)\">\n  <ng-template ngSwitchCase=\"input\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <input\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [autocomplete]=\"prop.autocomplete\"\n      [type]=\"getType(prop)\"\n      [abpDisabled]=\"disabled\"\n      [readonly]=\"readonly\"\n      class=\"form-control\"\n    />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"hidden\">\n    <input [formControlName]=\"prop.name\" type=\"hidden\" />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"checkbox\">\n    <div class=\"custom-checkbox custom-control\" validationTarget>\n      <input\n        #field\n        [id]=\"prop.id\"\n        [formControlName]=\"prop.name\"\n        [abpDisabled]=\"disabled\"\n        type=\"checkbox\"\n        class=\"custom-control-input\"\n      />\n      <ng-template\n        [ngTemplateOutlet]=\"label\"\n        [ngTemplateOutletContext]=\"{ $implicit: 'custom-control-label' }\"\n      ></ng-template>\n    </div>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"select\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <select\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      class=\"custom-select form-control\"\n    >\n      <option\n        *ngFor=\"let option of options$ | async; trackBy: track.by('value')\"\n        [ngValue]=\"option.value\"\n      >\n        {{ option.key }}\n      </option>\n    </select>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"multiselect\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <select\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      multiple=\"multiple\"\n      class=\"custom-select form-control\"\n    >\n      <option\n        *ngFor=\"let option of options$ | async; trackBy: track.by('value')\"\n        [ngValue]=\"option.value\"\n      >\n        {{ option.key }}\n      </option>\n    </select>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"typeahead\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <div #typeahead class=\"position-relative\" validationStyle validationTarget>\n      <input\n        #field\n        [id]=\"prop.id\"\n        [autocomplete]=\"prop.autocomplete\"\n        [abpDisabled]=\"disabled\"\n        [ngbTypeahead]=\"search\"\n        [editable]=\"false\"\n        [inputFormatter]=\"typeaheadFormatter\"\n        [resultFormatter]=\"typeaheadFormatter\"\n        [ngModelOptions]=\"{ standalone: true }\"\n        [(ngModel)]=\"typeaheadModel\"\n        (selectItem)=\"setTypeaheadValue($event.item)\"\n        (blur)=\"setTypeaheadValue(typeaheadModel)\"\n        [class.is-invalid]=\"typeahead.classList.contains('is-invalid')\"\n        class=\"form-control\"\n      />\n      <input [formControlName]=\"prop.name\" type=\"hidden\" />\n    </div>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"date\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <input\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      (click)=\"datepicker.open()\"\n      (keyup.space)=\"datepicker.open()\"\n      ngbDatepicker\n      #datepicker=\"ngbDatepicker\"\n      type=\"text\"\n      class=\"form-control\"\n    />\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"time\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <ngb-timepicker [formControlName]=\"prop.name\"></ngb-timepicker>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"dateTime\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <abp-date-time-picker [prop]=\"prop\" [meridian]=\"meridian\"></abp-date-time-picker>\n  </ng-template>\n\n  <ng-template ngSwitchCase=\"textarea\">\n    <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\n    <textarea\n      #field\n      [id]=\"prop.id\"\n      [formControlName]=\"prop.name\"\n      [abpDisabled]=\"disabled\"\n      [readonly]=\"readonly\"\n      class=\"form-control\"\n    ></textarea>\n  </ng-template>\n</div>\n\n<ng-template #label let-classes>\n  <label [htmlFor]=\"prop.id\" [ngClass]=\"classes\"\n    >{{ prop.displayName | abpLocalization }} {{ asterisk }}</label\n  >\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0$1,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                    },
                    { provide: NgbDateAdapter, useClass: DateAdapter },
                    { provide: NgbTimeAdapter, useClass: TimeAdapter },
                ]
            },] }
];
ExtensibleFormPropComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TrackByService },
    { type: ConfigStateService },
    { type: FormGroupDirective }
];
ExtensibleFormPropComponent.propDecorators = {
    data: [{ type: Input }],
    prop: [{ type: Input }],
    first: [{ type: Input }],
    fieldRef: [{ type: ViewChild, args: ['field',] }]
};
function isRequired(validator) {
    return validator === Validators.required || validator === AbpValidators.required;
}

/* tslint:disable:variable-name */
class ActionList extends LinkedList {
}
class ActionData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Action {
    constructor(permission, visible = _ => true, action = _ => { }) {
        this.permission = permission;
        this.visible = visible;
        this.action = action;
    }
}
class ActionsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Actions {
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    get actions() {
        const actionList = new this._ctor();
        this.callbackList.forEach(callback => callback(actionList));
        return actionList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class EntityActionList extends ActionList {
}
class EntityActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = EntityActionList;
    }
}
class EntityActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityActions;
    }
}
class EntityAction extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
    }
    static create(options) {
        return new EntityAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityAction.create);
    }
}

/* tslint:disable:variable-name */
class PropList extends LinkedList {
}
class PropData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Prop {
    constructor(type, name, displayName, permission, visible = _ => true, isExtra = false) {
        this.type = type;
        this.name = name;
        this.displayName = displayName;
        this.permission = permission;
        this.visible = visible;
        this.isExtra = isExtra;
        this.displayName = this.displayName || this.name;
    }
}
class PropsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Props {
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    get props() {
        const propList = new this._ctor();
        this.callbackList.forEach(callback => callback(propList));
        return propList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class EntityPropList extends PropList {
}
class EntityProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = EntityPropList;
    }
}
class EntityPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityProps;
    }
}
class EntityProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName, options.permission, options.visible, options.isExtra);
        this.columnWidth = options.columnWidth;
        this.sortable = options.sortable || false;
        this.valueResolver = options.valueResolver || (data => of(data.record[this.name]));
        this.action = options.action;
    }
    static create(options) {
        return new EntityProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityProp.create);
    }
}

class FormPropList extends PropList {
}
class FormProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = FormPropList;
    }
}
class CreateFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class EditFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class FormProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName, options.permission, options.visible, options.isExtra);
        this.asyncValidators = options.asyncValidators || (_ => []);
        this.validators = options.validators || (_ => []);
        this.disabled = options.disabled || (_ => false);
        this.readonly = options.readonly || (_ => false);
        this.autocomplete = options.autocomplete || 'off';
        this.options = options.options;
        this.id = options.id || options.name;
        const defaultValue = options.defaultValue;
        this.defaultValue = isFalsyValue(defaultValue) ? defaultValue : defaultValue || null;
    }
    static create(options) {
        return new FormProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(FormProp.create);
    }
}
class FormPropData extends PropData {
    constructor(injector, record) {
        super();
        this.record = record;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
    }
}
function isFalsyValue(defaultValue) {
    return [0, '', false].indexOf(defaultValue) > -1;
}

class ToolbarActionList extends ActionList {
}
class ToolbarActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActionList;
    }
}
class ToolbarActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActions;
    }
}
class ToolbarAction extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
    }
    static create(options) {
        return new ToolbarAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarAction.create);
    }
}
class ToolbarComponent extends Action {
    constructor(options) {
        super(options.permission, options.visible, options.action);
        this.component = options.component;
    }
    static create(options) {
        return new ToolbarComponent(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarComponent.create);
    }
}

class ExtensionsService {
    constructor() {
        this.entityActions = new EntityActionsFactory();
        this.toolbarActions = new ToolbarActionsFactory();
        this.entityProps = new EntityPropsFactory();
        this.createFormProps = new CreateFormPropsFactory();
        this.editFormProps = new EditFormPropsFactory();
    }
}
ExtensionsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ExtensionsService_Factory() { return new ExtensionsService(); }, token: ExtensionsService, providedIn: "root" });
ExtensionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

const EXTENSIONS_IDENTIFIER = new InjectionToken('EXTENSIONS_IDENTIFIER');
const EXTENSIONS_ACTION_TYPE = new InjectionToken('EXTENSIONS_ACTION_TYPE');
const EXTENSIONS_ACTION_DATA = new InjectionToken('EXTENSIONS_ACTION_DATA');
const EXTENSIONS_ACTION_CALLBACK = new InjectionToken('EXTENSIONS_ACTION_DATA');

const ɵ0 = selfFactory;
class ExtensibleFormComponent {
    constructor(cdRef, track, container, extensions, identifier) {
        this.cdRef = cdRef;
        this.track = track;
        this.container = container;
        this.extensions = extensions;
        this.identifier = identifier;
        this.extraPropertiesKey = EXTRA_PROPERTIES_KEY;
    }
    set selectedRecord(record) {
        const type = !record || JSON.stringify(record) === '{}' ? 'create' : 'edit';
        this.propList = this.extensions[`${type}FormProps`].get(this.identifier).props;
        this.record = record;
    }
    get form() {
        return (this.container ? this.container.control : { controls: {} });
    }
    get extraProperties() {
        return (this.form.controls.extraProperties || { controls: {} });
    }
}
ExtensibleFormComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'abpExtensibleForm',
                selector: 'abp-extensible-form',
                template: "<ng-container *ngIf=\"form\">\n  <ng-container *abpPropData=\"let data; fromList: propList; withRecord: record\">\n    <ng-container *ngFor=\"let prop of propList; let first = first; trackBy: track.by('name')\">\n      <ng-container *ngIf=\"prop.visible(data)\">\n        <ng-container\n          [formGroupName]=\"extraPropertiesKey\"\n          *ngIf=\"extraProperties.controls[prop.name]; else tempDefault\"\n        >\n          <abp-extensible-form-prop [prop]=\"prop\" [data]=\"data\"></abp-extensible-form-prop>\n        </ng-container>\n\n        <ng-template #tempDefault>\n          <abp-extensible-form-prop\n            *ngIf=\"form.get(prop.name)\"\n            [prop]=\"prop\"\n            [data]=\"data\"\n            [first]=\"first\"\n          ></abp-extensible-form-prop>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                viewProviders: [
                    {
                        provide: ControlContainer,
                        useFactory: ɵ0,
                        deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                    },
                ]
            },] }
];
ExtensibleFormComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TrackByService },
    { type: ControlContainer },
    { type: ExtensionsService },
    { type: String, decorators: [{ type: Inject, args: [EXTENSIONS_IDENTIFIER,] }] }
];
ExtensibleFormComponent.propDecorators = {
    formProps: [{ type: ViewChildren, args: [ExtensibleFormPropComponent,] }],
    selectedRecord: [{ type: Input }]
};

const DEFAULT_ACTIONS_COLUMN_WIDTH = 150;
class ExtensibleTableComponent {
    constructor(locale, config, injector) {
        this.locale = locale;
        this.config = config;
        this.trackByFn = (_, item) => item.name;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        this.propList = extensions.entityProps.get(name).props;
        this.actionList = extensions['entityActions'].get(name)
            .actions;
        this.setColumnWidths(DEFAULT_ACTIONS_COLUMN_WIDTH);
    }
    set actionsText(value) {
        this._actionsText = value;
    }
    get actionsText() {
        var _a;
        return (_a = this._actionsText) !== null && _a !== void 0 ? _a : (this.actionList.length > 1 ? 'AbpUi::Actions' : '');
    }
    set actionsColumnWidth(width) {
        this.setColumnWidths(width ? Number(width) : undefined);
    }
    setColumnWidths(actionsColumn) {
        const widths = [actionsColumn];
        this.propList.forEach(({ value: prop }) => {
            widths.push(prop.columnWidth);
        });
        this.columnWidths = widths;
    }
    getDate(value, format) {
        return value ? formatDate(value, format, this.locale) : '';
    }
    getIcon(value) {
        return value
            ? '<div class="text-center text-success"><i class="fa fa-check"></i></div>'
            : '<div class="text-center text-danger"><i class="fa fa-times"></i></div>';
    }
    getContent(prop, data) {
        return prop.valueResolver(data).pipe(map(value => {
            switch (prop.type) {
                case "boolean" /* Boolean */:
                    return this.getIcon(value);
                case "date" /* Date */:
                    return this.getDate(value, getShortDateFormat(this.config));
                case "time" /* Time */:
                    return this.getDate(value, getShortTimeFormat(this.config));
                case "dateTime" /* DateTime */:
                    return this.getDate(value, getShortDateShortTimeFormat(this.config));
                default:
                    return value;
                // More types can be handled in the future
            }
        }));
    }
    ngOnChanges({ data }) {
        if (!(data === null || data === void 0 ? void 0 : data.currentValue))
            return;
        this.data = data.currentValue.map((record, index) => {
            this.propList.forEach(prop => {
                const propData = { getInjected: this.getInjected, record, index };
                record[`_${prop.value.name}`] = {
                    visible: prop.value.visible(propData),
                    value: this.getContent(prop.value, propData),
                };
            });
            return record;
        });
    }
}
ExtensibleTableComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'abpExtensibleTable',
                selector: 'abp-extensible-table',
                template: "<ngx-datatable default [rows]=\"data\" [count]=\"recordsTotal\" [list]=\"list\">\n  <ngx-datatable-column\n    *ngIf=\"actionsTemplate || actionList.length\"\n    [name]=\"actionsText | abpLocalization\"\n    [maxWidth]=\"columnWidths[0]\"\n    [width]=\"columnWidths[0]\"\n    [sortable]=\"false\"\n  >\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\n      <ng-container\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\n      ></ng-container>\n      <ng-template #gridActions>\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\n      </ng-template>\n    </ng-template>\n  </ngx-datatable-column>\n\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\n    <ngx-datatable-column\n      [width]=\"columnWidths[i + 1] || 200\"\n      [name]=\"prop.displayName | abpLocalization\"\n      [prop]=\"prop.name\"\n      [sortable]=\"prop.sortable\"\n    >\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\n        <ng-container *abpPermission=\"prop.permission\">\n          <div\n            *ngIf=\"row['_' + prop.name].visible\"\n            [innerHTML]=\"row['_' + prop.name].value | async\"\n            (click)=\"\n              prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\n            \"\n            [class.pointer]=\"prop.action\"\n          ></div>\n        </ng-container>\n      </ng-template>\n    </ngx-datatable-column>\n  </ng-container>\n</ngx-datatable>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ExtensibleTableComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ConfigStateService },
    { type: Injector }
];
ExtensibleTableComponent.propDecorators = {
    actionsText: [{ type: Input }],
    data: [{ type: Input }],
    list: [{ type: Input }],
    recordsTotal: [{ type: Input }],
    actionsColumnWidth: [{ type: Input }],
    actionsTemplate: [{ type: Input }]
};

// tslint:disable: directive-class-suffix
// Fix for https://github.com/angular/angular/issues/23904
// @dynamic
class AbstractActionsComponent extends ActionData {
    constructor(injector) {
        super();
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        const type = injector.get(EXTENSIONS_ACTION_TYPE);
        this.actionList = extensions[type].get(name).actions;
    }
}
AbstractActionsComponent.decorators = [
    { type: Directive }
];
AbstractActionsComponent.ctorParameters = () => [
    { type: Injector }
];
AbstractActionsComponent.propDecorators = {
    record: [{ type: Input }]
};

class GridActionsComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.icon = 'fa fa-cog';
        this.text = '';
        this.trackByFn = (_, item) => item.text;
    }
}
GridActionsComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'abpGridActions',
                selector: 'abp-grid-actions',
                template: "<div *ngIf=\"actionList.length > 1\" ngbDropdown container=\"body\" class=\"d-inline-block\">\n  <button\n    class=\"btn btn-primary btn-sm dropdown-toggle\"\n    data-toggle=\"dropdown\"\n    aria-haspopup=\"true\"\n    ngbDropdownToggle\n  >\n    <i [ngClass]=\"icon\" [class.mr-1]=\"icon\"></i>{{ text | abpLocalization }}\n  </button>\n  <div ngbDropdownMenu>\n    <ng-container\n      *ngFor=\"let action of actionList; trackBy: trackByFn\"\n      [ngTemplateOutlet]=\"btnItem\"\n      [ngTemplateOutletContext]=\"{ $implicit: action }\"\n    >\n    </ng-container>\n  </div>\n</div>\n\n<ng-container\n  *ngIf=\"actionList.length === 1\"\n  [ngTemplateOutlet]=\"btnItem\"\n  [ngTemplateOutletContext]=\"{ $implicit: actionList.get(0).value }\"\n></ng-container>\n\n<ng-template #btnItem let-action>\n  <ng-container *ngIf=\"action.visible(data)\">\n    <button\n      ngbDropdownItem\n      *abpPermission=\"action.permission\"\n      (click)=\"action.action(data)\"\n      type=\"button\"\n      class=\"{{ actionList.length === 1 ? 'btn btn-primary' : '' }}\"\n      [class.text-center]=\"actionList.length === 1\"\n    >\n      <i [ngClass]=\"action.icon\" [class.mr-1]=\"action.icon\"></i>\n      <span *ngIf=\"action.icon; else ellipsis\">{{ action.text | abpLocalization }}</span>\n      <ng-template #ellipsis>\n        <div abpEllipsis>{{ action.text | abpLocalization }}</div>\n      </ng-template>\n    </button>\n  </ng-container>\n</ng-template>\n",
                providers: [
                    {
                        provide: EXTENSIONS_ACTION_TYPE,
                        useValue: 'entityActions',
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
GridActionsComponent.ctorParameters = () => [
    { type: Injector }
];
GridActionsComponent.propDecorators = {
    icon: [{ type: Input }],
    index: [{ type: Input }],
    text: [{ type: Input }]
};

class PageToolbarComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.injector = injector;
        this.trackByFn = (_, item) => item.action || item.component;
    }
    createInjector(action) {
        const get = (token, notFoundValue, flags) => {
            return token === EXTENSIONS_ACTION_DATA
                ? this.data
                : token === EXTENSIONS_ACTION_CALLBACK
                    ? (data = this.data) => action.action(data)
                    : this.getInjected.call(this.injector, token, notFoundValue, flags);
        };
        return { get };
    }
}
PageToolbarComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'abpPageToolbar',
                selector: 'abp-page-toolbar',
                template: "<div class=\"row justify-content-end mx-n1\" id=\"AbpContentToolbar\">\n  <div class=\"col-auto px-1 pt-0 pt-md-2\" *ngFor=\"let action of actionList; trackBy: trackByFn\">\n    <ng-container *ngIf=\"action.visible(data)\">\n      <ng-container *abpPermission=\"action.permission\">\n        <ng-container *ngIf=\"action.component as component; else button\">\n          <ng-container\n            *ngComponentOutlet=\"component; injector: createInjector(action)\"\n          ></ng-container>\n        </ng-container>\n\n        <ng-template #button>\n          <button (click)=\"action.action(data)\" type=\"button\" class=\"btn btn-primary btn-sm\">\n            <i [ngClass]=\"action.icon\" [class.mr-1]=\"action.icon\"></i>\n            {{ action.text | abpLocalization }}\n          </button>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </div>\n</div>\n",
                providers: [
                    {
                        provide: EXTENSIONS_ACTION_TYPE,
                        useValue: 'toolbarActions',
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
PageToolbarComponent.ctorParameters = () => [
    { type: Injector }
];

class DisabledDirective {
    constructor(ngControl) {
        this.ngControl = ngControl;
    }
    // Related issue: https://github.com/angular/angular/issues/35330
    ngOnChanges({ abpDisabled }) {
        if (this.ngControl.control && abpDisabled) {
            this.ngControl.control[abpDisabled.currentValue ? 'disable' : 'enable']();
        }
    }
}
DisabledDirective.decorators = [
    { type: Directive, args: [{
                selector: '[abpDisabled]',
            },] }
];
DisabledDirective.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Host }] }
];
DisabledDirective.propDecorators = {
    abpDisabled: [{ type: Input }]
};

class PropDataDirective extends PropData {
    constructor(tempRef, vcRef, injector) {
        super();
        this.tempRef = tempRef;
        this.vcRef = vcRef;
        // tslint:disable-next-line
        this.getInjected = injector.get.bind(injector);
    }
    ngOnChanges() {
        this.vcRef.clear();
        this.vcRef.createEmbeddedView(this.tempRef, {
            $implicit: this.data,
            index: 0,
        });
    }
    ngOnDestroy() {
        this.vcRef.clear();
    }
}
PropDataDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'abpPropData',
                selector: '[abpPropData]',
            },] }
];
PropDataDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: Injector }
];
PropDataDirective.propDecorators = {
    propList: [{ type: Input, args: ['abpPropDataFromList',] }],
    record: [{ type: Input, args: ['abpPropDataWithRecord',] }],
    index: [{ type: Input, args: ['abpPropDataAtIndex',] }]
};

var objectExtensions = /*#__PURE__*/Object.freeze({
    __proto__: null
});

class BaseUiExtensionsModule {
}
BaseUiExtensionsModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    DateTimePickerComponent,
                    PageToolbarComponent,
                    GridActionsComponent,
                    ExtensibleFormComponent,
                    ExtensibleTableComponent,
                    PropDataDirective,
                    DisabledDirective,
                ],
                declarations: [
                    DateTimePickerComponent,
                    PageToolbarComponent,
                    GridActionsComponent,
                    ExtensibleFormPropComponent,
                    ExtensibleFormComponent,
                    ExtensibleTableComponent,
                    PropDataDirective,
                    DisabledDirective,
                ],
                imports: [
                    CoreModule,
                    ThemeSharedModule,
                    NgxValidateCoreModule,
                    NgbDatepickerModule,
                    NgbDropdownModule,
                    NgbTimepickerModule,
                    NgbTypeaheadModule,
                ],
            },] }
];
class UiExtensionsModule {
}
UiExtensionsModule.decorators = [
    { type: NgModule, args: [{
                exports: [BaseUiExtensionsModule],
                imports: [BaseUiExtensionsModule],
            },] }
];

function mergeWithDefaultActions(extension, defaultActions, ...contributors) {
    Object.keys(defaultActions).forEach((name) => {
        const actions = extension.get(name);
        actions.clearContributors();
        actions.addContributor((actionList) => actionList.addManyTail(defaultActions[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => actions.addContributor(callback)));
    });
}

function generateFormFromProps(data) {
    const extensions = data.getInjected(ExtensionsService);
    const identifier = data.getInjected(EXTENSIONS_IDENTIFIER);
    const form = new FormGroup({});
    const extraForm = new FormGroup({});
    form.addControl(EXTRA_PROPERTIES_KEY, extraForm);
    const record = data.record || {};
    const type = JSON.stringify(record) === '{}' ? 'create' : 'edit';
    const props = extensions[`${type}FormProps`].get(identifier).props;
    const extraProperties = record[EXTRA_PROPERTIES_KEY] || {};
    props.forEach(({ value: prop }) => {
        const name = prop.name;
        const isExtraProperty = prop.isExtra || name in extraProperties;
        let value = isExtraProperty ? extraProperties[name] : name in record ? record[name] : undefined;
        if (typeof value === 'undefined')
            value = prop.defaultValue;
        if (value) {
            let adapter;
            switch (prop.type) {
                case "date" /* Date */:
                    adapter = new DateAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "time" /* Time */:
                    adapter = new TimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "dateTime" /* DateTime */:
                    adapter = new DateTimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                default:
                    break;
            }
        }
        const formControl = new FormControl(value, {
            asyncValidators: prop.asyncValidators(data),
            validators: prop.validators(data),
        });
        (isExtraProperty ? extraForm : form).addControl(name, formControl);
    });
    return form;
}

function createExtraPropertyValueResolver(name) {
    return (data) => of(data.record[EXTRA_PROPERTIES_KEY][name]);
}
function mergeWithDefaultProps(extension, defaultProps, ...contributors) {
    Object.keys(defaultProps).forEach((name) => {
        const props = extension.get(name);
        props.clearContributors();
        props.addContributor((propList) => propList.addManyTail(defaultProps[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => props.addContributor(callback)));
    });
}

function createEnum(members) {
    const enumObject = {};
    members.forEach(({ name, value }) => {
        enumObject[(enumObject[name] = value)] = name;
    });
    return enumObject;
}
function createEnumValueResolver(enumType, lookupEnum, propName) {
    return data => {
        const value = data.record[EXTRA_PROPERTIES_KEY][propName];
        const key = lookupEnum.transformed[value];
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, localizeEnum(key));
    };
}
function createEnumOptions(enumType, lookupEnum) {
    return data => {
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, lookupEnum.fields.map(({ name, value }) => ({
            key: localizeEnum(name),
            value,
        })));
    };
}
function createLocalizationStream(l10n, mapTarget) {
    return merge(of(null), l10n.languageChange$).pipe(map(() => mapTarget));
}
function createEnumLocalizer(l10n, enumType, lookupEnum) {
    const resource = lookupEnum.localizationResource;
    const shortType = getShortEnumType(enumType);
    return key => l10n.localizeWithFallbackSync([resource], ['Enum:' + shortType + '.' + key, shortType + '.' + key, key], key);
}
function getShortEnumType(enumType) {
    return enumType.split('.').pop();
}

function createDisplayNameLocalizationPipeKeyGenerator(localization) {
    const generateLocalizationPipeKey = createLocalizationPipeKeyGenerator(localization);
    return (displayName, fallback) => {
        if (displayName && displayName.name)
            return generateLocalizationPipeKey([displayName.resource], [displayName.name], displayName.name);
        const key = generateLocalizationPipeKey([fallback.resource], ['DisplayName:' + fallback.name], undefined);
        if (key)
            return key;
        return generateLocalizationPipeKey([fallback.resource], [fallback.name], fallback.name);
    };
}

function getValidatorsFromProperty(property) {
    const validators = [];
    property.attributes.forEach(attr => {
        if (attr.typeSimple in AbpValidators)
            validators.push(AbpValidators[attr.typeSimple](attr.config));
    });
    return validators;
}

function selectObjectExtensions(configState) {
    return configState.getOne$('objectExtensions');
}
function selectLocalization(configState) {
    return configState.getOne$('localization');
}
function selectEnums(configState) {
    return selectObjectExtensions(configState).pipe(map((extensions) => Object.keys(extensions.enums).reduce((acc, key) => {
        const { fields, localizationResource } = extensions.enums[key];
        acc[key] = {
            fields,
            localizationResource,
            transformed: createEnum(fields),
        };
        return acc;
    }, {})));
}
function getObjectExtensionEntitiesFromStore(configState, moduleKey) {
    return selectObjectExtensions(configState).pipe(map(extensions => {
        if (!extensions)
            return null;
        return (extensions.modules[moduleKey] || {})
            .entities;
    }), map(entities => (isUndefined(entities) ? {} : entities)), filter(Boolean), take(1));
}
function mapEntitiesToContributors(configState, resource) {
    return pipe(switchMap(entities => zip(selectLocalization(configState), selectEnums(configState)).pipe(map(([localization, enums]) => {
        const generateDisplayName = createDisplayNameLocalizationPipeKeyGenerator(localization);
        return Object.keys(entities).reduce((acc, key) => {
            acc.prop[key] = [];
            acc.createForm[key] = [];
            acc.editForm[key] = [];
            const entity = entities[key];
            if (!entity)
                return acc;
            const properties = entity.properties;
            if (!properties)
                return acc;
            const mapPropertiesToContributors = createPropertiesToContributorsMapper(generateDisplayName, resource, enums);
            return mapPropertiesToContributors(properties, acc, key);
        }, {
            prop: {},
            createForm: {},
            editForm: {},
        });
    }))), take(1));
}
function createPropertiesToContributorsMapper(generateDisplayName, resource, enums) {
    return (properties, contributors, key) => {
        const isExtra = true;
        const generateTypeaheadDisplayName = createTypeaheadDisplayNameGenerator(generateDisplayName, properties);
        Object.keys(properties).forEach((name) => {
            const property = properties[name];
            const propName = name;
            const lookup = property.ui.lookup || {};
            const type = getTypeaheadType(lookup, name) || getTypeFromProperty(property);
            const generateDN = hasTypeaheadTextSuffix(name)
                ? generateTypeaheadDisplayName
                : generateDisplayName;
            const displayName = generateDN(property.displayName, { name, resource });
            if (property.ui.onTable.isVisible) {
                const sortable = Boolean(property.ui.onTable.isSortable);
                const columnWidth = type === "boolean" /* Boolean */ ? 150 : 250;
                const valueResolver = type === "enum" /* Enum */
                    ? createEnumValueResolver(property.type, enums[property.type], propName)
                    : createExtraPropertyValueResolver(propName);
                const entityProp = new EntityProp({
                    type,
                    name: propName,
                    displayName,
                    sortable,
                    columnWidth,
                    valueResolver,
                    isExtra,
                });
                const contributor = (propList) => propList.addTail(entityProp);
                contributors.prop[key].push(contributor);
            }
            const isOnCreateForm = property.ui.onCreateForm.isVisible;
            const isOnEditForm = property.ui.onEditForm.isVisible;
            if (isOnCreateForm || isOnEditForm) {
                const defaultValue = property.defaultValue;
                const validators = () => getValidatorsFromProperty(property);
                let options;
                if (type === "enum" /* Enum */)
                    options = createEnumOptions(propName, enums[property.type]);
                else if (type === "typeahead" /* Typeahead */)
                    options = createTypeaheadOptions(lookup);
                const formProp = new FormProp({
                    type,
                    name: propName,
                    displayName,
                    options,
                    defaultValue,
                    validators,
                    isExtra,
                });
                const formContributor = (propList) => propList.addTail(formProp);
                if (isOnCreateForm)
                    contributors.createForm[key].push(formContributor);
                if (isOnEditForm)
                    contributors.editForm[key].push(formContributor);
            }
        });
        return contributors;
    };
}
function getTypeFromProperty(property) {
    return property.typeSimple.replace(/\?$/, '');
}
function isUndefined(obj) {
    return typeof obj === 'undefined';
}

/**
 * Generated bundle index. Do not edit.
 */

export { ActionList, BaseUiExtensionsModule, CreateFormPropsFactory, DateAdapter, DateTimeAdapter, DateTimePickerComponent, DisabledDirective, EXTENSIONS_ACTION_CALLBACK, EXTENSIONS_ACTION_DATA, EXTENSIONS_ACTION_TYPE, EXTENSIONS_IDENTIFIER, EXTRA_PROPERTIES_KEY, EditFormPropsFactory, EntityAction, EntityActionList, EntityActions, EntityActionsFactory, EntityProp, EntityPropList, EntityProps, EntityPropsFactory, ExtensibleFormComponent, ExtensibleFormPropComponent, ExtensibleTableComponent, ExtensionsService, FormProp, FormPropData, FormPropList, FormProps, GridActionsComponent, objectExtensions as ObjectExtensions, PageToolbarComponent, PropDataDirective, PropList, TimeAdapter, ToolbarAction, ToolbarActionList, ToolbarActions, ToolbarActionsFactory, ToolbarComponent, UiExtensionsModule, createExtraPropertyValueResolver, generateFormFromProps, getObjectExtensionEntitiesFromStore, mapEntitiesToContributors, mergeWithDefaultActions, mergeWithDefaultProps, ActionData as ɵa, Action as ɵb, ActionsFactory as ɵc, Actions as ɵd, PropData as ɵe, Prop as ɵf, PropsFactory as ɵg, Props as ɵh, selfFactory as ɵi, AbstractActionsComponent as ɵj };
//# sourceMappingURL=abp-ng.theme.shared-extensions.js.map
